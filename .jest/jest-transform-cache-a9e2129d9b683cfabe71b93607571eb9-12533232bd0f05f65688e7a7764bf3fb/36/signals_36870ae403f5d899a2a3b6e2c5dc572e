a9a433da29890527fb1bf4e5650ec3a7
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var signals_exports = {};
__export(signals_exports, {
  BASE_EFFECT_NODE: () => import_effect.BASE_EFFECT_NODE,
  REACTIVE_NODE: () => import_signal.REACTIVE_NODE,
  SIGNAL: () => import_signal.SIGNAL,
  SIGNAL_NODE: () => import_signal2.SIGNAL_NODE,
  consumerAfterComputation: () => import_signal.consumerAfterComputation,
  consumerBeforeComputation: () => import_signal.consumerBeforeComputation,
  consumerDestroy: () => import_signal.consumerDestroy,
  consumerMarkDirty: () => import_signal.consumerMarkDirty,
  consumerPollProducersForChange: () => import_signal.consumerPollProducersForChange,
  createComputed: () => import_signal2.createComputed,
  createLinkedSignal: () => import_effect.createLinkedSignal,
  createSignal: () => import_signal2.createSignal,
  createWatch: () => createWatch,
  defaultEquals: () => import_signal2.defaultEquals,
  finalizeConsumerAfterComputation: () => import_signal2.finalizeConsumerAfterComputation,
  getActiveConsumer: () => import_signal2.getActiveConsumer,
  installDevToolsSignalFormatter: () => installDevToolsSignalFormatter,
  isInNotificationPhase: () => import_signal.isInNotificationPhase,
  isReactive: () => import_signal2.isReactive,
  linkedSignalSetFn: () => import_effect.linkedSignalSetFn,
  linkedSignalUpdateFn: () => import_effect.linkedSignalUpdateFn,
  producerAccessed: () => import_signal2.producerAccessed,
  producerIncrementEpoch: () => import_signal2.producerIncrementEpoch,
  producerMarkClean: () => import_signal2.producerMarkClean,
  producerNotifyConsumers: () => import_signal2.producerNotifyConsumers,
  producerUpdateValueVersion: () => import_signal2.producerUpdateValueVersion,
  producerUpdatesAllowed: () => import_signal2.producerUpdatesAllowed,
  resetConsumerBeforeComputation: () => import_signal2.resetConsumerBeforeComputation,
  runEffect: () => import_effect.runEffect,
  runPostProducerCreatedFn: () => import_signal2.runPostProducerCreatedFn,
  runPostSignalSetFn: () => import_signal2.runPostSignalSetFn,
  setActiveConsumer: () => import_signal2.setActiveConsumer,
  setAlternateWeakRefImpl: () => import_weak_ref.setAlternateWeakRefImpl,
  setPostProducerCreatedFn: () => import_signal2.setPostProducerCreatedFn,
  setPostSignalSetFn: () => import_signal2.setPostSignalSetFn,
  setThrowInvalidWriteToSignalError: () => import_signal2.setThrowInvalidWriteToSignalError,
  signalGetFn: () => import_signal2.signalGetFn,
  signalSetFn: () => import_signal2.signalSetFn,
  signalUpdateFn: () => import_signal2.signalUpdateFn,
  untracked: () => import_effect.untracked
});
module.exports = __toCommonJS(signals_exports);
var import_signal = require("../signal.mjs");
var import_signal2 = require("../signal.mjs");
var import_effect = require("../effect.mjs");
var import_weak_ref = require("../weak_ref.mjs");
/**
 * @license Angular v20.3.16
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */
const formatter = {
  /**
   *  If the function returns `null`, the formatter is not used for this reference
   */
  header: (sig, config) => {
    if (!isSignal(sig) || (config == null ? void 0 : config.ngSkipFormatting))
      return null;
    let value;
    try {
      value = sig();
    } catch (e) {
      return ["span", "Signal(\u26A0\uFE0F Error)"];
    }
    const kind = "computation" in sig[import_signal.SIGNAL] ? "Computed" : "Signal";
    const isPrimitive = value === null || !Array.isArray(value) && typeof value !== "object";
    return [
      "span",
      {},
      ["span", {}, `${kind}(`],
      (() => {
        if (isSignal(value)) {
          return formatter.header(value, config);
        } else if (isPrimitive && value !== void 0 && typeof value !== "function") {
          return ["object", { object: value }];
        } else {
          return prettifyPreview(value);
        }
      })(),
      ["span", {}, `)`]
    ];
  },
  hasBody: (sig, config) => {
    if (!isSignal(sig))
      return false;
    try {
      sig();
    } catch (e) {
      return false;
    }
    return !(config == null ? void 0 : config.ngSkipFormatting);
  },
  body: (sig, config) => {
    const color = "var(--sys-color-primary)";
    return [
      "div",
      { style: `background: #FFFFFF10; padding-left: 4px; padding-top: 2px; padding-bottom: 2px;` },
      ["div", { style: `color: ${color}` }, "Signal value: "],
      ["div", { style: `padding-left: .5rem;` }, ["object", { object: sig(), config }]],
      ["div", { style: `color: ${color}` }, "Signal function: "],
      [
        "div",
        { style: `padding-left: .5rem;` },
        ["object", { object: sig, config: __spreadProps(__spreadValues({}, config), { skipFormatting: true }) }]
      ]
    ];
  }
};
function prettifyPreview(value) {
  if (value === null)
    return "null";
  if (Array.isArray(value))
    return `Array(${value.length})`;
  if (value instanceof Element)
    return `<${value.tagName.toLowerCase()}>`;
  if (value instanceof URL)
    return `URL`;
  switch (typeof value) {
    case "undefined": {
      return "undefined";
    }
    case "function": {
      if ("prototype" in value) {
        return "class";
      } else {
        return "() => {\u2026}";
      }
    }
    case "object": {
      if (value.constructor.name === "Object") {
        return "{\u2026}";
      } else {
        return `${value.constructor.name} {}`;
      }
    }
    default: {
      return ["object", { object: value, config: { skipFormatting: true } }];
    }
  }
}
function isSignal(value) {
  return value[import_signal.SIGNAL] !== void 0;
}
function installDevToolsSignalFormatter() {
  var _a;
  (_a = globalThis.devtoolsFormatters) != null ? _a : globalThis.devtoolsFormatters = [];
  if (!globalThis.devtoolsFormatters.some((f) => f === formatter)) {
    globalThis.devtoolsFormatters.push(formatter);
  }
}
function createWatch(fn, schedule, allowSignalWrites) {
  const node = Object.create(WATCH_NODE);
  if (allowSignalWrites) {
    node.consumerAllowSignalWrites = true;
  }
  node.fn = fn;
  node.schedule = schedule;
  const registerOnCleanup = (cleanupFn) => {
    node.cleanupFn = cleanupFn;
  };
  function isWatchNodeDestroyed(node2) {
    return node2.fn === null && node2.schedule === null;
  }
  function destroyWatchNode(node2) {
    if (!isWatchNodeDestroyed(node2)) {
      (0, import_signal.consumerDestroy)(node2);
      node2.cleanupFn();
      node2.fn = null;
      node2.schedule = null;
      node2.cleanupFn = NOOP_CLEANUP_FN;
    }
  }
  const run = () => {
    if (node.fn === null) {
      return;
    }
    if ((0, import_signal.isInNotificationPhase)()) {
      throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? "Schedulers cannot synchronously execute watches while scheduling." : "");
    }
    node.dirty = false;
    if (node.version > 0 && !(0, import_signal.consumerPollProducersForChange)(node)) {
      return;
    }
    node.version++;
    const prevConsumer = (0, import_signal.consumerBeforeComputation)(node);
    try {
      node.cleanupFn();
      node.cleanupFn = NOOP_CLEANUP_FN;
      node.fn(registerOnCleanup);
    } finally {
      (0, import_signal.consumerAfterComputation)(node, prevConsumer);
    }
  };
  node.ref = {
    notify: () => (0, import_signal.consumerMarkDirty)(node),
    run,
    cleanup: () => node.cleanupFn(),
    destroy: () => destroyWatchNode(node),
    [import_signal.SIGNAL]: node
  };
  return node.ref;
}
const NOOP_CLEANUP_FN = () => {
};
const WATCH_NODE = /* @__PURE__ */ (() => {
  return __spreadProps(__spreadValues({}, import_signal.REACTIVE_NODE), {
    consumerIsAlwaysLive: true,
    consumerAllowSignalWrites: false,
    consumerMarkedDirty: (node) => {
      if (node.schedule !== null) {
        node.schedule(node.ref);
      }
    },
    cleanupFn: NOOP_CLEANUP_FN
  });
})();
if (typeof ngDevMode !== "undefined" && ngDevMode) {
  installDevToolsSignalFormatter();
}
