0fb0d3c6cfd0e3f63d6e01a175a2971b
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var debug_node_exports = {};
__export(debug_node_exports, {
  AFTER_RENDER_PHASES: () => AFTER_RENDER_PHASES,
  ANIMATIONS_DISABLED: () => ANIMATIONS_DISABLED,
  ANIMATION_MODULE_TYPE: () => ANIMATION_MODULE_TYPE,
  APP_BOOTSTRAP_LISTENER: () => APP_BOOTSTRAP_LISTENER,
  APP_ID: () => APP_ID,
  APP_INITIALIZER: () => APP_INITIALIZER,
  AcxChangeDetectionStrategy: () => AcxChangeDetectionStrategy,
  AcxViewEncapsulation: () => AcxViewEncapsulation,
  AfterRenderImpl: () => AfterRenderImpl,
  AfterRenderManager: () => AfterRenderManager,
  AfterRenderSequence: () => AfterRenderSequence,
  ApplicationInitStatus: () => ApplicationInitStatus,
  ApplicationRef: () => ApplicationRef,
  Attribute: () => Attribute,
  COMPILER_OPTIONS: () => COMPILER_OPTIONS,
  CONTAINERS: () => CONTAINERS,
  CSP_NONCE: () => CSP_NONCE,
  CUSTOM_ELEMENTS_SCHEMA: () => CUSTOM_ELEMENTS_SCHEMA,
  ChangeDetectionSchedulerImpl: () => ChangeDetectionSchedulerImpl,
  ChangeDetectionStrategy: () => ChangeDetectionStrategy,
  Compiler: () => Compiler,
  CompilerFactory: () => CompilerFactory,
  Component: () => Component,
  ComponentFactory: () => ComponentFactory2,
  ComponentFactory$1: () => ComponentFactory$1,
  ComponentFactoryResolver: () => ComponentFactoryResolver$1,
  ComponentRef: () => ComponentRef$1,
  ComponentRef$1: () => ComponentRef2,
  Console: () => Console,
  DEFAULT_CURRENCY_CODE: () => DEFAULT_CURRENCY_CODE,
  DEFAULT_LOCALE_ID: () => DEFAULT_LOCALE_ID,
  DEFER_BLOCK_CONFIG: () => DEFER_BLOCK_CONFIG,
  DEFER_BLOCK_DEPENDENCY_INTERCEPTOR: () => DEFER_BLOCK_DEPENDENCY_INTERCEPTOR,
  DEFER_BLOCK_ID: () => DEFER_BLOCK_ID,
  DEFER_BLOCK_SSR_ID_ATTRIBUTE: () => DEFER_BLOCK_SSR_ID_ATTRIBUTE,
  DEFER_BLOCK_STATE: () => DEFER_BLOCK_STATE$1,
  DEFER_BLOCK_STATE$1: () => DEFER_BLOCK_STATE,
  DEFER_HYDRATE_TRIGGERS: () => DEFER_HYDRATE_TRIGGERS,
  DEFER_PARENT_BLOCK_ID: () => DEFER_PARENT_BLOCK_ID,
  DEHYDRATED_BLOCK_REGISTRY: () => DEHYDRATED_BLOCK_REGISTRY,
  DISCONNECTED_NODES: () => DISCONNECTED_NODES,
  DebugElement: () => DebugElement,
  DebugEventListener: () => DebugEventListener,
  DebugNode: () => DebugNode,
  DeferBlockBehavior: () => DeferBlockBehavior,
  DeferBlockState: () => DeferBlockState,
  DehydratedBlockRegistry: () => DehydratedBlockRegistry,
  Directive: () => Directive,
  ELEMENT_CONTAINERS: () => ELEMENT_CONTAINERS,
  EVENT_REPLAY_ENABLED_DEFAULT: () => EVENT_REPLAY_ENABLED_DEFAULT,
  ElementRef: () => ElementRef,
  EnvironmentNgModuleRefAdapter: () => EnvironmentNgModuleRefAdapter,
  EventEmitter: () => EventEmitter,
  Framework: () => Framework,
  Host: () => Host,
  HostBinding: () => HostBinding,
  HostListener: () => HostListener,
  HydrationStatus: () => HydrationStatus,
  I18N_DATA: () => I18N_DATA,
  IMAGE_CONFIG: () => IMAGE_CONFIG,
  IMAGE_CONFIG_DEFAULTS: () => IMAGE_CONFIG_DEFAULTS,
  IS_ENABLED_BLOCKING_INITIAL_NAVIGATION: () => IS_ENABLED_BLOCKING_INITIAL_NAVIGATION,
  IS_EVENT_REPLAY_ENABLED: () => IS_EVENT_REPLAY_ENABLED,
  IS_HYDRATION_DOM_REUSE_ENABLED: () => IS_HYDRATION_DOM_REUSE_ENABLED,
  IS_I18N_HYDRATION_ENABLED: () => IS_I18N_HYDRATION_ENABLED,
  IS_INCREMENTAL_HYDRATION_ENABLED: () => IS_INCREMENTAL_HYDRATION_ENABLED,
  Inject: () => Inject,
  Injectable: () => Injectable,
  Input: () => Input,
  JSACTION_BLOCK_ELEMENT_MAP: () => JSACTION_BLOCK_ELEMENT_MAP,
  JSACTION_EVENT_CONTRACT: () => JSACTION_EVENT_CONTRACT,
  LContext: () => LContext,
  LOCALE_ID: () => LOCALE_ID,
  LocaleDataIndex: () => LocaleDataIndex,
  MAX_ANIMATION_TIMEOUT: () => MAX_ANIMATION_TIMEOUT,
  MULTIPLIER: () => MULTIPLIER,
  MissingTranslationStrategy: () => MissingTranslationStrategy,
  ModuleWithComponentFactories: () => ModuleWithComponentFactories,
  NGH_ATTR_NAME: () => NGH_ATTR_NAME,
  NGH_DATA_KEY: () => NGH_DATA_KEY,
  NGH_DEFER_BLOCKS_KEY: () => NGH_DEFER_BLOCKS_KEY,
  NODES: () => NODES,
  NOOP_AFTER_RENDER_REF: () => NOOP_AFTER_RENDER_REF,
  NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: () => NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,
  NO_CHANGE: () => NO_CHANGE,
  NO_ERRORS_SCHEMA: () => NO_ERRORS_SCHEMA,
  NUM_ROOT_NODES: () => NUM_ROOT_NODES,
  NgModule: () => NgModule,
  NgModuleFactory: () => NgModuleFactory2,
  NgModuleFactory$1: () => NgModuleFactory$1,
  NgModuleRef: () => NgModuleRef2,
  NgModuleRef$1: () => NgModuleRef$1,
  NgProbeToken: () => NgProbeToken,
  NgZone: () => NgZone,
  NoopNgZone: () => NoopNgZone,
  Optional: () => Optional,
  Output: () => Output,
  PACKAGE_ROOT_URL: () => PACKAGE_ROOT_URL,
  PLATFORM_ID: () => PLATFORM_ID,
  PLATFORM_INITIALIZER: () => PLATFORM_INITIALIZER,
  PRESERVE_HOST_CONTENT: () => PRESERVE_HOST_CONTENT,
  PROVIDED_NG_ZONE: () => PROVIDED_NG_ZONE,
  Pipe: () => Pipe,
  QueryList: () => QueryList,
  ReflectionCapabilities: () => ReflectionCapabilities,
  Renderer2: () => Renderer2,
  RendererFactory2: () => RendererFactory2,
  RendererStyleFlags2: () => RendererStyleFlags2,
  SKIP_HYDRATION_ATTR_NAME: () => SKIP_HYDRATION_ATTR_NAME,
  SSR_CONTENT_INTEGRITY_MARKER: () => SSR_CONTENT_INTEGRITY_MARKER,
  Sanitizer: () => Sanitizer,
  SecurityContext: () => SecurityContext,
  Self: () => Self,
  SimpleChange: () => SimpleChange,
  SkipSelf: () => SkipSelf,
  TEMPLATES: () => TEMPLATES,
  TEMPLATE_ID: () => TEMPLATE_ID,
  TESTABILITY: () => TESTABILITY,
  TESTABILITY_GETTER: () => TESTABILITY_GETTER,
  TRANSLATIONS: () => TRANSLATIONS,
  TRANSLATIONS_FORMAT: () => TRANSLATIONS_FORMAT,
  TemplateRef: () => TemplateRef,
  Testability: () => Testability,
  TestabilityRegistry: () => TestabilityRegistry,
  TimerScheduler: () => TimerScheduler,
  TracingAction: () => TracingAction,
  TracingService: () => TracingService,
  TransferState: () => TransferState,
  Type: () => Type,
  UseExhaustiveCheckNoChanges: () => UseExhaustiveCheckNoChanges,
  ViewContainerRef: () => ViewContainerRef,
  ViewEncapsulation: () => ViewEncapsulation,
  ViewRef: () => ViewRef,
  _sanitizeHtml: () => _sanitizeHtml,
  _sanitizeUrl: () => _sanitizeUrl,
  afterEveryRender: () => afterEveryRender,
  afterNextRender: () => afterNextRender,
  allLeavingAnimations: () => allLeavingAnimations,
  allowSanitizationBypassAndThrow: () => allowSanitizationBypassAndThrow,
  angularCoreEnv: () => angularCoreEnv,
  appendDeferBlocksToJSActionMap: () => appendDeferBlocksToJSActionMap,
  asNativeElements: () => asNativeElements,
  assertComponentDef: () => assertComponentDef,
  assertStandaloneComponentType: () => assertStandaloneComponentType,
  bypassSanitizationTrustHtml: () => bypassSanitizationTrustHtml,
  bypassSanitizationTrustResourceUrl: () => bypassSanitizationTrustResourceUrl,
  bypassSanitizationTrustScript: () => bypassSanitizationTrustScript,
  bypassSanitizationTrustStyle: () => bypassSanitizationTrustStyle,
  bypassSanitizationTrustUrl: () => bypassSanitizationTrustUrl,
  calcPathForNode: () => calcPathForNode,
  checkNoChangesInternal: () => checkNoChangesInternal,
  cleanupDehydratedViews: () => cleanupDehydratedViews,
  clearResolutionOfComponentResourcesQueue: () => clearResolutionOfComponentResourcesQueue,
  collectNativeNodes: () => collectNativeNodes,
  collectNativeNodesInLContainer: () => collectNativeNodesInLContainer,
  compileComponent: () => compileComponent,
  compileDirective: () => compileDirective,
  compileNgModule: () => compileNgModule,
  compileNgModuleDefs: () => compileNgModuleDefs,
  compilePipe: () => compilePipe,
  convertHydrateTriggersToJsAction: () => convertHydrateTriggersToJsAction,
  countBlocksSkippedByHydration: () => countBlocksSkippedByHydration,
  createEnvironmentInjector: () => createEnvironmentInjector,
  createMultiResultQuerySignalFn: () => createMultiResultQuerySignalFn,
  createNgModule: () => createNgModule,
  createNgModuleRef: () => createNgModuleRef,
  createNgModuleRefWithProviders: () => createNgModuleRefWithProviders,
  createSingleResultOptionalQuerySignalFn: () => createSingleResultOptionalQuerySignalFn,
  createSingleResultRequiredQuerySignalFn: () => createSingleResultRequiredQuerySignalFn,
  depsTracker: () => depsTracker,
  devModeEqual: () => devModeEqual,
  enableApplyRootElementTransformImpl: () => enableApplyRootElementTransformImpl,
  enableClaimDehydratedIcuCaseImpl: () => enableClaimDehydratedIcuCaseImpl,
  enableFindMatchingDehydratedViewImpl: () => enableFindMatchingDehydratedViewImpl,
  enableLocateOrCreateContainerAnchorImpl: () => enableLocateOrCreateContainerAnchorImpl,
  enableLocateOrCreateContainerRefImpl: () => enableLocateOrCreateContainerRefImpl,
  enableLocateOrCreateElementContainerNodeImpl: () => enableLocateOrCreateElementContainerNodeImpl,
  enableLocateOrCreateElementNodeImpl: () => enableLocateOrCreateElementNodeImpl,
  enableLocateOrCreateI18nNodeImpl: () => enableLocateOrCreateI18nNodeImpl,
  enableLocateOrCreateTextNodeImpl: () => enableLocateOrCreateTextNodeImpl,
  enablePrepareI18nBlockForHydrationImpl: () => enablePrepareI18nBlockForHydrationImpl,
  enableProfiling: () => enableProfiling,
  enableRetrieveDeferBlockDataImpl: () => enableRetrieveDeferBlockDataImpl,
  enableRetrieveHydrationInfoImpl: () => enableRetrieveHydrationInfoImpl,
  enableStashEventListenerImpl: () => enableStashEventListenerImpl,
  findLocaleData: () => findLocaleData,
  flushModuleScopingQueueAsMuchAsPossible: () => flushModuleScopingQueueAsMuchAsPossible,
  gatherDeferBlocksCommentNodes: () => gatherDeferBlocksCommentNodes,
  generateStandaloneInDeclarationsError: () => generateStandaloneInDeclarationsError,
  getAsyncClassMetadataFn: () => getAsyncClassMetadataFn,
  getCompilerFacade: () => getCompilerFacade,
  getDebugNode: () => getDebugNode,
  getDeferBlocks: () => getDeferBlocks$1,
  getDirectives: () => getDirectives,
  getDocument: () => getDocument,
  getHostElement: () => getHostElement,
  getLContext: () => getLContext,
  getLDeferBlockDetails: () => getLDeferBlockDetails,
  getLNodeForHydration: () => getLNodeForHydration,
  getLocaleCurrencyCode: () => getLocaleCurrencyCode,
  getLocalePluralCase: () => getLocalePluralCase,
  getNgZone: () => getNgZone,
  getNgZoneOptions: () => getNgZoneOptions,
  getOrComputeI18nChildren: () => getOrComputeI18nChildren,
  getRegisteredNgModuleType: () => getRegisteredNgModuleType,
  getSanitizationBypassType: () => getSanitizationBypassType,
  getTDeferBlockDetails: () => getTDeferBlockDetails,
  getTransferState: () => getTransferState,
  inferTagNameFromDefinition: () => inferTagNameFromDefinition,
  inputBinding: () => inputBinding,
  internalProvideZoneChangeDetection: () => internalProvideZoneChangeDetection,
  invokeListeners: () => invokeListeners,
  isBoundToModule: () => isBoundToModule,
  isComponentDefPendingResolution: () => isComponentDefPendingResolution,
  isComponentResourceResolutionQueueEmpty: () => isComponentResourceResolutionQueueEmpty,
  isDeferBlock: () => isDeferBlock,
  isDetachedByI18n: () => isDetachedByI18n,
  isDisconnectedNode: () => isDisconnectedNode,
  isI18nHydrationEnabled: () => isI18nHydrationEnabled,
  isI18nHydrationSupportEnabled: () => isI18nHydrationSupportEnabled,
  isInSkipHydrationBlock: () => isInSkipHydrationBlock,
  isIncrementalHydrationEnabled: () => isIncrementalHydrationEnabled,
  isJsObject: () => isJsObject,
  isLetDeclaration: () => isLetDeclaration,
  isListLikeIterable: () => isListLikeIterable,
  isNgModule: () => isNgModule,
  isPromise: () => isPromise,
  isSubscribable: () => isSubscribable,
  isTNodeShape: () => isTNodeShape,
  isViewDirty: () => isViewDirty,
  iterateListLike: () => iterateListLike,
  makePropDecorator: () => makePropDecorator,
  makeStateKey: () => makeStateKey,
  markForRefresh: () => markForRefresh,
  noSideEffects: () => noSideEffects,
  optionsReducer: () => optionsReducer,
  outputBinding: () => outputBinding,
  patchComponentDefWithScope: () => patchComponentDefWithScope,
  performanceMarkFeature: () => performanceMarkFeature,
  processAndInitTriggers: () => processAndInitTriggers,
  processBlockData: () => processBlockData,
  processTextNodeBeforeSerialization: () => processTextNodeBeforeSerialization,
  profiler: () => profiler,
  provideAppInitializer: () => provideAppInitializer,
  provideNgReflectAttributes: () => provideNgReflectAttributes,
  provideZoneChangeDetection: () => provideZoneChangeDetection,
  provideZonelessChangeDetection: () => provideZonelessChangeDetection,
  publishDefaultGlobalUtils: () => publishDefaultGlobalUtils,
  publishExternalGlobalUtil: () => publishExternalGlobalUtil,
  publishSignalConfiguration: () => publishSignalConfiguration,
  readHydrationInfo: () => readHydrationInfo,
  readPatchedLView: () => readPatchedLView,
  registerLocaleData: () => registerLocaleData,
  registerNgModuleType: () => registerNgModuleType,
  remove: () => remove,
  removeListeners: () => removeListeners,
  renderDeferBlockState: () => renderDeferBlockState,
  resetCompiledComponents: () => resetCompiledComponents,
  resetIncrementalHydrationEnabledWarnedForTests: () => resetIncrementalHydrationEnabledWarnedForTests,
  resetJitOptions: () => resetJitOptions,
  resolveComponentResources: () => resolveComponentResources,
  restoreComponentResolutionQueue: () => restoreComponentResolutionQueue,
  setAllowDuplicateNgModuleIdsForTest: () => setAllowDuplicateNgModuleIdsForTest,
  setClassMetadata: () => setClassMetadata,
  setClassMetadataAsync: () => setClassMetadataAsync,
  setDocument: () => setDocument,
  setIsI18nHydrationSupportEnabled: () => setIsI18nHydrationSupportEnabled,
  setJSActionAttributes: () => setJSActionAttributes,
  setJitOptions: () => setJitOptions,
  setLocaleId: () => setLocaleId,
  setStashFn: () => setStashFn,
  setTestabilityGetter: () => setTestabilityGetter,
  sharedMapFunction: () => sharedMapFunction,
  sharedStashFunction: () => sharedStashFunction,
  transitiveScopesFor: () => transitiveScopesFor,
  triggerHydrationFromBlockName: () => triggerHydrationFromBlockName,
  triggerResourceLoading: () => triggerResourceLoading,
  trySerializeI18nBlock: () => trySerializeI18nBlock,
  twoWayBinding: () => twoWayBinding,
  unregisterAllLocaleData: () => unregisterAllLocaleData,
  unsupportedProjectionOfDomNodes: () => unsupportedProjectionOfDomNodes,
  unwrapSafeValue: () => unwrapSafeValue,
  validateMatchingNode: () => validateMatchingNode,
  validateNodeExists: () => validateNodeExists,
  verifySsrContentsIntegrity: () => verifySsrContentsIntegrity,
  \u0275getUnknownElementStrictMode: () => \u0275getUnknownElementStrictMode,
  \u0275getUnknownPropertyStrictMode: () => \u0275getUnknownPropertyStrictMode,
  \u0275setClassDebugInfo: () => \u0275setClassDebugInfo,
  \u0275setUnknownElementStrictMode: () => \u0275setUnknownElementStrictMode,
  \u0275setUnknownPropertyStrictMode: () => \u0275setUnknownPropertyStrictMode,
  \u0275\u0275CopyDefinitionFeature: () => \u0275\u0275CopyDefinitionFeature,
  \u0275\u0275ExternalStylesFeature: () => \u0275\u0275ExternalStylesFeature,
  \u0275\u0275HostDirectivesFeature: () => \u0275\u0275HostDirectivesFeature,
  \u0275\u0275InheritDefinitionFeature: () => \u0275\u0275InheritDefinitionFeature,
  \u0275\u0275NgOnChangesFeature: () => \u0275\u0275NgOnChangesFeature,
  \u0275\u0275ProvidersFeature: () => \u0275\u0275ProvidersFeature,
  \u0275\u0275advance: () => \u0275\u0275advance,
  \u0275\u0275animateEnter: () => \u0275\u0275animateEnter,
  \u0275\u0275animateEnterListener: () => \u0275\u0275animateEnterListener,
  \u0275\u0275animateLeave: () => \u0275\u0275animateLeave,
  \u0275\u0275animateLeaveListener: () => \u0275\u0275animateLeaveListener,
  \u0275\u0275ariaProperty: () => \u0275\u0275ariaProperty,
  \u0275\u0275attachSourceLocations: () => \u0275\u0275attachSourceLocations,
  \u0275\u0275attribute: () => \u0275\u0275attribute,
  \u0275\u0275classMap: () => \u0275\u0275classMap,
  \u0275\u0275classProp: () => \u0275\u0275classProp,
  \u0275\u0275componentInstance: () => \u0275\u0275componentInstance,
  \u0275\u0275conditional: () => \u0275\u0275conditional,
  \u0275\u0275conditionalBranchCreate: () => \u0275\u0275conditionalBranchCreate,
  \u0275\u0275conditionalCreate: () => \u0275\u0275conditionalCreate,
  \u0275\u0275contentQuery: () => \u0275\u0275contentQuery,
  \u0275\u0275contentQuerySignal: () => \u0275\u0275contentQuerySignal,
  \u0275\u0275declareLet: () => \u0275\u0275declareLet,
  \u0275\u0275defer: () => \u0275\u0275defer,
  \u0275\u0275deferEnableTimerScheduling: () => \u0275\u0275deferEnableTimerScheduling,
  \u0275\u0275deferHydrateNever: () => \u0275\u0275deferHydrateNever,
  \u0275\u0275deferHydrateOnHover: () => \u0275\u0275deferHydrateOnHover,
  \u0275\u0275deferHydrateOnIdle: () => \u0275\u0275deferHydrateOnIdle,
  \u0275\u0275deferHydrateOnImmediate: () => \u0275\u0275deferHydrateOnImmediate,
  \u0275\u0275deferHydrateOnInteraction: () => \u0275\u0275deferHydrateOnInteraction,
  \u0275\u0275deferHydrateOnTimer: () => \u0275\u0275deferHydrateOnTimer,
  \u0275\u0275deferHydrateOnViewport: () => \u0275\u0275deferHydrateOnViewport,
  \u0275\u0275deferHydrateWhen: () => \u0275\u0275deferHydrateWhen,
  \u0275\u0275deferOnHover: () => \u0275\u0275deferOnHover,
  \u0275\u0275deferOnIdle: () => \u0275\u0275deferOnIdle,
  \u0275\u0275deferOnImmediate: () => \u0275\u0275deferOnImmediate,
  \u0275\u0275deferOnInteraction: () => \u0275\u0275deferOnInteraction,
  \u0275\u0275deferOnTimer: () => \u0275\u0275deferOnTimer,
  \u0275\u0275deferOnViewport: () => \u0275\u0275deferOnViewport,
  \u0275\u0275deferPrefetchOnHover: () => \u0275\u0275deferPrefetchOnHover,
  \u0275\u0275deferPrefetchOnIdle: () => \u0275\u0275deferPrefetchOnIdle,
  \u0275\u0275deferPrefetchOnImmediate: () => \u0275\u0275deferPrefetchOnImmediate,
  \u0275\u0275deferPrefetchOnInteraction: () => \u0275\u0275deferPrefetchOnInteraction,
  \u0275\u0275deferPrefetchOnTimer: () => \u0275\u0275deferPrefetchOnTimer,
  \u0275\u0275deferPrefetchOnViewport: () => \u0275\u0275deferPrefetchOnViewport,
  \u0275\u0275deferPrefetchWhen: () => \u0275\u0275deferPrefetchWhen,
  \u0275\u0275deferWhen: () => \u0275\u0275deferWhen,
  \u0275\u0275defineComponent: () => \u0275\u0275defineComponent,
  \u0275\u0275defineDirective: () => \u0275\u0275defineDirective,
  \u0275\u0275defineNgModule: () => \u0275\u0275defineNgModule,
  \u0275\u0275definePipe: () => \u0275\u0275definePipe,
  \u0275\u0275directiveInject: () => \u0275\u0275directiveInject,
  \u0275\u0275domElement: () => \u0275\u0275domElement,
  \u0275\u0275domElementContainer: () => \u0275\u0275domElementContainer,
  \u0275\u0275domElementContainerEnd: () => \u0275\u0275domElementContainerEnd,
  \u0275\u0275domElementContainerStart: () => \u0275\u0275domElementContainerStart,
  \u0275\u0275domElementEnd: () => \u0275\u0275domElementEnd,
  \u0275\u0275domElementStart: () => \u0275\u0275domElementStart,
  \u0275\u0275domListener: () => \u0275\u0275domListener,
  \u0275\u0275domProperty: () => \u0275\u0275domProperty,
  \u0275\u0275domTemplate: () => \u0275\u0275domTemplate,
  \u0275\u0275element: () => \u0275\u0275element,
  \u0275\u0275elementContainer: () => \u0275\u0275elementContainer,
  \u0275\u0275elementContainerEnd: () => \u0275\u0275elementContainerEnd,
  \u0275\u0275elementContainerStart: () => \u0275\u0275elementContainerStart,
  \u0275\u0275elementEnd: () => \u0275\u0275elementEnd,
  \u0275\u0275elementStart: () => \u0275\u0275elementStart,
  \u0275\u0275getComponentDepsFactory: () => \u0275\u0275getComponentDepsFactory,
  \u0275\u0275getCurrentView: () => \u0275\u0275getCurrentView,
  \u0275\u0275getInheritedFactory: () => \u0275\u0275getInheritedFactory,
  \u0275\u0275getReplaceMetadataURL: () => \u0275\u0275getReplaceMetadataURL,
  \u0275\u0275i18n: () => \u0275\u0275i18n,
  \u0275\u0275i18nApply: () => \u0275\u0275i18nApply,
  \u0275\u0275i18nAttributes: () => \u0275\u0275i18nAttributes,
  \u0275\u0275i18nEnd: () => \u0275\u0275i18nEnd,
  \u0275\u0275i18nExp: () => \u0275\u0275i18nExp,
  \u0275\u0275i18nPostprocess: () => \u0275\u0275i18nPostprocess,
  \u0275\u0275i18nStart: () => \u0275\u0275i18nStart,
  \u0275\u0275injectAttribute: () => \u0275\u0275injectAttribute,
  \u0275\u0275interpolate: () => \u0275\u0275interpolate,
  \u0275\u0275interpolate1: () => \u0275\u0275interpolate1,
  \u0275\u0275interpolate2: () => \u0275\u0275interpolate2,
  \u0275\u0275interpolate3: () => \u0275\u0275interpolate3,
  \u0275\u0275interpolate4: () => \u0275\u0275interpolate4,
  \u0275\u0275interpolate5: () => \u0275\u0275interpolate5,
  \u0275\u0275interpolate6: () => \u0275\u0275interpolate6,
  \u0275\u0275interpolate7: () => \u0275\u0275interpolate7,
  \u0275\u0275interpolate8: () => \u0275\u0275interpolate8,
  \u0275\u0275interpolateV: () => \u0275\u0275interpolateV,
  \u0275\u0275invalidFactory: () => \u0275\u0275invalidFactory,
  \u0275\u0275listener: () => \u0275\u0275listener,
  \u0275\u0275loadQuery: () => \u0275\u0275loadQuery,
  \u0275\u0275nextContext: () => \u0275\u0275nextContext,
  \u0275\u0275pipe: () => \u0275\u0275pipe,
  \u0275\u0275pipeBind1: () => \u0275\u0275pipeBind1,
  \u0275\u0275pipeBind2: () => \u0275\u0275pipeBind2,
  \u0275\u0275pipeBind3: () => \u0275\u0275pipeBind3,
  \u0275\u0275pipeBind4: () => \u0275\u0275pipeBind4,
  \u0275\u0275pipeBindV: () => \u0275\u0275pipeBindV,
  \u0275\u0275projection: () => \u0275\u0275projection,
  \u0275\u0275projectionDef: () => \u0275\u0275projectionDef,
  \u0275\u0275property: () => \u0275\u0275property,
  \u0275\u0275pureFunction0: () => \u0275\u0275pureFunction0,
  \u0275\u0275pureFunction1: () => \u0275\u0275pureFunction1,
  \u0275\u0275pureFunction2: () => \u0275\u0275pureFunction2,
  \u0275\u0275pureFunction3: () => \u0275\u0275pureFunction3,
  \u0275\u0275pureFunction4: () => \u0275\u0275pureFunction4,
  \u0275\u0275pureFunction5: () => \u0275\u0275pureFunction5,
  \u0275\u0275pureFunction6: () => \u0275\u0275pureFunction6,
  \u0275\u0275pureFunction7: () => \u0275\u0275pureFunction7,
  \u0275\u0275pureFunction8: () => \u0275\u0275pureFunction8,
  \u0275\u0275pureFunctionV: () => \u0275\u0275pureFunctionV,
  \u0275\u0275queryAdvance: () => \u0275\u0275queryAdvance,
  \u0275\u0275queryRefresh: () => \u0275\u0275queryRefresh,
  \u0275\u0275readContextLet: () => \u0275\u0275readContextLet,
  \u0275\u0275reference: () => \u0275\u0275reference,
  \u0275\u0275repeater: () => \u0275\u0275repeater,
  \u0275\u0275repeaterCreate: () => \u0275\u0275repeaterCreate,
  \u0275\u0275repeaterTrackByIdentity: () => \u0275\u0275repeaterTrackByIdentity,
  \u0275\u0275repeaterTrackByIndex: () => \u0275\u0275repeaterTrackByIndex,
  \u0275\u0275replaceMetadata: () => \u0275\u0275replaceMetadata,
  \u0275\u0275resolveBody: () => \u0275\u0275resolveBody,
  \u0275\u0275resolveDocument: () => \u0275\u0275resolveDocument,
  \u0275\u0275resolveWindow: () => \u0275\u0275resolveWindow,
  \u0275\u0275sanitizeHtml: () => \u0275\u0275sanitizeHtml,
  \u0275\u0275sanitizeResourceUrl: () => \u0275\u0275sanitizeResourceUrl,
  \u0275\u0275sanitizeScript: () => \u0275\u0275sanitizeScript,
  \u0275\u0275sanitizeStyle: () => \u0275\u0275sanitizeStyle,
  \u0275\u0275sanitizeUrl: () => \u0275\u0275sanitizeUrl,
  \u0275\u0275sanitizeUrlOrResourceUrl: () => \u0275\u0275sanitizeUrlOrResourceUrl,
  \u0275\u0275setComponentScope: () => \u0275\u0275setComponentScope,
  \u0275\u0275setNgModuleScope: () => \u0275\u0275setNgModuleScope,
  \u0275\u0275storeLet: () => \u0275\u0275storeLet,
  \u0275\u0275styleMap: () => \u0275\u0275styleMap,
  \u0275\u0275styleProp: () => \u0275\u0275styleProp,
  \u0275\u0275syntheticHostListener: () => \u0275\u0275syntheticHostListener,
  \u0275\u0275syntheticHostProperty: () => \u0275\u0275syntheticHostProperty,
  \u0275\u0275template: () => \u0275\u0275template,
  \u0275\u0275templateRefExtractor: () => \u0275\u0275templateRefExtractor,
  \u0275\u0275text: () => \u0275\u0275text,
  \u0275\u0275textInterpolate: () => \u0275\u0275textInterpolate,
  \u0275\u0275textInterpolate1: () => \u0275\u0275textInterpolate1,
  \u0275\u0275textInterpolate2: () => \u0275\u0275textInterpolate2,
  \u0275\u0275textInterpolate3: () => \u0275\u0275textInterpolate3,
  \u0275\u0275textInterpolate4: () => \u0275\u0275textInterpolate4,
  \u0275\u0275textInterpolate5: () => \u0275\u0275textInterpolate5,
  \u0275\u0275textInterpolate6: () => \u0275\u0275textInterpolate6,
  \u0275\u0275textInterpolate7: () => \u0275\u0275textInterpolate7,
  \u0275\u0275textInterpolate8: () => \u0275\u0275textInterpolate8,
  \u0275\u0275textInterpolateV: () => \u0275\u0275textInterpolateV,
  \u0275\u0275trustConstantHtml: () => \u0275\u0275trustConstantHtml,
  \u0275\u0275trustConstantResourceUrl: () => \u0275\u0275trustConstantResourceUrl,
  \u0275\u0275twoWayBindingSet: () => \u0275\u0275twoWayBindingSet,
  \u0275\u0275twoWayListener: () => \u0275\u0275twoWayListener,
  \u0275\u0275twoWayProperty: () => \u0275\u0275twoWayProperty,
  \u0275\u0275validateAttribute: () => \u0275\u0275validateAttribute,
  \u0275\u0275viewQuery: () => \u0275\u0275viewQuery,
  \u0275\u0275viewQuerySignal: () => \u0275\u0275viewQuerySignal
});
module.exports = __toCommonJS(debug_node_exports);
var import_root_effect_scheduler = require("./root_effect_scheduler.mjs");
var import_signal = require("./signal.mjs");
var import_rxjs = require("rxjs");
var import_signals = require("@angular/core/primitives/signals");
var import_operators = require("rxjs/operators");
var import_attribute = require("./attribute.mjs");
/**
 * @license Angular v20.3.16
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */
var _a, _b, _c, _d, _e, _f, _g;
function noSideEffects(fn) {
  return { toString: fn }.toString();
}
const ANNOTATIONS = "__annotations__";
const PARAMETERS = "__parameters__";
const PROP_METADATA = "__prop__metadata__";
function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, ...args);
        return this;
      }
      const annotationInstance = new DecoratorFactory(...args);
      return function TypeDecorator(cls) {
        if (typeFn)
          typeFn(cls, ...args);
        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
        annotations.push(annotationInstance);
        return cls;
      };
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
  });
}
function makeMetadataCtor(props) {
  return function ctor(...args) {
    if (props) {
      const values = props(...args);
      for (const propName in values) {
        this[propName] = values[propName];
      }
    }
  };
}
function makeParamDecorator(name, props, parentClass) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const annotationInstance = new ParamDecoratorFactory(...args);
      ParamDecorator.annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index) {
        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        (parameters[index] = parameters[index] || []).push(annotationInstance);
        return cls;
      }
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  });
}
function makePropDecorator(name, props, parentClass, additionalProcessing) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const decoratorInstance = new PropDecoratorFactory(...args);
      function PropDecorator(target, name2) {
        if (target === void 0) {
          throw new Error("Standard Angular field decorators are not supported in JIT mode.");
        }
        const constructor = target.constructor;
        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
        meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
        meta[name2].unshift(decoratorInstance);
      }
      return PropDecorator;
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  });
}
const Inject = (0, import_root_effect_scheduler.attachInjectFlag)(
  // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.
  makeParamDecorator("Inject", (token) => ({ token })),
  -1
  /* DecoratorFlags.Inject */
);
const Optional = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  (0, import_root_effect_scheduler.attachInjectFlag)(
    makeParamDecorator("Optional"),
    8
    /* InternalInjectFlags.Optional */
  )
);
const Self = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  (0, import_root_effect_scheduler.attachInjectFlag)(
    makeParamDecorator("Self"),
    2
    /* InternalInjectFlags.Self */
  )
);
const SkipSelf = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  (0, import_root_effect_scheduler.attachInjectFlag)(
    makeParamDecorator("SkipSelf"),
    4
    /* InternalInjectFlags.SkipSelf */
  )
);
const Host = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  (0, import_root_effect_scheduler.attachInjectFlag)(
    makeParamDecorator("Host"),
    1
    /* InternalInjectFlags.Host */
  )
);
function getCompilerFacade(request) {
  const globalNg = import_root_effect_scheduler._global["ng"];
  if (globalNg && globalNg.\u0275compilerFacade) {
    return globalNg.\u0275compilerFacade;
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.error(`JIT compilation failed for ${request.kind}`, request.type);
    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

`;
    if (request.usage === 1) {
      message += `The ${request.kind} is part of a library that has been partially compiled.
`;
      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
`;
      message += "\n";
      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
`;
    } else {
      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
`;
    }
    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
`;
    message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
    throw new Error(message);
  } else {
    throw new Error("JIT compiler unavailable");
  }
}
const angularCoreDiEnv = {
  "\u0275\u0275defineInjectable": import_root_effect_scheduler.\u0275\u0275defineInjectable,
  "\u0275\u0275defineInjector": import_root_effect_scheduler.\u0275\u0275defineInjector,
  "\u0275\u0275inject": import_root_effect_scheduler.\u0275\u0275inject,
  "\u0275\u0275invalidFactoryDep": import_root_effect_scheduler.\u0275\u0275invalidFactoryDep,
  "resolveForwardRef": import_root_effect_scheduler.resolveForwardRef
};
const Type = Function;
function isType(v) {
  return typeof v === "function";
}
const ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
const ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
const ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
const ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
function isDelegateCtor(typeStr) {
  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
class ReflectionCapabilities {
  constructor(reflect) {
    __publicField(this, "_reflect");
    this._reflect = reflect || import_root_effect_scheduler._global["Reflect"];
  }
  factory(t) {
    return (...args) => new t(...args);
  }
  /** @internal */
  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
    let result;
    if (typeof paramTypes === "undefined") {
      result = (0, import_root_effect_scheduler.newArray)(paramAnnotations.length);
    } else {
      result = (0, import_root_effect_scheduler.newArray)(paramTypes.length);
    }
    for (let i = 0; i < result.length; i++) {
      if (typeof paramTypes === "undefined") {
        result[i] = [];
      } else if (paramTypes[i] && paramTypes[i] != Object) {
        result[i] = [paramTypes[i]];
      } else {
        result[i] = [];
      }
      if (paramAnnotations && paramAnnotations[i] != null) {
        result[i] = result[i].concat(paramAnnotations[i]);
      }
    }
    return result;
  }
  _ownParameters(type, parentCtor) {
    const typeStr = type.toString();
    if (isDelegateCtor(typeStr)) {
      return null;
    }
    if (type.parameters && type.parameters !== parentCtor.parameters) {
      return type.parameters;
    }
    const tsickleCtorParams = type.ctorParameters;
    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
      const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
      const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
      const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
      return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
    }
    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
    if (paramTypes || paramAnnotations) {
      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
    }
    return (0, import_root_effect_scheduler.newArray)(type.length);
  }
  parameters(type) {
    if (!isType(type)) {
      return [];
    }
    const parentCtor = getParentCtor(type);
    let parameters = this._ownParameters(type, parentCtor);
    if (!parameters && parentCtor !== Object) {
      parameters = this.parameters(parentCtor);
    }
    return parameters || [];
  }
  _ownAnnotations(typeOrFunc, parentCtor) {
    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
      let annotations = typeOrFunc.annotations;
      if (typeof annotations === "function" && annotations.annotations) {
        annotations = annotations.annotations;
      }
      return annotations;
    }
    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
    }
    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
      return typeOrFunc[ANNOTATIONS];
    }
    return null;
  }
  annotations(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return [];
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
    return parentAnnotations.concat(ownAnnotations);
  }
  _ownPropMetadata(typeOrFunc, parentCtor) {
    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
      let propMetadata = typeOrFunc.propMetadata;
      if (typeof propMetadata === "function" && propMetadata.propMetadata) {
        propMetadata = propMetadata.propMetadata;
      }
      return propMetadata;
    }
    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
      const propDecorators = typeOrFunc.propDecorators;
      const propMetadata = {};
      Object.keys(propDecorators).forEach((prop) => {
        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
      });
      return propMetadata;
    }
    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
      return typeOrFunc[PROP_METADATA];
    }
    return null;
  }
  propMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const propMetadata = {};
    if (parentCtor !== Object) {
      const parentPropMetadata = this.propMetadata(parentCtor);
      Object.keys(parentPropMetadata).forEach((propName) => {
        propMetadata[propName] = parentPropMetadata[propName];
      });
    }
    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
    if (ownPropMetadata) {
      Object.keys(ownPropMetadata).forEach((propName) => {
        const decorators = [];
        if (propMetadata.hasOwnProperty(propName)) {
          decorators.push(...propMetadata[propName]);
        }
        decorators.push(...ownPropMetadata[propName]);
        propMetadata[propName] = decorators;
      });
    }
    return propMetadata;
  }
  ownPropMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
  }
  hasLifecycleHook(type, lcProperty) {
    return type instanceof Type && lcProperty in type.prototype;
  }
}
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
  if (!decoratorInvocations) {
    return [];
  }
  return decoratorInvocations.map((decoratorInvocation) => {
    const decoratorType = decoratorInvocation.type;
    const annotationCls = decoratorType.annotationCls;
    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
    return new annotationCls(...annotationArgs);
  });
}
function getParentCtor(ctor) {
  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
  const parentCtor = parentProto ? parentProto.constructor : null;
  return parentCtor || Object;
}
class SimpleChange {
  constructor(previousValue, currentValue, firstChange) {
    __publicField(this, "previousValue");
    __publicField(this, "currentValue");
    __publicField(this, "firstChange");
    this.previousValue = previousValue;
    this.currentValue = currentValue;
    this.firstChange = firstChange;
  }
  /**
   * Check whether the new value is the first value assigned.
   */
  isFirstChange() {
    return this.firstChange;
  }
}
function applyValueToInputField(instance, inputSignalNode, privateName, value) {
  if (inputSignalNode !== null) {
    inputSignalNode.applyValueToInputSignal(inputSignalNode, value);
  } else {
    instance[privateName] = value;
  }
}
const \u0275\u0275NgOnChangesFeature = /* @__PURE__ */ (() => {
  const \u0275\u0275NgOnChangesFeatureImpl = () => NgOnChangesFeatureImpl;
  \u0275\u0275NgOnChangesFeatureImpl.ngInherit = true;
  return \u0275\u0275NgOnChangesFeatureImpl;
})();
function NgOnChangesFeatureImpl(definition) {
  if (definition.type.prototype.ngOnChanges) {
    definition.setInput = ngOnChangesSetInput;
  }
  return rememberChangeHistoryAndInvokeOnChangesHook;
}
function rememberChangeHistoryAndInvokeOnChangesHook() {
  const simpleChangesStore = getSimpleChangesStore(this);
  const current = simpleChangesStore == null ? void 0 : simpleChangesStore.current;
  if (current) {
    const previous = simpleChangesStore.previous;
    if (previous === import_root_effect_scheduler.EMPTY_OBJ) {
      simpleChangesStore.previous = current;
    } else {
      for (let key in current) {
        previous[key] = current[key];
      }
    }
    simpleChangesStore.current = null;
    this.ngOnChanges(current);
  }
}
function ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {
  const declaredName = this.declaredInputs[publicName];
  ngDevMode && (0, import_root_effect_scheduler.assertString)(declaredName, "Name of input in ngOnChanges has to be a string");
  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, { previous: import_root_effect_scheduler.EMPTY_OBJ, current: null });
  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
  const previous = simpleChangesStore.previous;
  const previousChange = previous[declaredName];
  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === import_root_effect_scheduler.EMPTY_OBJ);
  applyValueToInputField(instance, inputSignalNode, privateName, value);
}
const SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
function getSimpleChangesStore(instance) {
  return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store2) {
  return instance[SIMPLE_CHANGES_STORE] = store2;
}
const profilerCallbacks = [];
const NOOP_PROFILER_REMOVAL = () => {
};
function removeProfiler(profiler2) {
  const profilerIdx = profilerCallbacks.indexOf(profiler2);
  if (profilerIdx !== -1) {
    profilerCallbacks.splice(profilerIdx, 1);
  }
}
function setProfiler(profiler2) {
  if (profiler2 !== null) {
    if (!profilerCallbacks.includes(profiler2)) {
      profilerCallbacks.push(profiler2);
    }
    return () => removeProfiler(profiler2);
  } else {
    profilerCallbacks.length = 0;
    return NOOP_PROFILER_REMOVAL;
  }
}
const profiler = function(event, instance = null, eventFn) {
  for (let i = 0; i < profilerCallbacks.length; i++) {
    const profilerCallback = profilerCallbacks[i];
    profilerCallback(event, instance, eventFn);
  }
};
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
  var _a2, _b2, _c2, _d2, _e2;
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;
  if (ngOnChanges) {
    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
    ((_a2 = tView.preOrderHooks) != null ? _a2 : tView.preOrderHooks = []).push(directiveIndex, wrappedOnChanges);
    ((_b2 = tView.preOrderCheckHooks) != null ? _b2 : tView.preOrderCheckHooks = []).push(directiveIndex, wrappedOnChanges);
  }
  if (ngOnInit) {
    ((_c2 = tView.preOrderHooks) != null ? _c2 : tView.preOrderHooks = []).push(0 - directiveIndex, ngOnInit);
  }
  if (ngDoCheck) {
    ((_d2 = tView.preOrderHooks) != null ? _d2 : tView.preOrderHooks = []).push(directiveIndex, ngDoCheck);
    ((_e2 = tView.preOrderCheckHooks) != null ? _e2 : tView.preOrderCheckHooks = []).push(directiveIndex, ngDoCheck);
  }
}
function registerPostOrderHooks(tView, tNode) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
    const directiveDef = tView.data[i];
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(directiveDef, "Expecting DirectiveDef");
    const lifecycleHooks = directiveDef.type.prototype;
    const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;
    if (ngAfterContentInit) {
      ((_a2 = tView.contentHooks) != null ? _a2 : tView.contentHooks = []).push(-i, ngAfterContentInit);
    }
    if (ngAfterContentChecked) {
      ((_b2 = tView.contentHooks) != null ? _b2 : tView.contentHooks = []).push(i, ngAfterContentChecked);
      ((_c2 = tView.contentCheckHooks) != null ? _c2 : tView.contentCheckHooks = []).push(i, ngAfterContentChecked);
    }
    if (ngAfterViewInit) {
      ((_d2 = tView.viewHooks) != null ? _d2 : tView.viewHooks = []).push(-i, ngAfterViewInit);
    }
    if (ngAfterViewChecked) {
      ((_e2 = tView.viewHooks) != null ? _e2 : tView.viewHooks = []).push(i, ngAfterViewChecked);
      ((_f2 = tView.viewCheckHooks) != null ? _f2 : tView.viewCheckHooks = []).push(i, ngAfterViewChecked);
    }
    if (ngOnDestroy != null) {
      ((_g2 = tView.destroyHooks) != null ? _g2 : tView.destroyHooks = []).push(i, ngOnDestroy);
    }
  }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
  callHooks(lView, hooks, 3, nodeIndex);
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
  ngDevMode && (0, import_root_effect_scheduler.assertNotEqual)(initPhase, 3, "Init pre-order hooks should not be called more than once");
  if ((lView[import_root_effect_scheduler.FLAGS] & 3) === initPhase) {
    callHooks(lView, hooks, initPhase, nodeIndex);
  }
}
function incrementInitPhaseFlags(lView, initPhase) {
  ngDevMode && (0, import_root_effect_scheduler.assertNotEqual)(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
  let flags = lView[import_root_effect_scheduler.FLAGS];
  if ((flags & 3) === initPhase) {
    flags &= 16383;
    flags += 1;
    lView[import_root_effect_scheduler.FLAGS] = flags;
  }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)((0, import_root_effect_scheduler.isInCheckNoChangesMode)(), false, "Hooks should never be run when in check no changes mode.");
  const startIndex = currentNodeIndex !== void 0 ? currentView[import_root_effect_scheduler.PREORDER_HOOK_FLAGS] & 65535 : 0;
  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
  const max = arr.length - 1;
  let lastNodeIndexFound = 0;
  for (let i = startIndex; i < max; i++) {
    const hook = arr[i + 1];
    if (typeof hook === "number") {
      lastNodeIndexFound = arr[i];
      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
        break;
      }
    } else {
      const isInitHook = arr[i] < 0;
      if (isInitHook) {
        currentView[import_root_effect_scheduler.PREORDER_HOOK_FLAGS] += 65536;
      }
      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
        callHook(currentView, initPhase, arr, i);
        currentView[import_root_effect_scheduler.PREORDER_HOOK_FLAGS] = (currentView[import_root_effect_scheduler.PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
      }
      i++;
    }
  }
}
function callHookInternal(directive, hook) {
  profiler(4, directive, hook);
  const prevConsumer = (0, import_signal.setActiveConsumer)(null);
  try {
    hook.call(directive);
  } finally {
    (0, import_signal.setActiveConsumer)(prevConsumer);
    profiler(5, directive, hook);
  }
}
function callHook(currentView, initPhase, arr, i) {
  const isInitHook = arr[i] < 0;
  const hook = arr[i + 1];
  const directiveIndex = isInitHook ? -arr[i] : arr[i];
  const directive = currentView[directiveIndex];
  if (isInitHook) {
    const indexWithintInitPhase = currentView[import_root_effect_scheduler.FLAGS] >> 14;
    if (indexWithintInitPhase < currentView[import_root_effect_scheduler.PREORDER_HOOK_FLAGS] >> 16 && (currentView[import_root_effect_scheduler.FLAGS] & 3) === initPhase) {
      currentView[import_root_effect_scheduler.FLAGS] += 16384;
      callHookInternal(directive, hook);
    }
  } else {
    callHookInternal(directive, hook);
  }
}
const NO_PARENT_INJECTOR = -1;
class NodeInjectorFactory {
  constructor(factory, isViewProvider, injectImplementation, name) {
    __publicField(this, "factory");
    __publicField(this, "name");
    /**
     * The inject implementation to be activated when using the factory.
     */
    __publicField(this, "injectImpl");
    /**
     * Marker set to true during factory invocation to see if we get into recursive loop.
     * Recursive loop causes an error to be displayed.
     */
    __publicField(this, "resolving", false);
    /**
     * Marks that the token can see other Tokens declared in `viewProviders` on the same node.
     */
    __publicField(this, "canSeeViewProviders");
    /**
     * An array of factories to use in case of `multi` provider.
     */
    __publicField(this, "multi");
    /**
     * Number of `multi`-providers which belong to the component.
     *
     * This is needed because when multiple components and directives declare the `multi` provider
     * they have to be concatenated in the correct order.
     *
     * Example:
     *
     * If we have a component and directive active an a single element as declared here
     * ```ts
     * component:
     *   providers: [ {provide: String, useValue: 'component', multi: true} ],
     *   viewProviders: [ {provide: String, useValue: 'componentView', multi: true} ],
     *
     * directive:
     *   providers: [ {provide: String, useValue: 'directive', multi: true} ],
     * ```
     *
     * Then the expected results are:
     *
     * ```ts
     * providers: ['component', 'directive']
     * viewProviders: ['component', 'componentView', 'directive']
     * ```
     *
     * The way to think about it is that the `viewProviders` have been inserted after the component
     * but before the directives, which is why we need to know how many `multi`s have been declared by
     * the component.
     */
    __publicField(this, "componentProviders");
    /**
     * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.
     * See `providerFactory`.
     */
    __publicField(this, "index");
    /**
     * Because the same `multi` provider can be declared in `providers` and `viewProviders` it is
     * possible for `viewProviders` to shadow the `providers`. For this reason we store the
     * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.
     *
     * Example:
     *
     * Given:
     * ```ts
     * providers: [ {provide: String, useValue: 'all', multi: true} ],
     * viewProviders: [ {provide: String, useValue: 'viewOnly', multi: true} ],
     * ```
     *
     * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case
     * of view injection. We further have to make sure that the shared instances (in our case
     * `all`) are the exact same instance in both the content as well as the view injection. (We
     * have to make sure that we don't double instantiate.) For this reason the `viewProviders`
     * `Factory` has a pointer to the shadowed `providers` factory so that it can instantiate the
     * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =
     * ['all', 'viewOnly']`).
     */
    __publicField(this, "providerFactory");
    this.factory = factory;
    this.name = name;
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(factory, "Factory not specified");
    ngDevMode && (0, import_root_effect_scheduler.assertEqual)(typeof factory, "function", "Expected factory function.");
    this.canSeeViewProviders = isViewProvider;
    this.injectImpl = injectImplementation;
  }
}
function toTNodeTypeAsString(tNodeType) {
  let text = "";
  tNodeType & 1 && (text += "|Text");
  tNodeType & 2 && (text += "|Element");
  tNodeType & 4 && (text += "|Container");
  tNodeType & 8 && (text += "|ElementContainer");
  tNodeType & 16 && (text += "|Projection");
  tNodeType & 32 && (text += "|IcuContainer");
  tNodeType & 64 && (text += "|Placeholder");
  tNodeType & 128 && (text += "|LetDeclaration");
  return text.length > 0 ? text.substring(1) : text;
}
function isTNodeShape(value) {
  return value != null && typeof value === "object" && (value.insertBeforeIndex === null || typeof value.insertBeforeIndex === "number" || Array.isArray(value.insertBeforeIndex));
}
function isLetDeclaration(tNode) {
  return !!(tNode.type & 128);
}
function hasClassInput(tNode) {
  return (tNode.flags & 8) !== 0;
}
function hasStyleInput(tNode) {
  return (tNode.flags & 16) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
  (0, import_root_effect_scheduler.assertDefined)(tNode, "should be called with a TNode");
  if ((tNode.type & expectedTypes) === 0) {
    (0, import_root_effect_scheduler.throwError)(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
  }
}
function assertPureTNodeType(type) {
  if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64 || type === 128)) {
    (0, import_root_effect_scheduler.throwError)(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
  }
}
function setUpAttributes(renderer, native, attrs) {
  let i = 0;
  while (i < attrs.length) {
    const value = attrs[i];
    if (typeof value === "number") {
      if (value !== 0) {
        break;
      }
      i++;
      const namespaceURI = attrs[i++];
      const attrName = attrs[i++];
      const attrVal = attrs[i++];
      renderer.setAttribute(native, attrName, attrVal, namespaceURI);
    } else {
      const attrName = value;
      const attrVal = attrs[++i];
      if (isAnimationProp(attrName)) {
        renderer.setProperty(native, attrName, attrVal);
      } else {
        renderer.setAttribute(native, attrName, attrVal);
      }
      i++;
    }
  }
  return i;
}
function isNameOnlyAttributeMarker(marker) {
  return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name) {
  return name.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
  if (src === null || src.length === 0) ;
  else if (dst === null || dst.length === 0) {
    dst = src.slice();
  } else {
    let srcMarker = -1;
    for (let i = 0; i < src.length; i++) {
      const item = src[i];
      if (typeof item === "number") {
        srcMarker = item;
      } else {
        if (srcMarker === 0) ;
        else if (srcMarker === -1 || srcMarker === 2) {
          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
        } else {
          mergeHostAttribute(dst, srcMarker, item, null, null);
        }
      }
    }
  }
  return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value) {
  let i = 0;
  let markerInsertPosition = dst.length;
  if (marker === -1) {
    markerInsertPosition = -1;
  } else {
    while (i < dst.length) {
      const dstValue = dst[i++];
      if (typeof dstValue === "number") {
        if (dstValue === marker) {
          markerInsertPosition = -1;
          break;
        } else if (dstValue > marker) {
          markerInsertPosition = i - 1;
          break;
        }
      }
    }
  }
  while (i < dst.length) {
    const item = dst[i];
    if (typeof item === "number") {
      break;
    } else if (item === key1) {
      {
        if (value !== null) {
          dst[i + 1] = value;
        }
        return;
      }
    }
    i++;
    if (value !== null)
      i++;
  }
  if (markerInsertPosition !== -1) {
    dst.splice(markerInsertPosition, 0, marker);
    i = markerInsertPosition + 1;
  }
  dst.splice(i++, 0, key1);
  if (value !== null) {
    dst.splice(i++, 0, value);
  }
}
function hasParentInjector(parentLocation) {
  return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
  if (ngDevMode) {
    (0, import_root_effect_scheduler.assertNumber)(parentLocation, "Number expected");
    (0, import_root_effect_scheduler.assertNotEqual)(parentLocation, -1, "Not a valid state.");
    const parentInjectorIndex = parentLocation & 32767;
    (0, import_root_effect_scheduler.assertGreaterThan)(parentInjectorIndex, import_root_effect_scheduler.HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
  }
  return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
  return parentLocation >> 16;
}
function getParentInjectorView(location, startView) {
  let viewOffset = getParentInjectorViewOffset(location);
  let parentView = startView;
  while (viewOffset > 0) {
    parentView = parentView[import_root_effect_scheduler.DECLARATION_VIEW];
    viewOffset--;
  }
  return parentView;
}
let includeViewProviders = true;
function setIncludeViewProviders(v) {
  const oldValue = includeViewProviders;
  includeViewProviders = v;
  return oldValue;
}
const BLOOM_SIZE = 256;
const BLOOM_MASK = BLOOM_SIZE - 1;
const BLOOM_BUCKET_BITS = 5;
let nextNgElementId = 0;
const NOT_FOUND = {};
function bloomAdd(injectorIndex, tView, type) {
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(tView.firstCreatePass, true, "expected firstCreatePass to be true");
  let id;
  if (typeof type === "string") {
    id = type.charCodeAt(0) || 0;
  } else if (type.hasOwnProperty(import_root_effect_scheduler.NG_ELEMENT_ID)) {
    id = type[import_root_effect_scheduler.NG_ELEMENT_ID];
  }
  if (id == null) {
    id = type[import_root_effect_scheduler.NG_ELEMENT_ID] = nextNgElementId++;
  }
  const bloomHash = id & BLOOM_MASK;
  const mask = 1 << bloomHash;
  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
  const existingInjectorIndex = getInjectorIndex(tNode, lView);
  if (existingInjectorIndex !== -1) {
    return existingInjectorIndex;
  }
  const tView = lView[import_root_effect_scheduler.TVIEW];
  if (tView.firstCreatePass) {
    tNode.injectorIndex = lView.length;
    insertBloom(tView.data, tNode);
    insertBloom(lView, null);
    insertBloom(tView.blueprint, null);
  }
  const parentLoc = getParentInjectorLocation(tNode, lView);
  const injectorIndex = tNode.injectorIndex;
  if (hasParentInjector(parentLoc)) {
    const parentIndex = getParentInjectorIndex(parentLoc);
    const parentLView = getParentInjectorView(parentLoc, lView);
    const parentData = parentLView[import_root_effect_scheduler.TVIEW].data;
    for (let i = 0; i < 8; i++) {
      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
    }
  }
  lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] = parentLoc;
  return injectorIndex;
}
function insertBloom(arr, footer) {
  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
  if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been
  // copied down from the parent node. No injector has been created yet on this node.
  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values
  // might not have been calculated yet for this instance
  lView[
    tNode.injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] === null) {
    return -1;
  } else {
    ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, tNode.injectorIndex);
    return tNode.injectorIndex;
  }
}
function getParentInjectorLocation(tNode, lView) {
  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
    return tNode.parent.injectorIndex;
  }
  let declarationViewOffset = 0;
  let parentTNode = null;
  let lViewCursor = lView;
  while (lViewCursor !== null) {
    parentTNode = getTNodeFromLView(lViewCursor);
    if (parentTNode === null) {
      return NO_PARENT_INJECTOR;
    }
    ngDevMode && parentTNode && (0, import_root_effect_scheduler.assertTNodeForLView)(parentTNode, lViewCursor[import_root_effect_scheduler.DECLARATION_VIEW]);
    declarationViewOffset++;
    lViewCursor = lViewCursor[import_root_effect_scheduler.DECLARATION_VIEW];
    if (parentTNode.injectorIndex !== -1) {
      return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
  }
  return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
  bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
  ngDevMode && assertTNodeType(
    tNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(tNode, "expecting tNode");
  if (attrNameToInject === "class") {
    return tNode.classes;
  }
  if (attrNameToInject === "style") {
    return tNode.styles;
  }
  const attrs = tNode.attrs;
  if (attrs) {
    const attrsLength = attrs.length;
    let i = 0;
    while (i < attrsLength) {
      const value = attrs[i];
      if (isNameOnlyAttributeMarker(value))
        break;
      if (value === 0) {
        i = i + 2;
      } else if (typeof value === "number") {
        i++;
        while (i < attrsLength && typeof attrs[i] === "string") {
          i++;
        }
      } else if (value === attrNameToInject) {
        return attrs[i + 1];
      } else {
        i = i + 2;
      }
    }
  }
  return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
  if (flags & 8 || notFoundValue !== void 0) {
    return notFoundValue;
  } else {
    (0, import_root_effect_scheduler.throwProviderNotFoundError)(token, "NodeInjector");
  }
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
  if (flags & 8 && notFoundValue === void 0) {
    notFoundValue = null;
  }
  if ((flags & (2 | 1)) === 0) {
    const moduleInjector = lView[import_root_effect_scheduler.INJECTOR$1];
    const previousInjectImplementation = (0, import_root_effect_scheduler.setInjectImplementation)(void 0);
    try {
      if (moduleInjector) {
        return moduleInjector.get(
          token,
          notFoundValue,
          flags & 8
          /* InternalInjectFlags.Optional */
        );
      } else {
        return (0, import_root_effect_scheduler.injectRootLimpMode)(
          token,
          notFoundValue,
          flags & 8
          /* InternalInjectFlags.Optional */
        );
      }
    } finally {
      (0, import_root_effect_scheduler.setInjectImplementation)(previousInjectImplementation);
    }
  }
  return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = 0, notFoundValue) {
  if (tNode !== null) {
    if (lView[import_root_effect_scheduler.FLAGS] & 2048 && // The token must be present on the current node injector when the `Self`
    // flag is set, so the lookup on embedded view injector(s) can be skipped.
    !(flags & 2)) {
      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
      if (embeddedInjectorValue !== NOT_FOUND) {
        return embeddedInjectorValue;
      }
    }
    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
    if (value !== NOT_FOUND) {
      return value;
    }
  }
  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
  const bloomHash = bloomHashBitOrFactory(token);
  if (typeof bloomHash === "function") {
    if (!(0, import_root_effect_scheduler.enterDI)(lView, tNode, flags)) {
      return flags & 1 ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    try {
      let value;
      if (ngDevMode) {
        (0, import_root_effect_scheduler.runInInjectorProfilerContext)(new NodeInjector((0, import_root_effect_scheduler.getCurrentTNode)(), (0, import_root_effect_scheduler.getLView)()), token, () => {
          (0, import_root_effect_scheduler.emitInjectorToCreateInstanceEvent)(token);
          value = bloomHash(flags);
          (0, import_root_effect_scheduler.emitInstanceCreatedByInjectorEvent)(value);
        });
      } else {
        value = bloomHash(flags);
      }
      if (value == null && !(flags & 8)) {
        (0, import_root_effect_scheduler.throwProviderNotFoundError)(token);
      } else {
        return value;
      }
    } finally {
      (0, import_root_effect_scheduler.leaveDI)();
    }
  } else if (typeof bloomHash === "number") {
    let previousTView = null;
    let injectorIndex = getInjectorIndex(tNode, lView);
    let parentLocation = NO_PARENT_INJECTOR;
    let hostTElementNode = flags & 1 ? lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW][import_root_effect_scheduler.T_HOST] : null;
    if (injectorIndex === -1 || flags & 4) {
      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
        injectorIndex = -1;
      } else {
        previousTView = lView[import_root_effect_scheduler.TVIEW];
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      }
    }
    while (injectorIndex !== -1) {
      ngDevMode && (0, import_root_effect_scheduler.assertNodeInjector)(lView, injectorIndex);
      const tView = lView[import_root_effect_scheduler.TVIEW];
      ngDevMode && (0, import_root_effect_scheduler.assertTNodeForLView)(tView.data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ], lView);
      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
        if (instance !== NOT_FOUND) {
          return instance;
        }
      }
      parentLocation = lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[import_root_effect_scheduler.TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
        previousTView = tView;
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      } else {
        injectorIndex = -1;
      }
    }
  }
  return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
  const currentTView = lView[import_root_effect_scheduler.TVIEW];
  const tNode = currentTView.data[
    injectorIndex + 8
    /* NodeInjectorOffset.TNODE */
  ];
  const canAccessViewProviders = previousTView == null ? (
    // 1) This is the first invocation `previousTView == null` which means that we are at the
    // `TNode` of where injector is starting to look. In such a case the only time we are allowed
    // to look into the ViewProviders is if:
    // - we are on a component
    // - AND the injector set `includeViewProviders` to true (implying that the token can see
    // ViewProviders because it is the Component or a Service which itself was declared in
    // ViewProviders)
    (0, import_root_effect_scheduler.isComponentHost)(tNode) && includeViewProviders
  ) : (
    // 2) `previousTView != null` which means that we are now walking across the parent nodes.
    // In such a case we are only allowed to look into the ViewProviders if:
    // - We just crossed from child View to Parent View `previousTView != currentTView`
    // - AND the parent TNode is an Element.
    // This means that we just came from the Component's View and therefore are allowed to see
    // into the ViewProviders.
    previousTView != currentTView && (tNode.type & 3) !== 0
  );
  const isHostSpecialCase = flags & 1 && hostTElementNode === tNode;
  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
  if (injectableIdx !== null) {
    return getNodeInjectable(lView, currentTView, injectableIdx, tNode, flags);
  } else {
    return NOT_FOUND;
  }
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
  const nodeProviderIndexes = tNode.providerIndexes;
  const tInjectables = tView.data;
  const injectablesStart = nodeProviderIndexes & 1048575;
  const directivesStart = tNode.directiveStart;
  const directiveEnd = tNode.directiveEnd;
  const cptViewProvidersCount = nodeProviderIndexes >> 20;
  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
  for (let i = startingIndex; i < endIndex; i++) {
    const providerTokenOrDef = tInjectables[i];
    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
      return i;
    }
  }
  if (isHostSpecialCase) {
    const dirDef = tInjectables[directivesStart];
    if (dirDef && (0, import_root_effect_scheduler.isComponentDef)(dirDef) && dirDef.type === token) {
      return directivesStart;
    }
  }
  return null;
}
let injectionPath = [];
function getNodeInjectable(lView, tView, index, tNode, flags) {
  var _a2;
  let value = lView[index];
  const tData = tView.data;
  if (value instanceof NodeInjectorFactory) {
    const factory = value;
    ngDevMode && injectionPath.push((_a2 = factory.name) != null ? _a2 : "unknown");
    if (factory.resolving) {
      const token2 = (0, import_root_effect_scheduler.stringifyForError)(tData[index]);
      if (ngDevMode) {
        throw (0, import_root_effect_scheduler.cyclicDependencyErrorWithDetails)(token2, injectionPath);
      } else {
        throw (0, import_root_effect_scheduler.cyclicDependencyError)(token2);
      }
    }
    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
    factory.resolving = true;
    const token = tData[index].type || tData[index];
    let prevInjectContext;
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      prevInjectContext = (0, import_root_effect_scheduler.setInjectorProfilerContext)({ injector, token });
    }
    const previousInjectImplementation = factory.injectImpl ? (0, import_root_effect_scheduler.setInjectImplementation)(factory.injectImpl) : null;
    const success = (0, import_root_effect_scheduler.enterDI)(
      lView,
      tNode,
      0
      /* InternalInjectFlags.Default */
    );
    ngDevMode && (0, import_root_effect_scheduler.assertEqual)(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
    try {
      ngDevMode && (0, import_root_effect_scheduler.emitInjectorToCreateInstanceEvent)(token);
      value = lView[index] = factory.factory(void 0, flags, tData, lView, tNode);
      ngDevMode && (0, import_root_effect_scheduler.emitInstanceCreatedByInjectorEvent)(value);
      if (tView.firstCreatePass && index >= tNode.directiveStart) {
        ngDevMode && (0, import_root_effect_scheduler.assertDirectiveDef)(tData[index]);
        registerPreOrderHooks(index, tData[index], tView);
      }
    } finally {
      ngDevMode && (0, import_root_effect_scheduler.setInjectorProfilerContext)(prevInjectContext);
      previousInjectImplementation !== null && (0, import_root_effect_scheduler.setInjectImplementation)(previousInjectImplementation);
      setIncludeViewProviders(previousIncludeViewProviders);
      factory.resolving = false;
      (0, import_root_effect_scheduler.leaveDI)();
      ngDevMode && (injectionPath = []);
    }
  }
  return value;
}
function bloomHashBitOrFactory(token) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(token, "token must be defined");
  if (typeof token === "string") {
    return token.charCodeAt(0) || 0;
  }
  const tokenId = (
    // First check with `hasOwnProperty` so we don't get an inherited ID.
    token.hasOwnProperty(import_root_effect_scheduler.NG_ELEMENT_ID) ? token[import_root_effect_scheduler.NG_ELEMENT_ID] : void 0
  );
  if (typeof tokenId === "number") {
    if (tokenId >= 0) {
      return tokenId & BLOOM_MASK;
    } else {
      ngDevMode && (0, import_root_effect_scheduler.assertEqual)(tokenId, -1, "Expecting to get Special Injector Id");
      return createNodeInjector;
    }
  } else {
    return tokenId;
  }
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
  const mask = 1 << bloomHash;
  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
  return !!(value & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
  return !(flags & 2) && !(flags & 1 && isFirstHostTNode);
}
function getNodeInjectorLView(nodeInjector) {
  return nodeInjector._lView;
}
function getNodeInjectorTNode(nodeInjector) {
  return nodeInjector._tNode;
}
class NodeInjector {
  constructor(_tNode, _lView) {
    __publicField(this, "_tNode");
    __publicField(this, "_lView");
    this._tNode = _tNode;
    this._lView = _lView;
  }
  get(token, notFoundValue, flags) {
    return getOrCreateInjectable(this._tNode, this._lView, token, (0, import_root_effect_scheduler.convertToBitFlags)(flags), notFoundValue);
  }
}
function createNodeInjector() {
  return new NodeInjector((0, import_root_effect_scheduler.getCurrentTNode)(), (0, import_root_effect_scheduler.getLView)());
}
function \u0275\u0275getInheritedFactory(type) {
  return noSideEffects(() => {
    const ownConstructor = type.prototype.constructor;
    const ownFactory = ownConstructor[import_root_effect_scheduler.NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
    const objectPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objectPrototype) {
      const factory = parent[import_root_effect_scheduler.NG_FACTORY_DEF] || getFactoryOf(parent);
      if (factory && factory !== ownFactory) {
        return factory;
      }
      parent = Object.getPrototypeOf(parent);
    }
    return (t) => new t();
  });
}
function getFactoryOf(type) {
  if ((0, import_root_effect_scheduler.isForwardRef)(type)) {
    return () => {
      const factory = getFactoryOf((0, import_root_effect_scheduler.resolveForwardRef)(type));
      return factory && factory();
    };
  }
  return (0, import_root_effect_scheduler.getFactoryDef)(type);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
  let currentTNode = tNode;
  let currentLView = lView;
  while (currentTNode !== null && currentLView !== null && currentLView[import_root_effect_scheduler.FLAGS] & 2048 && !(0, import_root_effect_scheduler.isRootView)(currentLView)) {
    ngDevMode && (0, import_root_effect_scheduler.assertTNodeForLView)(currentTNode, currentLView);
    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | 2, NOT_FOUND);
    if (nodeInjectorValue !== NOT_FOUND) {
      return nodeInjectorValue;
    }
    let parentTNode = currentTNode.parent;
    if (!parentTNode) {
      const embeddedViewInjector = currentLView[import_root_effect_scheduler.EMBEDDED_VIEW_INJECTOR];
      if (embeddedViewInjector) {
        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
        if (embeddedViewInjectorValue !== NOT_FOUND) {
          return embeddedViewInjectorValue;
        }
      }
      parentTNode = getTNodeFromLView(currentLView);
      currentLView = currentLView[import_root_effect_scheduler.DECLARATION_VIEW];
    }
    currentTNode = parentTNode;
  }
  return notFoundValue;
}
function getTNodeFromLView(lView) {
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const tViewType = tView.type;
  if (tViewType === 2) {
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  } else if (tViewType === 1) {
    return lView[import_root_effect_scheduler.T_HOST];
  }
  return null;
}
function \u0275\u0275injectAttribute(attrNameToInject) {
  return injectAttributeImpl((0, import_root_effect_scheduler.getCurrentTNode)(), attrNameToInject);
}
const Attribute = makeParamDecorator("Attribute", (attributeName2) => ({
  attributeName: attributeName2,
  __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName2)
}));
let _reflect = null;
function getReflect() {
  return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type) {
  return convertDependencies(getReflect().parameters(type));
}
function convertDependencies(deps) {
  return deps.map((dep) => reflectDependency(dep));
}
function reflectDependency(dep) {
  const meta = {
    token: null,
    attribute: null,
    host: false,
    optional: false,
    self: false,
    skipSelf: false
  };
  if (Array.isArray(dep) && dep.length > 0) {
    for (let j = 0; j < dep.length; j++) {
      const param = dep[j];
      if (param === void 0) {
        continue;
      }
      const proto = Object.getPrototypeOf(param);
      if (param instanceof Optional || proto.ngMetadataName === "Optional") {
        meta.optional = true;
      } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
        meta.skipSelf = true;
      } else if (param instanceof Self || proto.ngMetadataName === "Self") {
        meta.self = true;
      } else if (param instanceof Host || proto.ngMetadataName === "Host") {
        meta.host = true;
      } else if (param instanceof Inject) {
        meta.token = param.token;
      } else if (param instanceof Attribute) {
        if (param.attributeName === void 0) {
          throw new import_root_effect_scheduler.RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
        }
        meta.attribute = param.attributeName;
      } else {
        meta.token = param;
      }
    }
  } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
    meta.token = null;
  } else {
    meta.token = dep;
  }
  return meta;
}
function compileInjectable(type, meta) {
  let ngInjectableDef = null;
  let ngFactoryDef = null;
  if (!type.hasOwnProperty(import_root_effect_scheduler.NG_PROV_DEF)) {
    Object.defineProperty(type, import_root_effect_scheduler.NG_PROV_DEF, {
      get: () => {
        if (ngInjectableDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/\u0275prov.js`, getInjectableMetadata(type, meta));
        }
        return ngInjectableDef;
      }
    });
  }
  if (!type.hasOwnProperty(import_root_effect_scheduler.NG_FACTORY_DEF)) {
    Object.defineProperty(type, import_root_effect_scheduler.NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/\u0275fac.js`, {
            name: type.name,
            type,
            typeArgumentCount: 0,
            // In JIT mode types are not available nor used.
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Injectable
          });
        }
        return ngFactoryDef;
      },
      // Leave this configurable so that the factories from directives or pipes can take precedence.
      configurable: true
    });
  }
}
const USE_VALUE = (0, import_root_effect_scheduler.getClosureSafeProperty)({
  provide: String,
  useValue: import_root_effect_scheduler.getClosureSafeProperty
});
function isUseClassProvider(meta) {
  return meta.useClass !== void 0;
}
function isUseValueProvider(meta) {
  return USE_VALUE in meta;
}
function isUseFactoryProvider(meta) {
  return meta.useFactory !== void 0;
}
function isUseExistingProvider(meta) {
  return meta.useExisting !== void 0;
}
function getInjectableMetadata(type, srcMeta) {
  const meta = srcMeta || { providedIn: null };
  const compilerMeta = {
    name: type.name,
    type,
    typeArgumentCount: 0,
    providedIn: meta.providedIn
  };
  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
    compilerMeta.deps = convertDependencies(meta.deps);
  }
  if (isUseClassProvider(meta)) {
    compilerMeta.useClass = meta.useClass;
  } else if (isUseValueProvider(meta)) {
    compilerMeta.useValue = meta.useValue;
  } else if (isUseFactoryProvider(meta)) {
    compilerMeta.useFactory = meta.useFactory;
  } else if (isUseExistingProvider(meta)) {
    compilerMeta.useExisting = meta.useExisting;
  }
  return compilerMeta;
}
const Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type, meta) => compileInjectable(type, meta));
function injectElementRef() {
  return createElementRef((0, import_root_effect_scheduler.getCurrentTNode)(), (0, import_root_effect_scheduler.getLView)());
}
function createElementRef(tNode, lView) {
  return new ElementRef((0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView));
}
class ElementRef {
  constructor(nativeElement) {
    /**
     * <div class="docs-alert docs-alert-important">
     *   <header>Use with caution</header>
     *   <p>
     *    Use this API as the last resort when direct access to DOM is needed. Use templating and
     *    data-binding provided by Angular instead. If used, it is recommended in combination with
     *    {@link /best-practices/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls DomSanitizer}
     *    for maxiumum security;
     *   </p>
     * </div>
     */
    __publicField(this, "nativeElement");
    this.nativeElement = nativeElement;
  }
}
/**
 * @internal
 * @nocollapse
 */
__publicField(ElementRef, "__NG_ELEMENT_ID__", injectElementRef);
function unwrapElementRef(value) {
  return value instanceof ElementRef ? value.nativeElement : value;
}
function symbolIterator() {
  return this._results[Symbol.iterator]();
}
_a = Symbol.iterator;
class QueryList {
  /**
   * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change
   *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in
   *     the same result)
   */
  constructor(_emitDistinctChangesOnly = false) {
    __publicField(this, "_emitDistinctChangesOnly");
    __publicField(this, "dirty", true);
    __publicField(this, "_onDirty");
    __publicField(this, "_results", []);
    __publicField(this, "_changesDetected", false);
    __publicField(this, "_changes");
    __publicField(this, "length", 0);
    __publicField(this, "first");
    __publicField(this, "last");
    __publicField(this, _a, /* @__PURE__ */ (() => symbolIterator)());
    this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
  }
  /**
   * Returns `Observable` of `QueryList` notifying the subscriber of changes.
   */
  get changes() {
    var _a2;
    return (_a2 = this._changes) != null ? _a2 : this._changes = new import_rxjs.Subject();
  }
  /**
   * Returns the QueryList entry at `index`.
   */
  get(index) {
    return this._results[index];
  }
  /**
   * See
   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
   */
  map(fn) {
    return this._results.map(fn);
  }
  filter(fn) {
    return this._results.filter(fn);
  }
  /**
   * See
   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
   */
  find(fn) {
    return this._results.find(fn);
  }
  /**
   * See
   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
   */
  reduce(fn, init) {
    return this._results.reduce(fn, init);
  }
  /**
   * See
   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
   */
  forEach(fn) {
    this._results.forEach(fn);
  }
  /**
   * See
   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
   */
  some(fn) {
    return this._results.some(fn);
  }
  /**
   * Returns a copy of the internal results list as an Array.
   */
  toArray() {
    return this._results.slice();
  }
  toString() {
    return this._results.toString();
  }
  /**
   * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that
   * on change detection, it will not notify of changes to the queries, unless a new change
   * occurs.
   *
   * @param resultsTree The query results to store
   * @param identityAccessor Optional function for extracting stable object identity from a value
   *    in the array. This function is executed for each element of the query result list while
   *    comparing current query list with the new one (provided as a first argument of the `reset`
   *    function) to detect if the lists are different. If the function is not provided, elements
   *    are compared as is (without any pre-processing).
   */
  reset(resultsTree, identityAccessor) {
    this.dirty = false;
    const newResultFlat = (0, import_root_effect_scheduler.flatten)(resultsTree);
    if (this._changesDetected = !(0, import_root_effect_scheduler.arrayEquals)(this._results, newResultFlat, identityAccessor)) {
      this._results = newResultFlat;
      this.length = newResultFlat.length;
      this.last = newResultFlat[this.length - 1];
      this.first = newResultFlat[0];
    }
  }
  /**
   * Triggers a change event by emitting on the `changes` {@link EventEmitter}.
   */
  notifyOnChanges() {
    if (this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly))
      this._changes.next(this);
  }
  /** @internal */
  onDirty(cb) {
    this._onDirty = cb;
  }
  /** internal */
  setDirty() {
    var _a2;
    this.dirty = true;
    (_a2 = this._onDirty) == null ? void 0 : _a2.call(this);
  }
  /** internal */
  destroy() {
    if (this._changes !== void 0) {
      this._changes.complete();
      this._changes.unsubscribe();
    }
  }
}
const SKIP_HYDRATION_ATTR_NAME = "ngSkipHydration";
const SKIP_HYDRATION_ATTR_NAME_LOWER_CASE = "ngskiphydration";
function hasSkipHydrationAttrOnTNode(tNode) {
  const attrs = tNode.mergedAttrs;
  if (attrs === null)
    return false;
  for (let i = 0; i < attrs.length; i += 2) {
    const value = attrs[i];
    if (typeof value === "number")
      return false;
    if (typeof value === "string" && value.toLowerCase() === SKIP_HYDRATION_ATTR_NAME_LOWER_CASE) {
      return true;
    }
  }
  return false;
}
function hasSkipHydrationAttrOnRElement(rNode) {
  return rNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME);
}
function hasInSkipHydrationBlockFlag(tNode) {
  return (tNode.flags & 128) === 128;
}
function isInSkipHydrationBlock(tNode) {
  if (hasInSkipHydrationBlockFlag(tNode)) {
    return true;
  }
  let currentTNode = tNode.parent;
  while (currentTNode) {
    if (hasInSkipHydrationBlockFlag(tNode) || hasSkipHydrationAttrOnTNode(currentTNode)) {
      return true;
    }
    currentTNode = currentTNode.parent;
  }
  return false;
}
function isI18nInSkipHydrationBlock(parentTNode) {
  return hasInSkipHydrationBlockFlag(parentTNode) || hasSkipHydrationAttrOnTNode(parentTNode) || isInSkipHydrationBlock(parentTNode);
}
var ChangeDetectionStrategy;
(function(ChangeDetectionStrategy2) {
  ChangeDetectionStrategy2[ChangeDetectionStrategy2["OnPush"] = 0] = "OnPush";
  ChangeDetectionStrategy2[ChangeDetectionStrategy2["Default"] = 1] = "Default";
})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
const TRACKED_LVIEWS = /* @__PURE__ */ new Map();
let uniqueIdCounter = 0;
function getUniqueLViewId() {
  return uniqueIdCounter++;
}
function registerLView(lView) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(lView[import_root_effect_scheduler.ID], "LView must have an ID in order to be registered");
  TRACKED_LVIEWS.set(lView[import_root_effect_scheduler.ID], lView);
}
function getLViewById(id) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(id, "ID used for LView lookup must be a number");
  return TRACKED_LVIEWS.get(id) || null;
}
function unregisterLView(lView) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(lView[import_root_effect_scheduler.ID], "Cannot stop tracking an LView that does not have an ID");
  TRACKED_LVIEWS.delete(lView[import_root_effect_scheduler.ID]);
}
function getTrackedLViews() {
  return TRACKED_LVIEWS;
}
class LContext {
  constructor(lViewId, nodeIndex, native) {
    __publicField(this, "lViewId");
    __publicField(this, "nodeIndex");
    __publicField(this, "native");
    /**
     * The instance of the Component node.
     */
    __publicField(this, "component");
    /**
     * The list of active directives that exist on this element.
     */
    __publicField(this, "directives");
    /**
     * The map of local references (local reference name => element or directive instance) that
     * exist on this element.
     */
    __publicField(this, "localRefs");
    this.lViewId = lViewId;
    this.nodeIndex = nodeIndex;
    this.native = native;
  }
  /** Component's parent view data. */
  get lView() {
    return getLViewById(this.lViewId);
  }
}
function getLContext(target) {
  let mpValue = readPatchedData(target);
  if (mpValue) {
    if ((0, import_root_effect_scheduler.isLView)(mpValue)) {
      const lView = mpValue;
      let nodeIndex;
      let component = void 0;
      let directives = void 0;
      if (isComponentInstance(target)) {
        nodeIndex = findViaComponent(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided component was not found in the application");
        }
        component = target;
      } else if (isDirectiveInstance(target)) {
        nodeIndex = findViaDirective(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided directive was not found in the application");
        }
        directives = getDirectivesAtNodeIndex(nodeIndex, lView);
      } else {
        nodeIndex = findViaNativeElement(lView, target);
        if (nodeIndex == -1) {
          return null;
        }
      }
      const native = (0, import_root_effect_scheduler.unwrapRNode)(lView[nodeIndex]);
      const existingCtx = readPatchedData(native);
      const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
      if (component && context.component === void 0) {
        context.component = component;
        attachPatchData(context.component, context);
      }
      if (directives && context.directives === void 0) {
        context.directives = directives;
        for (let i = 0; i < directives.length; i++) {
          attachPatchData(directives[i], context);
        }
      }
      attachPatchData(context.native, context);
      mpValue = context;
    }
  } else {
    const rElement = target;
    ngDevMode && (0, import_root_effect_scheduler.assertDomNode)(rElement);
    let parent = rElement;
    while (parent = parent.parentNode) {
      const parentContext = readPatchedData(parent);
      if (parentContext) {
        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
        if (!lView) {
          return null;
        }
        const index = findViaNativeElement(lView, rElement);
        if (index >= 0) {
          const native = (0, import_root_effect_scheduler.unwrapRNode)(lView[index]);
          const context = createLContext(lView, index, native);
          attachPatchData(native, context);
          mpValue = context;
          break;
        }
      }
    }
  }
  return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
  return new LContext(lView[import_root_effect_scheduler.ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
  let patchedData = readPatchedData(componentInstance);
  let lView;
  if ((0, import_root_effect_scheduler.isLView)(patchedData)) {
    const contextLView = patchedData;
    const nodeIndex = findViaComponent(contextLView, componentInstance);
    lView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(nodeIndex, contextLView);
    const context = createLContext(contextLView, nodeIndex, lView[import_root_effect_scheduler.HOST]);
    context.component = componentInstance;
    attachPatchData(componentInstance, context);
    attachPatchData(context.native, context);
  } else {
    const context = patchedData;
    const contextLView = context.lView;
    ngDevMode && (0, import_root_effect_scheduler.assertLView)(contextLView);
    lView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(context.nodeIndex, contextLView);
  }
  return lView;
}
const MONKEY_PATCH_KEY_NAME = "__ngContext__";
function attachPatchData(target, data) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(target, "Target expected");
  if ((0, import_root_effect_scheduler.isLView)(data)) {
    target[MONKEY_PATCH_KEY_NAME] = data[import_root_effect_scheduler.ID];
    registerLView(data);
  } else {
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
}
function readPatchedData(target) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(target, "Target expected");
  const data = target[MONKEY_PATCH_KEY_NAME];
  return typeof data === "number" ? getLViewById(data) : data || null;
}
function readPatchedLView(target) {
  const value = readPatchedData(target);
  if (value) {
    return (0, import_root_effect_scheduler.isLView)(value) ? value : value.lView;
  }
  return null;
}
function isComponentInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275cmp;
}
function isDirectiveInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275dir;
}
function findViaNativeElement(lView, target) {
  const tView = lView[import_root_effect_scheduler.TVIEW];
  for (let i = import_root_effect_scheduler.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if ((0, import_root_effect_scheduler.unwrapRNode)(lView[i]) === target) {
      return i;
    }
  }
  return -1;
}
function traverseNextElement(tNode) {
  if (tNode.child) {
    return tNode.child;
  } else if (tNode.next) {
    return tNode.next;
  } else {
    while (tNode.parent && !tNode.parent.next) {
      tNode = tNode.parent;
    }
    return tNode.parent && tNode.parent.next;
  }
}
function findViaComponent(lView, componentInstance) {
  const componentIndices = lView[import_root_effect_scheduler.TVIEW].components;
  if (componentIndices) {
    for (let i = 0; i < componentIndices.length; i++) {
      const elementComponentIndex = componentIndices[i];
      const componentView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(elementComponentIndex, lView);
      if (componentView[import_root_effect_scheduler.CONTEXT] === componentInstance) {
        return elementComponentIndex;
      }
    }
  } else {
    const rootComponentView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(import_root_effect_scheduler.HEADER_OFFSET, lView);
    const rootComponent = rootComponentView[import_root_effect_scheduler.CONTEXT];
    if (rootComponent === componentInstance) {
      return import_root_effect_scheduler.HEADER_OFFSET;
    }
  }
  return -1;
}
function findViaDirective(lView, directiveInstance) {
  let tNode = lView[import_root_effect_scheduler.TVIEW].firstChild;
  while (tNode) {
    const directiveIndexStart = tNode.directiveStart;
    const directiveIndexEnd = tNode.directiveEnd;
    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
      if (lView[i] === directiveInstance) {
        return tNode.index;
      }
    }
    tNode = traverseNextElement(tNode);
  }
  return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[import_root_effect_scheduler.TVIEW].data[nodeIndex];
  if (tNode.directiveStart === 0)
    return import_root_effect_scheduler.EMPTY_ARRAY;
  const results = [];
  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
    const directiveInstance = lView[i];
    if (!isComponentInstance(directiveInstance)) {
      results.push(directiveInstance);
    }
  }
  return results;
}
function getComponentAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[import_root_effect_scheduler.TVIEW].data[nodeIndex];
  return (0, import_root_effect_scheduler.isComponentHost)(tNode) ? lView[tNode.directiveStart + tNode.componentOffset] : null;
}
function discoverLocalRefs(lView, nodeIndex) {
  const tNode = lView[import_root_effect_scheduler.TVIEW].data[nodeIndex];
  if (tNode && tNode.localNames) {
    const result = {};
    let localIndex = tNode.index + 1;
    for (let i = 0; i < tNode.localNames.length; i += 2) {
      result[tNode.localNames[i]] = lView[localIndex];
      localIndex++;
    }
    return result;
  }
  return null;
}
function getRootView(componentOrLView) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(componentOrLView, "component");
  let lView = (0, import_root_effect_scheduler.isLView)(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
  while (lView && !(0, import_root_effect_scheduler.isRootView)(lView)) {
    lView = (0, import_root_effect_scheduler.getLViewParent)(lView);
  }
  ngDevMode && (0, import_root_effect_scheduler.assertLView)(lView);
  return lView;
}
function getRootContext(viewOrComponent) {
  const rootView = getRootView(viewOrComponent);
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(rootView[import_root_effect_scheduler.CONTEXT], "Root view has no context. Perhaps it is disconnected?");
  return rootView[import_root_effect_scheduler.CONTEXT];
}
function getFirstLContainer(lView) {
  return getNearestLContainer(lView[import_root_effect_scheduler.CHILD_HEAD]);
}
function getNextLContainer(container) {
  return getNearestLContainer(container[import_root_effect_scheduler.NEXT]);
}
function getNearestLContainer(viewOrContainer) {
  while (viewOrContainer !== null && !(0, import_root_effect_scheduler.isLContainer)(viewOrContainer)) {
    viewOrContainer = viewOrContainer[import_root_effect_scheduler.NEXT];
  }
  return viewOrContainer;
}
function getComponent(element) {
  ngDevMode && assertDomElement(element);
  const context = getLContext(element);
  if (context === null)
    return null;
  if (context.component === void 0) {
    const lView = context.lView;
    if (lView === null) {
      return null;
    }
    context.component = getComponentAtNodeIndex(context.nodeIndex, lView);
  }
  return context.component;
}
function getContext(element) {
  assertDomElement(element);
  const context = getLContext(element);
  const lView = context ? context.lView : null;
  return lView === null ? null : lView[import_root_effect_scheduler.CONTEXT];
}
function getOwningComponent(elementOrDir) {
  const context = getLContext(elementOrDir);
  let lView = context ? context.lView : null;
  if (lView === null)
    return null;
  let parent;
  while (lView[import_root_effect_scheduler.TVIEW].type === 2 && (parent = (0, import_root_effect_scheduler.getLViewParent)(lView))) {
    lView = parent;
  }
  return (0, import_root_effect_scheduler.isRootView)(lView) ? null : lView[import_root_effect_scheduler.CONTEXT];
}
function getRootComponents(elementOrDir) {
  const lView = readPatchedLView(elementOrDir);
  return lView !== null ? [getRootContext(lView)] : [];
}
function getInjector(elementOrDir) {
  const context = getLContext(elementOrDir);
  const lView = context ? context.lView : null;
  if (lView === null)
    return import_root_effect_scheduler.Injector.NULL;
  const tNode = lView[import_root_effect_scheduler.TVIEW].data[context.nodeIndex];
  return new NodeInjector(tNode, lView);
}
function getInjectionTokens(element) {
  const context = getLContext(element);
  const lView = context ? context.lView : null;
  if (lView === null)
    return [];
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const tNode = tView.data[context.nodeIndex];
  const providerTokens = [];
  const startIndex = tNode.providerIndexes & 1048575;
  const endIndex = tNode.directiveEnd;
  for (let i = startIndex; i < endIndex; i++) {
    let value = tView.data[i];
    if (isDirectiveDefHack(value)) {
      value = value.type;
    }
    providerTokens.push(value);
  }
  return providerTokens;
}
function getDirectives(node) {
  if (node instanceof Text) {
    return [];
  }
  const context = getLContext(node);
  const lView = context ? context.lView : null;
  if (lView === null) {
    return [];
  }
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const nodeIndex = context.nodeIndex;
  if (!(tView == null ? void 0 : tView.data[nodeIndex])) {
    return [];
  }
  if (context.directives === void 0) {
    context.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
  }
  return context.directives === null ? [] : [...context.directives];
}
var Framework;
(function(Framework2) {
  Framework2["Angular"] = "angular";
  Framework2["ACX"] = "acx";
  Framework2["Wiz"] = "wiz";
})(Framework || (Framework = {}));
var AcxChangeDetectionStrategy;
(function(AcxChangeDetectionStrategy2) {
  AcxChangeDetectionStrategy2[AcxChangeDetectionStrategy2["Default"] = 0] = "Default";
  AcxChangeDetectionStrategy2[AcxChangeDetectionStrategy2["OnPush"] = 1] = "OnPush";
})(AcxChangeDetectionStrategy || (AcxChangeDetectionStrategy = {}));
var AcxViewEncapsulation;
(function(AcxViewEncapsulation2) {
  AcxViewEncapsulation2[AcxViewEncapsulation2["Emulated"] = 0] = "Emulated";
  AcxViewEncapsulation2[AcxViewEncapsulation2["None"] = 1] = "None";
})(AcxViewEncapsulation || (AcxViewEncapsulation = {}));
function getDirectiveMetadata$1(directiveOrComponentInstance) {
  const { constructor } = directiveOrComponentInstance;
  if (!constructor) {
    throw new Error("Unable to find the instance constructor");
  }
  const componentDef = (0, import_root_effect_scheduler.getComponentDef)(constructor);
  if (componentDef) {
    const inputs = extractInputDebugMetadata(componentDef.inputs);
    return {
      inputs,
      outputs: componentDef.outputs,
      encapsulation: componentDef.encapsulation,
      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
  }
  const directiveDef = (0, import_root_effect_scheduler.getDirectiveDef)(constructor);
  if (directiveDef) {
    const inputs = extractInputDebugMetadata(directiveDef.inputs);
    return { inputs, outputs: directiveDef.outputs };
  }
  return null;
}
function getLocalRefs(target) {
  const context = getLContext(target);
  if (context === null)
    return {};
  if (context.localRefs === void 0) {
    const lView = context.lView;
    if (lView === null) {
      return {};
    }
    context.localRefs = discoverLocalRefs(lView, context.nodeIndex);
  }
  return context.localRefs || {};
}
function getHostElement(componentOrDirective) {
  return getLContext(componentOrDirective).native;
}
function getListeners(element) {
  ngDevMode && assertDomElement(element);
  const lContext = getLContext(element);
  const lView = lContext === null ? null : lContext.lView;
  if (lView === null)
    return [];
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const lCleanup = lView[import_root_effect_scheduler.CLEANUP];
  const tCleanup = tView.cleanup;
  const listeners = [];
  if (tCleanup && lCleanup) {
    for (let i = 0; i < tCleanup.length; ) {
      const firstParam = tCleanup[i++];
      const secondParam = tCleanup[i++];
      if (typeof firstParam === "string") {
        const name = firstParam;
        const listenerElement = (0, import_root_effect_scheduler.unwrapRNode)(lView[secondParam]);
        const callback = lCleanup[tCleanup[i++]];
        const useCaptureOrIndx = tCleanup[i++];
        const type = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
        const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
        if (element == listenerElement) {
          listeners.push({ element, name, callback, useCapture, type });
        }
      }
    }
  }
  listeners.sort(sortListeners);
  return listeners;
}
function sortListeners(a, b) {
  if (a.name == b.name)
    return 0;
  return a.name < b.name ? -1 : 1;
}
function isDirectiveDefHack(obj) {
  return obj.type !== void 0 && obj.declaredInputs !== void 0 && obj.resolveHostDirectives !== void 0;
}
function assertDomElement(value) {
  if (typeof Element !== "undefined" && !(value instanceof Element)) {
    throw new Error("Expecting instance of DOM Element");
  }
}
function extractInputDebugMetadata(inputs) {
  const res = {};
  for (const key in inputs) {
    if (inputs.hasOwnProperty(key)) {
      const value = inputs[key];
      if (value !== void 0) {
        res[key] = value[0];
      }
    }
  }
  return res;
}
let DOCUMENT = void 0;
function setDocument(document2) {
  DOCUMENT = document2;
}
function getDocument() {
  if (DOCUMENT !== void 0) {
    return DOCUMENT;
  } else if (typeof document !== "undefined") {
    return document;
  }
  throw new import_root_effect_scheduler.RuntimeError(210, (typeof ngDevMode === "undefined" || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);
}
const APP_ID = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "AppId" : "", {
  providedIn: "root",
  factory: () => DEFAULT_APP_ID
});
const DEFAULT_APP_ID = "ng";
const PLATFORM_INITIALIZER = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "Platform Initializer" : "");
const PLATFORM_ID = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "Platform ID" : "", {
  providedIn: "platform",
  factory: () => "unknown"
  // set a default platform name, when none set explicitly
});
const PACKAGE_ROOT_URL = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "Application Packages Root URL" : "");
const ANIMATION_MODULE_TYPE = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "AnimationModuleType" : "");
const CSP_NONCE = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "CSP nonce" : "", {
  providedIn: "root",
  factory: () => {
    var _a2, _b2;
    return ((_b2 = (_a2 = getDocument().body) == null ? void 0 : _a2.querySelector("[ngCspNonce]")) == null ? void 0 : _b2.getAttribute("ngCspNonce")) || null;
  }
});
const IMAGE_CONFIG_DEFAULTS = {
  breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  placeholderResolution: 30,
  disableImageSizeWarning: false,
  disableImageLazyLoadWarning: false
};
const IMAGE_CONFIG = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "ImageConfig" : "", {
  providedIn: "root",
  factory: () => IMAGE_CONFIG_DEFAULTS
});
function makeStateKey(key) {
  return key;
}
function initTransferState() {
  const transferState = new TransferState();
  if (typeof ngServerMode === "undefined" || !ngServerMode) {
    transferState.store = retrieveTransferredState(getDocument(), (0, import_root_effect_scheduler.inject)(APP_ID));
  }
  return transferState;
}
const _TransferState = class _TransferState {
  constructor() {
    /** @internal */
    __publicField(this, "store", {});
    __publicField(this, "onSerializeCallbacks", {});
  }
  /**
   * Get the value corresponding to a key. Return `defaultValue` if key is not found.
   */
  get(key, defaultValue) {
    return this.store[key] !== void 0 ? this.store[key] : defaultValue;
  }
  /**
   * Set the value corresponding to a key.
   */
  set(key, value) {
    this.store[key] = value;
  }
  /**
   * Remove a key from the store.
   */
  remove(key) {
    delete this.store[key];
  }
  /**
   * Test whether a key exists in the store.
   */
  hasKey(key) {
    return this.store.hasOwnProperty(key);
  }
  /**
   * Indicates whether the state is empty.
   */
  get isEmpty() {
    return Object.keys(this.store).length === 0;
  }
  /**
   * Register a callback to provide the value for a key when `toJson` is called.
   */
  onSerialize(key, callback) {
    this.onSerializeCallbacks[key] = callback;
  }
  /**
   * Serialize the current state of the store to JSON.
   */
  toJson() {
    for (const key in this.onSerializeCallbacks) {
      if (this.onSerializeCallbacks.hasOwnProperty(key)) {
        try {
          this.store[key] = this.onSerializeCallbacks[key]();
        } catch (e) {
          console.warn("Exception in onSerialize callback: ", e);
        }
      }
    }
    return JSON.stringify(this.store).replace(/</g, "\\u003C");
  }
};
/** @nocollapse */
__publicField(
  _TransferState,
  "\u0275prov",
  /** @pureOrBreakMyCode */
  /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({
    token: _TransferState,
    providedIn: "root",
    factory: initTransferState
  })
);
let TransferState = _TransferState;
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + "-state");
  if (script == null ? void 0 : script.textContent) {
    try {
      return JSON.parse(script.textContent);
    } catch (e) {
      console.warn("Exception while restoring TransferState for app " + appId, e);
    }
  }
  return {};
}
const REFERENCE_NODE_HOST = "h";
const REFERENCE_NODE_BODY = "b";
const NODE_NAVIGATION_STEP_FIRST_CHILD = "f";
const NODE_NAVIGATION_STEP_NEXT_SIBLING = "n";
const ELEMENT_CONTAINERS = "e";
const TEMPLATES = "t";
const CONTAINERS = "c";
const MULTIPLIER = "x";
const NUM_ROOT_NODES = "r";
const TEMPLATE_ID = "i";
const NODES = "n";
const DISCONNECTED_NODES = "d";
const I18N_DATA = "l";
const DEFER_BLOCK_ID = "di";
const DEFER_BLOCK_STATE$1 = "s";
const DEFER_PARENT_BLOCK_ID = "p";
const DEFER_HYDRATE_TRIGGERS = "t";
const IS_HYDRATION_DOM_REUSE_ENABLED = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "IS_HYDRATION_DOM_REUSE_ENABLED" : "");
const PRESERVE_HOST_CONTENT_DEFAULT = false;
const PRESERVE_HOST_CONTENT = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "PRESERVE_HOST_CONTENT" : "", {
  providedIn: "root",
  factory: () => PRESERVE_HOST_CONTENT_DEFAULT
});
const IS_I18N_HYDRATION_ENABLED = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "IS_I18N_HYDRATION_ENABLED" : "");
const IS_EVENT_REPLAY_ENABLED = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "IS_EVENT_REPLAY_ENABLED" : "");
const EVENT_REPLAY_ENABLED_DEFAULT = false;
const IS_INCREMENTAL_HYDRATION_ENABLED = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "IS_INCREMENTAL_HYDRATION_ENABLED" : "");
const JSACTION_BLOCK_ELEMENT_MAP = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "JSACTION_BLOCK_ELEMENT_MAP" : "", {
  providedIn: "root",
  factory: () => /* @__PURE__ */ new Map()
});
const IS_ENABLED_BLOCKING_INITIAL_NAVIGATION = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "IS_ENABLED_BLOCKING_INITIAL_NAVIGATION" : "");
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
const eventListenerOptions = {
  passive: true,
  capture: true
};
const hoverTriggers = /* @__PURE__ */ new WeakMap();
const interactionTriggers = /* @__PURE__ */ new WeakMap();
const viewportTriggers = /* @__PURE__ */ new WeakMap();
const interactionEventNames = ["click", "keydown"];
const hoverEventNames = ["mouseenter", "mouseover", "focusin"];
let intersectionObserver = null;
let observedViewportElements = 0;
class DeferEventEntry {
  constructor() {
    __publicField(this, "callbacks", /* @__PURE__ */ new Set());
    __publicField(this, "listener", () => {
      for (const callback of this.callbacks) {
        callback();
      }
    });
  }
}
function onInteraction(trigger, callback) {
  let entry = interactionTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    interactionTriggers.set(trigger, entry);
    for (const name of interactionEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const { callbacks, listener } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      interactionTriggers.delete(trigger);
      for (const name of interactionEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
    }
  };
}
function onHover(trigger, callback) {
  let entry = hoverTriggers.get(trigger);
  if (!entry) {
    entry = new DeferEventEntry();
    hoverTriggers.set(trigger, entry);
    for (const name of hoverEventNames) {
      trigger.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const { callbacks, listener } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      for (const name of hoverEventNames) {
        trigger.removeEventListener(name, listener, eventListenerOptions);
      }
      hoverTriggers.delete(trigger);
    }
  };
}
function createIntersectionObserver() {
  return new IntersectionObserver((entries) => {
    for (const current of entries) {
      if (current.isIntersecting && viewportTriggers.has(current.target)) {
        viewportTriggers.get(current.target).listener();
      }
    }
  });
}
function onViewport(trigger, callback, observerFactoryFn) {
  let entry = viewportTriggers.get(trigger);
  intersectionObserver = intersectionObserver || observerFactoryFn();
  if (!entry) {
    entry = new DeferEventEntry();
    intersectionObserver.observe(trigger);
    viewportTriggers.set(trigger, entry);
    observedViewportElements++;
  }
  entry.callbacks.add(callback);
  return () => {
    if (!viewportTriggers.has(trigger)) {
      return;
    }
    entry.callbacks.delete(callback);
    if (entry.callbacks.size === 0) {
      intersectionObserver == null ? void 0 : intersectionObserver.unobserve(trigger);
      viewportTriggers.delete(trigger);
      observedViewportElements--;
    }
    if (observedViewportElements === 0) {
      intersectionObserver == null ? void 0 : intersectionObserver.disconnect();
      intersectionObserver = null;
    }
  };
}
const DEFER_BLOCK_SSR_ID_ATTRIBUTE = "ngb";
function setJSActionAttributes(nativeElement, eventTypes, parentDeferBlockId = null) {
  if (eventTypes.length === 0 || nativeElement.nodeType !== Node.ELEMENT_NODE) {
    return;
  }
  const existingAttr = nativeElement.getAttribute(import_attribute.Attribute.JSACTION);
  const parts = eventTypes.reduce((prev, curr) => {
    var _a2;
    return ((_a2 = existingAttr == null ? void 0 : existingAttr.indexOf(curr)) != null ? _a2 : -1) === -1 ? prev + curr + ":;" : prev;
  }, "");
  nativeElement.setAttribute(import_attribute.Attribute.JSACTION, `${existingAttr != null ? existingAttr : ""}${parts}`);
  const blockName = parentDeferBlockId != null ? parentDeferBlockId : "";
  if (blockName !== "" && parts.length > 0) {
    nativeElement.setAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE, blockName);
  }
}
const sharedStashFunction = (rEl, eventType, listenerFn) => {
  var _a2, _b2;
  const el = rEl;
  const eventListenerMap = (_a2 = el.__jsaction_fns) != null ? _a2 : /* @__PURE__ */ new Map();
  const eventListeners = (_b2 = eventListenerMap.get(eventType)) != null ? _b2 : [];
  eventListeners.push(listenerFn);
  eventListenerMap.set(eventType, eventListeners);
  el.__jsaction_fns = eventListenerMap;
};
const sharedMapFunction = (rEl, jsActionMap) => {
  var _a2, _b2;
  const el = rEl;
  let blockName = (_a2 = el.getAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE)) != null ? _a2 : "";
  const blockSet = (_b2 = jsActionMap.get(blockName)) != null ? _b2 : /* @__PURE__ */ new Set();
  if (!blockSet.has(el)) {
    blockSet.add(el);
  }
  jsActionMap.set(blockName, blockSet);
};
function removeListenersFromBlocks(blockNames, jsActionMap) {
  if (blockNames.length > 0) {
    let blockList = [];
    for (let blockName of blockNames) {
      if (jsActionMap.has(blockName)) {
        blockList = [...blockList, ...jsActionMap.get(blockName)];
      }
    }
    const replayList = new Set(blockList);
    replayList.forEach(removeListeners);
  }
}
const removeListeners = (el) => {
  el.removeAttribute(import_attribute.Attribute.JSACTION);
  el.removeAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE);
  el.__jsaction_fns = void 0;
};
const JSACTION_EVENT_CONTRACT = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "EVENT_CONTRACT_DETAILS" : "", {
  providedIn: "root",
  factory: () => ({})
});
function invokeListeners(event, currentTarget) {
  var _a2;
  const handlerFns = (_a2 = currentTarget == null ? void 0 : currentTarget.__jsaction_fns) == null ? void 0 : _a2.get(event.type);
  if (!handlerFns || !(currentTarget == null ? void 0 : currentTarget.isConnected)) {
    return;
  }
  for (const handler of handlerFns) {
    handler(event);
  }
}
const stashEventListeners = /* @__PURE__ */ new Map();
function setStashFn(appId, fn) {
  stashEventListeners.set(appId, fn);
  return () => stashEventListeners.delete(appId);
}
let isStashEventListenerImplEnabled = false;
let _stashEventListenerImpl = (lView, target, eventName, wrappedListener) => {
};
function stashEventListenerImpl(lView, target, eventName, wrappedListener) {
  _stashEventListenerImpl(lView, target, eventName, wrappedListener);
}
function enableStashEventListenerImpl() {
  if (!isStashEventListenerImplEnabled) {
    _stashEventListenerImpl = (lView, target, eventName, wrappedListener) => {
      const appId = lView[import_root_effect_scheduler.INJECTOR$1].get(APP_ID);
      const stashEventListener = stashEventListeners.get(appId);
      stashEventListener == null ? void 0 : stashEventListener(target, eventName, wrappedListener);
    };
    isStashEventListenerImplEnabled = true;
  }
}
const DEHYDRATED_BLOCK_REGISTRY = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "DEHYDRATED_BLOCK_REGISTRY" : "");
const _DehydratedBlockRegistry = class _DehydratedBlockRegistry {
  constructor() {
    __publicField(this, "registry", /* @__PURE__ */ new Map());
    __publicField(this, "cleanupFns", /* @__PURE__ */ new Map());
    __publicField(this, "jsActionMap", (0, import_root_effect_scheduler.inject)(JSACTION_BLOCK_ELEMENT_MAP));
    __publicField(this, "contract", (0, import_root_effect_scheduler.inject)(JSACTION_EVENT_CONTRACT));
    // Blocks that are being hydrated.
    __publicField(this, "hydrating", /* @__PURE__ */ new Map());
    // Blocks that are awaiting a defer instruction finish.
    __publicField(this, "awaitingCallbacks", /* @__PURE__ */ new Map());
  }
  add(blockId, info) {
    this.registry.set(blockId, info);
    if (this.awaitingCallbacks.has(blockId)) {
      const awaitingCallbacks = this.awaitingCallbacks.get(blockId);
      for (const cb of awaitingCallbacks) {
        cb();
      }
    }
  }
  get(blockId) {
    var _a2;
    return (_a2 = this.registry.get(blockId)) != null ? _a2 : null;
  }
  has(blockId) {
    return this.registry.has(blockId);
  }
  cleanup(hydratedBlocks) {
    var _a2;
    removeListenersFromBlocks(hydratedBlocks, this.jsActionMap);
    for (let blockId of hydratedBlocks) {
      this.registry.delete(blockId);
      this.jsActionMap.delete(blockId);
      this.invokeTriggerCleanupFns(blockId);
      this.hydrating.delete(blockId);
      this.awaitingCallbacks.delete(blockId);
    }
    if (this.size === 0) {
      (_a2 = this.contract.instance) == null ? void 0 : _a2.cleanUp();
    }
  }
  get size() {
    return this.registry.size;
  }
  // we have to leave the lowest block Id in the registry
  // unless that block has no children
  addCleanupFn(blockId, fn) {
    let cleanupFunctions = [];
    if (this.cleanupFns.has(blockId)) {
      cleanupFunctions = this.cleanupFns.get(blockId);
    }
    cleanupFunctions.push(fn);
    this.cleanupFns.set(blockId, cleanupFunctions);
  }
  invokeTriggerCleanupFns(blockId) {
    var _a2;
    const fns = (_a2 = this.cleanupFns.get(blockId)) != null ? _a2 : [];
    for (let fn of fns) {
      fn();
    }
    this.cleanupFns.delete(blockId);
  }
  awaitParentBlock(topmostParentBlock, callback) {
    var _a2;
    const parentBlockAwaitCallbacks = (_a2 = this.awaitingCallbacks.get(topmostParentBlock)) != null ? _a2 : [];
    parentBlockAwaitCallbacks.push(callback);
    this.awaitingCallbacks.set(topmostParentBlock, parentBlockAwaitCallbacks);
  }
};
/** @nocollapse */
__publicField(
  _DehydratedBlockRegistry,
  "\u0275prov",
  /** @pureOrBreakMyCode */
  /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({
    token: _DehydratedBlockRegistry,
    providedIn: null,
    factory: () => new _DehydratedBlockRegistry()
  })
);
let DehydratedBlockRegistry = _DehydratedBlockRegistry;
function isDetachedByI18n(tNode) {
  return (tNode.flags & 32) === 32;
}
const TRANSFER_STATE_TOKEN_ID = "__nghData__";
const NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
const TRANSFER_STATE_DEFER_BLOCKS_INFO = "__nghDeferData__";
const NGH_DEFER_BLOCKS_KEY = makeStateKey(TRANSFER_STATE_DEFER_BLOCKS_INFO);
function isInternalHydrationTransferStateKey(key) {
  return key === TRANSFER_STATE_TOKEN_ID || key === TRANSFER_STATE_DEFER_BLOCKS_INFO;
}
const NGH_ATTR_NAME = "ngh";
const SSR_CONTENT_INTEGRITY_MARKER = "nghm";
let _retrieveHydrationInfoImpl = () => null;
function retrieveHydrationInfoImpl(rNode, injector, isRootView2 = false) {
  var _a2;
  let nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);
  if (nghAttrValue == null)
    return null;
  const [componentViewNgh, rootViewNgh] = nghAttrValue.split("|");
  nghAttrValue = isRootView2 ? rootViewNgh : componentViewNgh;
  if (!nghAttrValue)
    return null;
  const rootNgh = rootViewNgh ? `|${rootViewNgh}` : "";
  const remainingNgh = isRootView2 ? componentViewNgh : rootNgh;
  let data = {};
  if (nghAttrValue !== "") {
    const transferState = injector.get(TransferState, null, { optional: true });
    if (transferState !== null) {
      const nghData = transferState.get(NGH_DATA_KEY, []);
      data = nghData[Number(nghAttrValue)];
      ngDevMode && (0, import_root_effect_scheduler.assertDefined)(data, "Unable to retrieve hydration info from the TransferState.");
    }
  }
  const dehydratedView = {
    data,
    firstChild: (_a2 = rNode.firstChild) != null ? _a2 : null
  };
  if (isRootView2) {
    dehydratedView.firstChild = rNode;
    setSegmentHead(dehydratedView, 0, rNode.nextSibling);
  }
  if (remainingNgh) {
    rNode.setAttribute(NGH_ATTR_NAME, remainingNgh);
  } else {
    rNode.removeAttribute(NGH_ATTR_NAME);
  }
  ngDevMode && markRNodeAsClaimedByHydration(
    rNode,
    /* checkIfAlreadyClaimed */
    false
  );
  ngDevMode && ngDevMode.hydratedComponents++;
  return dehydratedView;
}
function enableRetrieveHydrationInfoImpl() {
  _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;
}
function retrieveHydrationInfo(rNode, injector, isRootView2 = false) {
  return _retrieveHydrationInfoImpl(rNode, injector, isRootView2);
}
function getLNodeForHydration(viewRef) {
  let lView = viewRef._lView;
  const tView = lView[import_root_effect_scheduler.TVIEW];
  if (tView.type === 2) {
    return null;
  }
  if ((0, import_root_effect_scheduler.isRootView)(lView)) {
    lView = lView[import_root_effect_scheduler.HEADER_OFFSET];
  }
  return lView;
}
function getTextNodeContent(node) {
  var _a2;
  return (_a2 = node.textContent) == null ? void 0 : _a2.replace(/\s/gm, "");
}
function processTextNodeMarkersBeforeHydration(node) {
  const doc = getDocument();
  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode(node2) {
      const content = getTextNodeContent(node2);
      const isTextNodeMarker = content === "ngetn" || content === "ngtns";
      return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
    }
  });
  let currentNode;
  const nodes = [];
  while (currentNode = commentNodesIterator.nextNode()) {
    nodes.push(currentNode);
  }
  for (const node2 of nodes) {
    if (node2.textContent === "ngetn") {
      node2.replaceWith(doc.createTextNode(""));
    } else {
      node2.remove();
    }
  }
}
var HydrationStatus;
(function(HydrationStatus2) {
  HydrationStatus2["Hydrated"] = "hydrated";
  HydrationStatus2["Skipped"] = "skipped";
  HydrationStatus2["Mismatched"] = "mismatched";
})(HydrationStatus || (HydrationStatus = {}));
const HYDRATION_INFO_KEY = "__ngDebugHydrationInfo__";
function patchHydrationInfo(node, info) {
  node[HYDRATION_INFO_KEY] = info;
}
function readHydrationInfo(node) {
  var _a2;
  return (_a2 = node[HYDRATION_INFO_KEY]) != null ? _a2 : null;
}
function markRNodeAsClaimedByHydration(node, checkIfAlreadyClaimed = true) {
  if (!ngDevMode) {
    throw new Error("Calling `markRNodeAsClaimedByHydration` in prod mode is not supported and likely a mistake.");
  }
  if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {
    throw new Error("Trying to claim a node, which was claimed already.");
  }
  patchHydrationInfo(node, { status: HydrationStatus.Hydrated });
  ngDevMode.hydratedNodes++;
}
function markRNodeAsSkippedByHydration(node) {
  if (!ngDevMode) {
    throw new Error("Calling `markRNodeAsSkippedByHydration` in prod mode is not supported and likely a mistake.");
  }
  patchHydrationInfo(node, { status: HydrationStatus.Skipped });
  ngDevMode.componentsSkippedHydration++;
}
function countBlocksSkippedByHydration(injector) {
  const transferState = injector.get(TransferState);
  const nghDeferData = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  if (ngDevMode) {
    ngDevMode.deferBlocksWithIncrementalHydration = Object.keys(nghDeferData).length;
  }
}
function markRNodeAsHavingHydrationMismatch(node, expectedNodeDetails = null, actualNodeDetails = null) {
  if (!ngDevMode) {
    throw new Error("Calling `markRNodeAsMismatchedByHydration` in prod mode is not supported and likely a mistake.");
  }
  while (node && !getComponent(node)) {
    node = node == null ? void 0 : node.parentNode;
  }
  if (node) {
    patchHydrationInfo(node, {
      status: HydrationStatus.Mismatched,
      expectedNodeDetails,
      actualNodeDetails
    });
  }
}
function isRNodeClaimedForHydration(node) {
  var _a2;
  return ((_a2 = readHydrationInfo(node)) == null ? void 0 : _a2.status) === HydrationStatus.Hydrated;
}
function setSegmentHead(hydrationInfo, index, node) {
  var _a2;
  (_a2 = hydrationInfo.segmentHeads) != null ? _a2 : hydrationInfo.segmentHeads = {};
  hydrationInfo.segmentHeads[index] = node;
}
function getSegmentHead(hydrationInfo, index) {
  var _a2, _b2;
  return (_b2 = (_a2 = hydrationInfo.segmentHeads) == null ? void 0 : _a2[index]) != null ? _b2 : null;
}
function isIncrementalHydrationEnabled(injector) {
  return injector.get(IS_INCREMENTAL_HYDRATION_ENABLED, false, {
    optional: true
  });
}
let incrementalHydrationEnabledWarned = false;
function resetIncrementalHydrationEnabledWarnedForTests() {
  incrementalHydrationEnabledWarned = false;
}
function warnIncrementalHydrationNotConfigured() {
  if (!incrementalHydrationEnabledWarned) {
    incrementalHydrationEnabledWarned = true;
    console.warn((0, import_root_effect_scheduler.formatRuntimeError)(508, "Angular has detected that some `@defer` blocks use `hydrate` triggers, but incremental hydration was not enabled. Please ensure that the `withIncrementalHydration()` call is added as an argument for the `provideClientHydration()` function call in your application config."));
  }
}
function assertSsrIdDefined(ssrUniqueId) {
  (0, import_root_effect_scheduler.assertDefined)(ssrUniqueId, "Internal error: expecting an SSR id for a defer block that should be hydrated, but the id is not present");
}
function getNgContainerSize(hydrationInfo, index) {
  var _a2, _b2, _c2;
  const data = hydrationInfo.data;
  let size = (_b2 = (_a2 = data[ELEMENT_CONTAINERS]) == null ? void 0 : _a2[index]) != null ? _b2 : null;
  if (size === null && ((_c2 = data[CONTAINERS]) == null ? void 0 : _c2[index])) {
    size = calcSerializedContainerSize(hydrationInfo, index);
  }
  return size;
}
function isSerializedElementContainer(hydrationInfo, index) {
  var _a2;
  return ((_a2 = hydrationInfo.data[ELEMENT_CONTAINERS]) == null ? void 0 : _a2[index]) !== void 0;
}
function getSerializedContainerViews(hydrationInfo, index) {
  var _a2, _b2;
  return (_b2 = (_a2 = hydrationInfo.data[CONTAINERS]) == null ? void 0 : _a2[index]) != null ? _b2 : null;
}
function calcSerializedContainerSize(hydrationInfo, index) {
  var _a2, _b2;
  const views = (_a2 = getSerializedContainerViews(hydrationInfo, index)) != null ? _a2 : [];
  let numNodes = 0;
  for (let view of views) {
    numNodes += view[NUM_ROOT_NODES] * ((_b2 = view[MULTIPLIER]) != null ? _b2 : 1);
  }
  return numNodes;
}
function initDisconnectedNodes(hydrationInfo) {
  if (typeof hydrationInfo.disconnectedNodes === "undefined") {
    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];
    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;
  }
  return hydrationInfo.disconnectedNodes;
}
function isDisconnectedNode$1(hydrationInfo, index) {
  var _a2;
  if (typeof hydrationInfo.disconnectedNodes === "undefined") {
    const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];
    hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;
  }
  return !!((_a2 = initDisconnectedNodes(hydrationInfo)) == null ? void 0 : _a2.has(index));
}
function canHydrateNode(lView, tNode) {
  const hydrationInfo = lView[import_root_effect_scheduler.HYDRATION];
  return hydrationInfo !== null && !(0, import_root_effect_scheduler.isInSkipHydrationBlock)() && !isDetachedByI18n(tNode) && !isDisconnectedNode$1(hydrationInfo, tNode.index - import_root_effect_scheduler.HEADER_OFFSET);
}
function processTextNodeBeforeSerialization(context, node) {
  var _a2;
  const el = node;
  const corruptedTextNodes = context.corruptedTextNodes;
  if (el.textContent === "") {
    corruptedTextNodes.set(
      el,
      "ngetn"
      /* TextNodeMarker.EmptyNode */
    );
  } else if (((_a2 = el.nextSibling) == null ? void 0 : _a2.nodeType) === Node.TEXT_NODE) {
    corruptedTextNodes.set(
      el,
      "ngtns"
      /* TextNodeMarker.Separator */
    );
  }
}
function convertHydrateTriggersToJsAction(triggers) {
  let actionList = [];
  if (triggers !== null) {
    if (triggers.has(
      4
      /* DeferBlockTrigger.Hover */
    )) {
      actionList.push(...hoverEventNames);
    }
    if (triggers.has(
      3
      /* DeferBlockTrigger.Interaction */
    )) {
      actionList.push(...interactionEventNames);
    }
  }
  return actionList;
}
function getParentBlockHydrationQueue(deferBlockId, injector) {
  const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
  const transferState = injector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  let isTopMostDeferBlock = false;
  let currentBlockId = deferBlockId;
  let parentBlockPromise = null;
  const hydrationQueue = [];
  while (!isTopMostDeferBlock && currentBlockId) {
    ngDevMode && (0, import_root_effect_scheduler.assertEqual)(hydrationQueue.indexOf(currentBlockId), -1, "Internal error: defer block hierarchy has a cycle.");
    isTopMostDeferBlock = dehydratedBlockRegistry.has(currentBlockId);
    const hydratingParentBlock = dehydratedBlockRegistry.hydrating.get(currentBlockId);
    if (parentBlockPromise === null && hydratingParentBlock != null) {
      parentBlockPromise = hydratingParentBlock.promise;
      break;
    }
    hydrationQueue.unshift(currentBlockId);
    currentBlockId = deferBlockParents[currentBlockId][DEFER_PARENT_BLOCK_ID];
  }
  return { parentBlockPromise, hydrationQueue };
}
function gatherDeferBlocksByJSActionAttribute(doc) {
  const jsactionNodes = doc.body.querySelectorAll("[jsaction]");
  const blockMap = /* @__PURE__ */ new Set();
  const eventTypes = [hoverEventNames.join(":;"), interactionEventNames.join(":;")].join("|");
  for (let node of jsactionNodes) {
    const attr = node.getAttribute("jsaction");
    const blockId = node.getAttribute("ngb");
    if ((attr == null ? void 0 : attr.match(eventTypes)) && blockId !== null) {
      blockMap.add(node);
    }
  }
  return blockMap;
}
function appendDeferBlocksToJSActionMap(doc, injector) {
  const blockMap = gatherDeferBlocksByJSActionAttribute(doc);
  const jsActionMap = injector.get(JSACTION_BLOCK_ELEMENT_MAP);
  for (let rNode of blockMap) {
    sharedMapFunction(rNode, jsActionMap);
  }
}
let _retrieveDeferBlockDataImpl = () => {
  return {};
};
function retrieveDeferBlockDataImpl(injector) {
  const transferState = injector.get(TransferState, null, { optional: true });
  if (transferState !== null) {
    const nghDeferData = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(nghDeferData, "Unable to retrieve defer block info from the TransferState.");
    return nghDeferData;
  }
  return {};
}
function enableRetrieveDeferBlockDataImpl() {
  _retrieveDeferBlockDataImpl = retrieveDeferBlockDataImpl;
}
function retrieveDeferBlockData(injector) {
  return _retrieveDeferBlockDataImpl(injector);
}
function isTimerTrigger(triggerInfo) {
  return typeof triggerInfo === "object" && triggerInfo.trigger === 5;
}
function getHydrateTimerTrigger(blockData) {
  var _a2, _b2;
  const trigger = (_a2 = blockData[DEFER_HYDRATE_TRIGGERS]) == null ? void 0 : _a2.find((t) => isTimerTrigger(t));
  return (_b2 = trigger == null ? void 0 : trigger.delay) != null ? _b2 : null;
}
function hasHydrateTrigger(blockData, trigger) {
  var _a2, _b2;
  return (_b2 = (_a2 = blockData[DEFER_HYDRATE_TRIGGERS]) == null ? void 0 : _a2.includes(trigger)) != null ? _b2 : false;
}
function createBlockSummary(blockInfo) {
  return {
    data: blockInfo,
    hydrate: {
      idle: hasHydrateTrigger(
        blockInfo,
        0
        /* DeferBlockTrigger.Idle */
      ),
      immediate: hasHydrateTrigger(
        blockInfo,
        1
        /* DeferBlockTrigger.Immediate */
      ),
      timer: getHydrateTimerTrigger(blockInfo),
      viewport: hasHydrateTrigger(
        blockInfo,
        2
        /* DeferBlockTrigger.Viewport */
      )
    }
  };
}
function processBlockData(injector) {
  const blockData = retrieveDeferBlockData(injector);
  let blockDetails = /* @__PURE__ */ new Map();
  for (let blockId in blockData) {
    blockDetails.set(blockId, createBlockSummary(blockData[blockId]));
  }
  return blockDetails;
}
function isSsrContentsIntegrity(node) {
  var _a2;
  return !!node && node.nodeType === Node.COMMENT_NODE && ((_a2 = node.textContent) == null ? void 0 : _a2.trim()) === SSR_CONTENT_INTEGRITY_MARKER;
}
function skipTextNodes(node) {
  while (node && node.nodeType === Node.TEXT_NODE) {
    node = node.previousSibling;
  }
  return node;
}
function verifySsrContentsIntegrity(doc) {
  for (const node of doc.body.childNodes) {
    if (isSsrContentsIntegrity(node)) {
      return;
    }
  }
  const beforeBody = skipTextNodes(doc.body.previousSibling);
  if (isSsrContentsIntegrity(beforeBody)) {
    return;
  }
  let endOfHead = skipTextNodes(doc.head.lastChild);
  if (isSsrContentsIntegrity(endOfHead)) {
    return;
  }
  throw new import_root_effect_scheduler.RuntimeError(-507, typeof ngDevMode !== "undefined" && ngDevMode && "Angular hydration logic detected that HTML content of this page was modified after it was produced during server side rendering. Make sure that there are no optimizations that remove comment nodes from HTML enabled on your CDN. Angular hydration relies on HTML produced by the server, including whitespaces and comment nodes.");
}
function refreshContentQueries(tView, lView) {
  const contentQueries = tView.contentQueries;
  if (contentQueries !== null) {
    const prevConsumer = (0, import_signal.setActiveConsumer)(null);
    try {
      for (let i = 0; i < contentQueries.length; i += 2) {
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && (0, import_root_effect_scheduler.assertDefined)(directiveDef, "DirectiveDef not found.");
          ngDevMode && (0, import_root_effect_scheduler.assertDefined)(directiveDef.contentQueries, "contentQueries function should be defined");
          (0, import_root_effect_scheduler.setCurrentQueryIndex)(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    } finally {
      (0, import_signal.setActiveConsumer)(prevConsumer);
    }
  }
}
function executeViewQueryFn(flags, viewQueryFn, component) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(viewQueryFn, "View queries function to execute must be defined.");
  (0, import_root_effect_scheduler.setCurrentQueryIndex)(0);
  const prevConsumer = (0, import_signal.setActiveConsumer)(null);
  try {
    viewQueryFn(flags, component);
  } finally {
    (0, import_signal.setActiveConsumer)(prevConsumer);
  }
}
function executeContentQueries(tView, tNode, lView) {
  if ((0, import_root_effect_scheduler.isContentQueryHost)(tNode)) {
    const prevConsumer = (0, import_signal.setActiveConsumer)(null);
    try {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          const directiveInstance = lView[directiveIndex];
          ngDevMode && (0, import_root_effect_scheduler.assertDefined)(directiveIndex, "Incorrect reference to a directive defining a content query");
          def.contentQueries(1, directiveInstance, directiveIndex);
        }
      }
    } finally {
      (0, import_signal.setActiveConsumer)(prevConsumer);
    }
  }
}
var ViewEncapsulation;
(function(ViewEncapsulation2) {
  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
})(ViewEncapsulation || (ViewEncapsulation = {}));
const CUSTOM_ELEMENTS_SCHEMA = {
  name: "custom-elements"
};
const NO_ERRORS_SCHEMA = {
  name: "no-errors-schema"
};
let shouldThrowErrorOnUnknownElement = false;
function \u0275setUnknownElementStrictMode(shouldThrow) {
  shouldThrowErrorOnUnknownElement = shouldThrow;
}
function \u0275getUnknownElementStrictMode() {
  return shouldThrowErrorOnUnknownElement;
}
let shouldThrowErrorOnUnknownProperty = false;
function \u0275setUnknownPropertyStrictMode(shouldThrow) {
  shouldThrowErrorOnUnknownProperty = shouldThrow;
}
function \u0275getUnknownPropertyStrictMode() {
  return shouldThrowErrorOnUnknownProperty;
}
function validateElementIsKnown(lView, tNode) {
  const tView = lView[import_root_effect_scheduler.TVIEW];
  if (tView.schemas === null)
    return;
  const tagName = tNode.value;
  if (!(0, import_root_effect_scheduler.isDirectiveHost)(tNode) && tagName !== null) {
    const isUnknown = (
      // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because
      // Domino doesn't expose HTMLUnknownElement globally.
      typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView) instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName)
    );
    if (isUnknown && !matchingSchemas(tView.schemas, tagName)) {
      const isHostStandalone = isHostComponentStandalone(lView);
      const templateLocation = getTemplateLocationDetails(lView);
      const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
      let message = `'${tagName}' is not a known element${templateLocation}:
`;
      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared"}.
`;
      if (tagName && tagName.indexOf("-") > -1) {
        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      } else {
        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
      }
      if (shouldThrowErrorOnUnknownElement) {
        throw new import_root_effect_scheduler.RuntimeError(304, message);
      } else {
        console.error((0, import_root_effect_scheduler.formatRuntimeError)(304, message));
      }
    }
  }
}
function isPropertyValid(element, propName, tagName, schemas) {
  if (schemas === null)
    return true;
  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
    return true;
  }
  return typeof Node === "undefined" || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
  if (!tagName && nodeType === 4) {
    tagName = "ng-template";
  }
  const isHostStandalone = isHostComponentStandalone(lView);
  const templateLocation = getTemplateLocationDetails(lView);
  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
  const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared";
  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
    message += `
If the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
  } else {
    message += `
1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;
    if (tagName && tagName.indexOf("-") > -1) {
      message += `
2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      message += `
3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    } else {
      message += `
2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    }
  }
  reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
  if (shouldThrowErrorOnUnknownProperty) {
    throw new import_root_effect_scheduler.RuntimeError(303, message);
  } else {
    console.error((0, import_root_effect_scheduler.formatRuntimeError)(303, message));
  }
}
function getDeclarationComponentDef(lView) {
  !ngDevMode && (0, import_root_effect_scheduler.throwError)("Must never be called in production mode");
  const declarationLView = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[import_root_effect_scheduler.CONTEXT];
  if (!context)
    return null;
  return context.constructor ? (0, import_root_effect_scheduler.getComponentDef)(context.constructor) : null;
}
function isHostComponentStandalone(lView) {
  !ngDevMode && (0, import_root_effect_scheduler.throwError)("Must never be called in production mode");
  const componentDef = getDeclarationComponentDef(lView);
  return !!(componentDef == null ? void 0 : componentDef.standalone);
}
function getTemplateLocationDetails(lView) {
  var _a2;
  !ngDevMode && (0, import_root_effect_scheduler.throwError)("Must never be called in production mode");
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = (_a2 = hostComponentDef == null ? void 0 : hostComponentDef.type) == null ? void 0 : _a2.name;
  return componentClassName ? ` (used in the '${componentClassName}' component template)` : "";
}
const KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([
  ["ngIf", "NgIf"],
  ["ngFor", "NgFor"],
  ["ngSwitchCase", "NgSwitchCase"],
  ["ngSwitchDefault", "NgSwitchDefault"]
]);
function matchingSchemas(schemas, tagName) {
  if (schemas !== null) {
    for (let i = 0; i < schemas.length; i++) {
      const schema = schemas[i];
      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
        return true;
      }
    }
  }
  return false;
}
let policy$1;
function getPolicy$1() {
  if (policy$1 === void 0) {
    policy$1 = null;
    if (import_root_effect_scheduler._global.trustedTypes) {
      try {
        policy$1 = import_root_effect_scheduler._global.trustedTypes.createPolicy("angular", {
          createHTML: (s) => s,
          createScript: (s) => s,
          createScriptURL: (s) => s
        });
      } catch (e) {
      }
    }
  }
  return policy$1;
}
function trustedHTMLFromString(html) {
  var _a2;
  return ((_a2 = getPolicy$1()) == null ? void 0 : _a2.createHTML(html)) || html;
}
function trustedScriptURLFromString(url) {
  var _a2;
  return ((_a2 = getPolicy$1()) == null ? void 0 : _a2.createScriptURL(url)) || url;
}
let policy;
function getPolicy() {
  if (policy === void 0) {
    policy = null;
    if (import_root_effect_scheduler._global.trustedTypes) {
      try {
        policy = import_root_effect_scheduler._global.trustedTypes.createPolicy("angular#unsafe-bypass", {
          createHTML: (s) => s,
          createScript: (s) => s,
          createScriptURL: (s) => s
        });
      } catch (e) {
      }
    }
  }
  return policy;
}
function trustedHTMLFromStringBypass(html) {
  var _a2;
  return ((_a2 = getPolicy()) == null ? void 0 : _a2.createHTML(html)) || html;
}
function trustedScriptFromStringBypass(script) {
  var _a2;
  return ((_a2 = getPolicy()) == null ? void 0 : _a2.createScript(script)) || script;
}
function trustedScriptURLFromStringBypass(url) {
  var _a2;
  return ((_a2 = getPolicy()) == null ? void 0 : _a2.createScriptURL(url)) || url;
}
class SafeValueImpl {
  constructor(changingThisBreaksApplicationSecurity) {
    __publicField(this, "changingThisBreaksApplicationSecurity");
    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
  }
  toString() {
    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${import_root_effect_scheduler.XSS_SECURITY_URL})`;
  }
}
class SafeHtmlImpl extends SafeValueImpl {
  getTypeName() {
    return "HTML";
  }
}
class SafeStyleImpl extends SafeValueImpl {
  getTypeName() {
    return "Style";
  }
}
class SafeScriptImpl extends SafeValueImpl {
  getTypeName() {
    return "Script";
  }
}
class SafeUrlImpl extends SafeValueImpl {
  getTypeName() {
    return "URL";
  }
}
class SafeResourceUrlImpl extends SafeValueImpl {
  getTypeName() {
    return "ResourceURL";
  }
}
function unwrapSafeValue(value) {
  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
}
function allowSanitizationBypassAndThrow(value, type) {
  const actualType = getSanitizationBypassType(value);
  if (actualType != null && actualType !== type) {
    if (actualType === "ResourceURL" && type === "URL")
      return true;
    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${import_root_effect_scheduler.XSS_SECURITY_URL})`);
  }
  return actualType === type;
}
function getSanitizationBypassType(value) {
  return value instanceof SafeValueImpl && value.getTypeName() || null;
}
function bypassSanitizationTrustHtml(trustedHtml) {
  return new SafeHtmlImpl(trustedHtml);
}
function bypassSanitizationTrustStyle(trustedStyle) {
  return new SafeStyleImpl(trustedStyle);
}
function bypassSanitizationTrustScript(trustedScript) {
  return new SafeScriptImpl(trustedScript);
}
function bypassSanitizationTrustUrl(trustedUrl) {
  return new SafeUrlImpl(trustedUrl);
}
function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
  return new SafeResourceUrlImpl(trustedResourceUrl);
}
function getInertBodyHelper(defaultDoc) {
  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
class DOMParserHelper {
  constructor(inertDocumentHelper) {
    __publicField(this, "inertDocumentHelper");
    this.inertDocumentHelper = inertDocumentHelper;
  }
  getInertBodyElement(html) {
    var _a2;
    html = "<body><remove></remove>" + html;
    try {
      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), "text/html").body;
      if (body === null) {
        return this.inertDocumentHelper.getInertBodyElement(html);
      }
      (_a2 = body.firstChild) == null ? void 0 : _a2.remove();
      return body;
    } catch (e) {
      return null;
    }
  }
}
class InertDocumentHelper {
  constructor(defaultDoc) {
    __publicField(this, "defaultDoc");
    __publicField(this, "inertDocument");
    this.defaultDoc = defaultDoc;
    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
  }
  getInertBodyElement(html) {
    const templateEl = this.inertDocument.createElement("template");
    templateEl.innerHTML = trustedHTMLFromString(html);
    return templateEl;
  }
}
function isDOMParserAvailable() {
  try {
    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
  } catch (e) {
    return false;
  }
}
const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
function _sanitizeUrl(url) {
  url = String(url);
  if (url.match(SAFE_URL_PATTERN))
    return url;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${import_root_effect_scheduler.XSS_SECURITY_URL})`);
  }
  return "unsafe:" + url;
}
function tagSet(tags) {
  const res = {};
  for (const t of tags.split(","))
    res[t] = true;
  return res;
}
function merge(...sets) {
  const res = {};
  for (const s of sets) {
    for (const v in s) {
      if (s.hasOwnProperty(v))
        res[v] = true;
    }
  }
  return res;
}
const VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
const OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
const OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
const OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
const BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
const INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
const VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
const URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
const HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
const ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
const VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
const SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
class SanitizingHtmlSerializer {
  constructor() {
    // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just
    // because characters were re-encoded.
    __publicField(this, "sanitizedSomething", false);
    __publicField(this, "buf", []);
  }
  sanitizeChildren(el) {
    let current = el.firstChild;
    let traverseContent = true;
    let parentNodes = [];
    while (current) {
      if (current.nodeType === Node.ELEMENT_NODE) {
        traverseContent = this.startElement(current);
      } else if (current.nodeType === Node.TEXT_NODE) {
        this.chars(current.nodeValue);
      } else {
        this.sanitizedSomething = true;
      }
      if (traverseContent && current.firstChild) {
        parentNodes.push(current);
        current = getFirstChild(current);
        continue;
      }
      while (current) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          this.endElement(current);
        }
        let next = getNextSibling(current);
        if (next) {
          current = next;
          break;
        }
        current = parentNodes.pop();
      }
    }
    return this.buf.join("");
  }
  /**
   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should
   * be traversed. Element content must always be traversed (even if the element itself is not
   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.
   *
   * @param element The element to sanitize.
   * @return True if the element's contents should be traversed.
   */
  startElement(element) {
    const tagName = getNodeName(element).toLowerCase();
    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
      this.sanitizedSomething = true;
      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
    }
    this.buf.push("<");
    this.buf.push(tagName);
    const elAttrs = element.attributes;
    for (let i = 0; i < elAttrs.length; i++) {
      const elAttr = elAttrs.item(i);
      const attrName = elAttr.name;
      const lower = attrName.toLowerCase();
      if (!VALID_ATTRS.hasOwnProperty(lower)) {
        this.sanitizedSomething = true;
        continue;
      }
      let value = elAttr.value;
      if (URI_ATTRS[lower])
        value = _sanitizeUrl(value);
      this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
    }
    this.buf.push(">");
    return true;
  }
  endElement(current) {
    const tagName = getNodeName(current).toLowerCase();
    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
      this.buf.push("</");
      this.buf.push(tagName);
      this.buf.push(">");
    }
  }
  chars(chars) {
    this.buf.push(encodeEntities(chars));
  }
}
function isClobberedElement(parentNode, childNode) {
  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
}
function getNextSibling(node) {
  const nextSibling = node.nextSibling;
  if (nextSibling && node !== nextSibling.previousSibling) {
    throw clobberedElementError(nextSibling);
  }
  return nextSibling;
}
function getFirstChild(node) {
  const firstChild = node.firstChild;
  if (firstChild && isClobberedElement(node, firstChild)) {
    throw clobberedElementError(firstChild);
  }
  return firstChild;
}
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === "string" ? nodeName : "FORM";
}
function clobberedElementError(node) {
  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
}
const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
const NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
function encodeEntities(value) {
  return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match) {
    const hi = match.charCodeAt(0);
    const low = match.charCodeAt(1);
    return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
  }).replace(NON_ALPHANUMERIC_REGEXP, function(match) {
    return "&#" + match.charCodeAt(0) + ";";
  }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
let inertBodyHelper;
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
  let inertBodyElement = null;
  try {
    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    let mXSSAttempts = 5;
    let parsedHtml = unsafeHtml;
    do {
      if (mXSSAttempts === 0) {
        throw new Error("Failed to sanitize html because the input is unstable");
      }
      mXSSAttempts--;
      unsafeHtml = parsedHtml;
      parsedHtml = inertBodyElement.innerHTML;
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    } while (unsafeHtml !== parsedHtml);
    const sanitizer = new SanitizingHtmlSerializer();
    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && sanitizer.sanitizedSomething) {
      console.warn(`WARNING: sanitizing HTML stripped some content, see ${import_root_effect_scheduler.XSS_SECURITY_URL}`);
    }
    return trustedHTMLFromString(safeHtml);
  } finally {
    if (inertBodyElement) {
      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
      while (parent.firstChild) {
        parent.firstChild.remove();
      }
    }
  }
}
function getTemplateContent(el) {
  return "content" in el && isTemplateElement(el) ? el.content : null;
}
function isTemplateElement(el) {
  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
}
const COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
const COMMENT_DELIMITER = /(<|>)/g;
const COMMENT_DELIMITER_ESCAPED = "\u200B$1\u200B";
function escapeCommentText(value) {
  return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
function createTextNode(renderer, value) {
  return renderer.createText(value);
}
function updateTextNode(renderer, rNode, value) {
  renderer.setValue(rNode, value);
}
function createCommentNode(renderer, value) {
  return renderer.createComment(escapeCommentText(value));
}
function createElementNode(renderer, name, namespace) {
  return renderer.createElement(name, namespace);
}
function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
  renderer.insertBefore(parent, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent, child) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(parent, "parent node must be defined");
  renderer.appendChild(parent, child);
}
function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
  if (beforeNode !== null) {
    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
  } else {
    nativeAppendChild(renderer, parent, child);
  }
}
function nativeRemoveNode(renderer, rNode, isHostElement, requireSynchronousElementRemoval) {
  renderer.removeChild(null, rNode, isHostElement, requireSynchronousElementRemoval);
}
function clearElementContents(rElement) {
  rElement.textContent = "";
}
function writeDirectStyle(renderer, element, newValue) {
  ngDevMode && (0, import_root_effect_scheduler.assertString)(newValue, "'newValue' should be a string");
  renderer.setAttribute(element, "style", newValue);
}
function writeDirectClass(renderer, element, newValue) {
  ngDevMode && (0, import_root_effect_scheduler.assertString)(newValue, "'newValue' should be a string");
  if (newValue === "") {
    renderer.removeAttribute(element, "class");
  } else {
    renderer.setAttribute(element, "class", newValue);
  }
}
function setupStaticAttributes(renderer, element, tNode) {
  const { mergedAttrs, classes, styles } = tNode;
  if (mergedAttrs !== null) {
    setUpAttributes(renderer, element, mergedAttrs);
  }
  if (classes !== null) {
    writeDirectClass(renderer, element, classes);
  }
  if (styles !== null) {
    writeDirectStyle(renderer, element, styles);
  }
}
function enforceIframeSecurity(iframe) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  iframe.src = "";
  iframe.srcdoc = trustedHTMLFromString("");
  nativeRemoveNode(lView[import_root_effect_scheduler.RENDERER], iframe);
}
var SecurityContext;
(function(SecurityContext2) {
  SecurityContext2[SecurityContext2["NONE"] = 0] = "NONE";
  SecurityContext2[SecurityContext2["HTML"] = 1] = "HTML";
  SecurityContext2[SecurityContext2["STYLE"] = 2] = "STYLE";
  SecurityContext2[SecurityContext2["SCRIPT"] = 3] = "SCRIPT";
  SecurityContext2[SecurityContext2["URL"] = 4] = "URL";
  SecurityContext2[SecurityContext2["RESOURCE_URL"] = 5] = "RESOURCE_URL";
})(SecurityContext || (SecurityContext = {}));
function \u0275\u0275sanitizeHtml(unsafeHtml) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeHtml,
    "HTML"
    /* BypassType.Html */
  )) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), (0, import_root_effect_scheduler.renderStringify)(unsafeHtml));
}
function \u0275\u0275sanitizeStyle(unsafeStyle) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeStyle,
    "Style"
    /* BypassType.Style */
  )) {
    return unwrapSafeValue(unsafeStyle);
  }
  return (0, import_root_effect_scheduler.renderStringify)(unsafeStyle);
}
function \u0275\u0275sanitizeUrl(unsafeUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeUrl,
    "URL"
    /* BypassType.Url */
  )) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl((0, import_root_effect_scheduler.renderStringify)(unsafeUrl));
}
function \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeResourceUrl,
    "ResourceURL"
    /* BypassType.ResourceUrl */
  )) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new import_root_effect_scheduler.RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${import_root_effect_scheduler.XSS_SECURITY_URL})`);
}
function \u0275\u0275sanitizeScript(unsafeScript) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeScript,
    "Script"
    /* BypassType.Script */
  )) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new import_root_effect_scheduler.RuntimeError(905, ngDevMode && "unsafe value used in a script context");
}
function \u0275\u0275trustConstantHtml(html) {
  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
  }
  return trustedHTMLFromString(html[0]);
}
function \u0275\u0275trustConstantResourceUrl(url) {
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
  }
  return trustedScriptURLFromString(url[0]);
}
const SRC_RESOURCE_TAGS = /* @__PURE__ */ new Set(["embed", "frame", "iframe", "media", "script"]);
const HREF_RESOURCE_TAGS = /* @__PURE__ */ new Set(["base", "link", "script"]);
function getUrlSanitizer(tag, prop) {
  const isResource = prop === "src" && SRC_RESOURCE_TAGS.has(tag) || prop === "href" && HREF_RESOURCE_TAGS.has(tag) || prop === "xlink:href" && tag === "script";
  return isResource ? \u0275\u0275sanitizeResourceUrl : \u0275\u0275sanitizeUrl;
}
function \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
    throw new import_root_effect_scheduler.RuntimeError(306, errorMessage);
  }
}
function validateAgainstEventAttributes(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
    throw new import_root_effect_scheduler.RuntimeError(306, errorMessage);
  }
}
function getSanitizer() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  return lView && lView[import_root_effect_scheduler.ENVIRONMENT].sanitizer;
}
const attributeName = /* @__PURE__ */ new Set(["attributename"]);
const SECURITY_SENSITIVE_ELEMENTS = {
  "iframe": /* @__PURE__ */ new Set([
    "sandbox",
    "allow",
    "allowfullscreen",
    "referrerpolicy",
    "csp",
    "fetchpriority"
  ]),
  "animate": attributeName,
  "set": attributeName,
  "animatemotion": attributeName,
  "animatetransform": attributeName
};
function \u0275\u0275validateAttribute(value, tagName, attributeName2) {
  var _a2;
  const lowerCaseTagName = tagName.toLowerCase();
  const lowerCaseAttrName = attributeName2.toLowerCase();
  if (!((_a2 = SECURITY_SENSITIVE_ELEMENTS[lowerCaseTagName]) == null ? void 0 : _a2.has(lowerCaseAttrName))) {
    return value;
  }
  const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
  if (tNode.type !== 2) {
    return value;
  }
  const lView = (0, import_root_effect_scheduler.getLView)();
  if (lowerCaseTagName === "iframe") {
    const element = (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
    enforceIframeSecurity(element);
  }
  const errorMessage = ngDevMode && `Angular has detected that the \`${attributeName2}\` was applied as a binding to the <${tagName}> element${getTemplateLocationDetails(lView)}. For security reasons, the \`${attributeName2}\` can be set on the <${tagName}> element as a static attribute only. 
To fix this, switch the \`${attributeName2}\` binding to a static attribute in a template or in host bindings section.`;
  throw new import_root_effect_scheduler.RuntimeError(-910, errorMessage);
}
const NG_REFLECT_ATTRS_FLAG_DEFAULT = false;
const NG_REFLECT_ATTRS_FLAG = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "NG_REFLECT_FLAG" : "", {
  providedIn: "root",
  factory: () => NG_REFLECT_ATTRS_FLAG_DEFAULT
});
function provideNgReflectAttributes() {
  const providers = typeof ngDevMode === "undefined" || ngDevMode ? [
    {
      provide: NG_REFLECT_ATTRS_FLAG,
      useValue: true
    }
  ] : [];
  return (0, import_root_effect_scheduler.makeEnvironmentProviders)(providers);
}
function normalizeDebugBindingName(name) {
  name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
  return `ng-reflect-${name}`;
}
const CAMEL_CASE_REGEXP = /([A-Z])/g;
function camelCaseToDashCase(input) {
  return input.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
}
function normalizeDebugBindingValue(value) {
  try {
    return value != null ? value.toString().slice(0, 30) : value;
  } catch (e) {
    return "[ERROR] Exception while trying to serialize the value";
  }
}
function \u0275\u0275resolveWindow(element) {
  return element.ownerDocument.defaultView;
}
function \u0275\u0275resolveDocument(element) {
  return element.ownerDocument;
}
function \u0275\u0275resolveBody(element) {
  return element.ownerDocument.body;
}
const INTERPOLATION_DELIMITER = `\uFFFD`;
function maybeUnwrapFn(value) {
  if (value instanceof Function) {
    return value();
  } else {
    return value;
  }
}
const VALUE_STRING_LENGTH_LIMIT = 200;
function assertStandaloneComponentType(type) {
  assertComponentDef(type);
  const componentDef = (0, import_root_effect_scheduler.getComponentDef)(type);
  if (!componentDef.standalone) {
    throw new import_root_effect_scheduler.RuntimeError(907, `The ${(0, import_root_effect_scheduler.stringifyForError)(type)} component is not marked as standalone, but Angular expects to have a standalone component here. Please make sure the ${(0, import_root_effect_scheduler.stringifyForError)(type)} component has the \`standalone: true\` flag in the decorator.`);
  }
}
function assertComponentDef(type) {
  if (!(0, import_root_effect_scheduler.getComponentDef)(type)) {
    throw new import_root_effect_scheduler.RuntimeError(906, `The ${(0, import_root_effect_scheduler.stringifyForError)(type)} is not an Angular component, make sure it has the \`@Component\` decorator.`);
  }
}
function throwMultipleComponentError(tNode, first, second) {
  throw new import_root_effect_scheduler.RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ${(0, import_root_effect_scheduler.stringifyForError)(first)} and ${(0, import_root_effect_scheduler.stringifyForError)(second)}`);
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {
  var _a2;
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = (_a2 = hostComponentDef == null ? void 0 : hostComponentDef.type) == null ? void 0 : _a2.name;
  const field = propName ? ` for '${propName}'` : "";
  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ""}`;
  if (creationMode) {
    msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
  }
  throw new import_root_effect_scheduler.RuntimeError(-100, msg);
}
function formatValue(value) {
  let strValue = String(value);
  try {
    if (Array.isArray(value) || strValue === "[object Object]") {
      strValue = JSON.stringify(value);
    }
  } catch (error) {
  }
  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + "\u2026" : strValue;
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
  let oldValue = prefix, newValue = prefix;
  for (let i = 0; i < chunks.length; i++) {
    const slotIdx = rootIndex + i;
    oldValue += `${lView[slotIdx]}${chunks[i]}`;
    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
  }
  return { propName, oldValue, newValue };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
  const tData = lView[import_root_effect_scheduler.TVIEW].data;
  const metadata = tData[bindingIndex];
  if (typeof metadata === "string") {
    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
    }
    return { propName: metadata, oldValue, newValue };
  }
  if (metadata === null) {
    let idx = bindingIndex - 1;
    while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
      idx--;
    }
    const meta = tData[idx];
    if (typeof meta === "string") {
      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
      if (matches && matches.length - 1 > bindingIndex - idx) {
        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
      }
    }
  }
  return { propName: void 0, oldValue, newValue };
}
function classIndexOf(className, classToSearch, startingIndex) {
  ngDevMode && (0, import_root_effect_scheduler.assertNotEqual)(classToSearch, "", 'can not look for "" string.');
  let end = className.length;
  while (true) {
    const foundIndex = className.indexOf(classToSearch, startingIndex);
    if (foundIndex === -1)
      return foundIndex;
    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
      const length = classToSearch.length;
      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
        return foundIndex;
      }
    }
    startingIndex = foundIndex + 1;
  }
}
const NG_TEMPLATE_SELECTOR = "ng-template";
function isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
  let i = 0;
  if (isProjectionMode) {
    for (; i < attrs.length && typeof attrs[i] === "string"; i += 2) {
      if (attrs[i] === "class" && classIndexOf(attrs[i + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {
        return true;
      }
    }
  } else if (isInlineTemplate(tNode)) {
    return false;
  }
  i = attrs.indexOf(1, i);
  if (i > -1) {
    let item;
    while (++i < attrs.length && typeof (item = attrs[i]) === "string") {
      if (item.toLowerCase() === cssClassToMatch) {
        return true;
      }
    }
  }
  return false;
}
function isInlineTemplate(tNode) {
  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
  return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(selector[0], "Selector should have a tag name");
  let mode = 4;
  const nodeAttrs = tNode.attrs;
  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;
  let skipToNextSelector = false;
  for (let i = 0; i < selector.length; i++) {
    const current = selector[i];
    if (typeof current === "number") {
      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
        return false;
      }
      if (skipToNextSelector && isPositive(current))
        continue;
      skipToNextSelector = false;
      mode = current | mode & 1;
      continue;
    }
    if (skipToNextSelector)
      continue;
    if (mode & 4) {
      mode = 2 | mode & 1;
      if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
      }
    } else if (mode & 8) {
      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
      }
    } else {
      const selectorAttrValue = selector[++i];
      const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
      if (attrIndexInNode === -1) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
        continue;
      }
      if (selectorAttrValue !== "") {
        let nodeAttrValue;
        if (attrIndexInNode > nameOnlyMarkerIdx) {
          nodeAttrValue = "";
        } else {
          ngDevMode && (0, import_root_effect_scheduler.assertNotEqual)(nodeAttrs[attrIndexInNode], 0, "We do not match directives on namespaced attributes");
          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
        }
        if (mode & 2 && selectorAttrValue !== nodeAttrValue) {
          if (isPositive(mode))
            return false;
          skipToNextSelector = true;
        }
      }
    }
  }
  return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
  return (mode & 1) === 0;
}
function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
  if (attrs === null)
    return -1;
  let i = 0;
  if (isProjectionMode || !isInlineTemplate2) {
    let bindingsMode = false;
    while (i < attrs.length) {
      const maybeAttrName = attrs[i];
      if (maybeAttrName === name) {
        return i;
      } else if (maybeAttrName === 3 || maybeAttrName === 6) {
        bindingsMode = true;
      } else if (maybeAttrName === 1 || maybeAttrName === 2) {
        let value = attrs[++i];
        while (typeof value === "string") {
          value = attrs[++i];
        }
        continue;
      } else if (maybeAttrName === 4) {
        break;
      } else if (maybeAttrName === 0) {
        i += 4;
        continue;
      }
      i += bindingsMode ? 1 : 2;
    }
    return -1;
  } else {
    return matchTemplateAttribute(attrs, name);
  }
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
  for (let i = 0; i < selector.length; i++) {
    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
      return true;
    }
  }
  return false;
}
function getProjectAsAttrValue(tNode) {
  const nodeAttrs = tNode.attrs;
  if (nodeAttrs != null) {
    const ngProjectAsAttrIdx = nodeAttrs.indexOf(
      5
      /* AttributeMarker.ProjectAs */
    );
    if ((ngProjectAsAttrIdx & 1) === 0) {
      return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
  }
  return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
  for (let i = 0; i < nodeAttrs.length; i++) {
    const nodeAttr = nodeAttrs[i];
    if (isNameOnlyAttributeMarker(nodeAttr)) {
      return i;
    }
  }
  return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name) {
  let i = attrs.indexOf(
    4
    /* AttributeMarker.Template */
  );
  if (i > -1) {
    i++;
    while (i < attrs.length) {
      const attr = attrs[i];
      if (typeof attr === "number")
        return -1;
      if (attr === name)
        return i;
      i++;
    }
  }
  return -1;
}
function isSelectorInSelectorList(selector, list) {
  selectorListLoop: for (let i = 0; i < list.length; i++) {
    const currentSelectorInList = list[i];
    if (selector.length !== currentSelectorInList.length) {
      continue;
    }
    for (let j = 0; j < selector.length; j++) {
      if (selector[j] !== currentSelectorInList[j]) {
        continue selectorListLoop;
      }
    }
    return true;
  }
  return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
  return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
}
function stringifyCSSSelector(selector) {
  let result = selector[0];
  let i = 1;
  let mode = 2;
  let currentChunk = "";
  let isNegativeMode = false;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode & 2) {
        const attrValue = selector[++i];
        currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
      } else if (mode & 8) {
        currentChunk += "." + valueOrMarker;
      } else if (mode & 4) {
        currentChunk += " " + valueOrMarker;
      }
    } else {
      if (currentChunk !== "" && !isPositive(valueOrMarker)) {
        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        currentChunk = "";
      }
      mode = valueOrMarker;
      isNegativeMode = isNegativeMode || !isPositive(mode);
    }
    i++;
  }
  if (currentChunk !== "") {
    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
  }
  return result;
}
function stringifyCSSSelectorList(selectorList) {
  return selectorList.map(stringifyCSSSelector).join(",");
}
function extractAttrsAndClassesFromSelector(selector) {
  const attrs = [];
  const classes = [];
  let i = 1;
  let mode = 2;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode === 2) {
        if (valueOrMarker !== "") {
          attrs.push(valueOrMarker, selector[++i]);
        }
      } else if (mode === 8) {
        classes.push(valueOrMarker);
      }
    } else {
      if (!isPositive(mode))
        break;
      mode = valueOrMarker;
    }
    i++;
  }
  if (classes.length) {
    attrs.push(1, ...classes);
  }
  return attrs;
}
const NO_CHANGE = typeof ngDevMode === "undefined" || ngDevMode ? { __brand__: "NO_CHANGE" } : {};
function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
  const bindingStartIndex = import_root_effect_scheduler.HEADER_OFFSET + decls;
  const initialViewLength = bindingStartIndex + vars;
  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
  const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
  const tView = blueprint[import_root_effect_scheduler.TVIEW] = {
    type,
    blueprint,
    template: templateFn,
    queries: null,
    viewQuery,
    declTNode,
    data: blueprint.slice().fill(null, bindingStartIndex),
    bindingStartIndex,
    expandoStartIndex: initialViewLength,
    hostBindingOpCodes: null,
    firstCreatePass: true,
    firstUpdatePass: true,
    staticViewQueries: false,
    staticContentQueries: false,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof directives === "function" ? directives() : directives,
    pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
    firstChild: null,
    schemas,
    consts,
    incompleteFirstPass: false,
    ssrId
  };
  if (ngDevMode) {
    Object.seal(tView);
  }
  return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
  const blueprint = [];
  for (let i = 0; i < initialViewLength; i++) {
    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
  }
  return blueprint;
}
function getOrCreateComponentTView(def) {
  const tView = def.tView;
  if (tView === null || tView.incompleteFirstPass) {
    const declTNode = null;
    return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
  }
  return tView;
}
function createLView(parentLView, tView, context, flags, host, tHostNode, environment, renderer, injector, embeddedViewInjector, hydrationInfo) {
  const lView = tView.blueprint.slice();
  lView[import_root_effect_scheduler.HOST] = host;
  lView[import_root_effect_scheduler.FLAGS] = flags | 4 | 128 | 8 | 64 | 1024;
  if (embeddedViewInjector !== null || parentLView && parentLView[import_root_effect_scheduler.FLAGS] & 2048) {
    lView[import_root_effect_scheduler.FLAGS] |= 2048;
  }
  (0, import_root_effect_scheduler.resetPreOrderHookFlags)(lView);
  ngDevMode && tView.declTNode && parentLView && (0, import_root_effect_scheduler.assertTNodeForLView)(tView.declTNode, parentLView);
  lView[import_root_effect_scheduler.PARENT] = lView[import_root_effect_scheduler.DECLARATION_VIEW] = parentLView;
  lView[import_root_effect_scheduler.CONTEXT] = context;
  lView[import_root_effect_scheduler.ENVIRONMENT] = environment || parentLView && parentLView[import_root_effect_scheduler.ENVIRONMENT];
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(lView[import_root_effect_scheduler.ENVIRONMENT], "LViewEnvironment is required");
  lView[import_root_effect_scheduler.RENDERER] = renderer || parentLView && parentLView[import_root_effect_scheduler.RENDERER];
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(lView[import_root_effect_scheduler.RENDERER], "Renderer is required");
  lView[import_root_effect_scheduler.INJECTOR$1] = injector || parentLView && parentLView[import_root_effect_scheduler.INJECTOR$1] || null;
  lView[import_root_effect_scheduler.T_HOST] = tHostNode;
  lView[import_root_effect_scheduler.ID] = getUniqueLViewId();
  lView[import_root_effect_scheduler.HYDRATION] = hydrationInfo;
  lView[import_root_effect_scheduler.EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
  lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW] : lView;
  return lView;
}
function createComponentLView(lView, hostTNode, def) {
  const native = (0, import_root_effect_scheduler.getNativeByTNode)(hostTNode, lView);
  const tView = getOrCreateComponentTView(def);
  const rendererFactory = lView[import_root_effect_scheduler.ENVIRONMENT].rendererFactory;
  const componentView = addToEndOfViewTree(lView, createLView(lView, tView, null, getInitialLViewFlagsFromDef(def), native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
  return lView[hostTNode.index] = componentView;
}
function getInitialLViewFlagsFromDef(def) {
  let flags = 16;
  if (def.signals) {
    flags = 4096;
  } else if (def.onPush) {
    flags = 64;
  }
  return flags;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
  if (numSlotsToAlloc === 0)
    return -1;
  if (ngDevMode) {
    (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
    (0, import_root_effect_scheduler.assertSame)(tView, lView[import_root_effect_scheduler.TVIEW], "`LView` must be associated with `TView`!");
    (0, import_root_effect_scheduler.assertEqual)(tView.data.length, lView.length, "Expecting LView to be same size as TView");
    (0, import_root_effect_scheduler.assertEqual)(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
    (0, import_root_effect_scheduler.assertFirstUpdatePass)(tView);
  }
  const allocIdx = lView.length;
  for (let i = 0; i < numSlotsToAlloc; i++) {
    lView.push(initialValue);
    tView.blueprint.push(initialValue);
    tView.data.push(null);
  }
  return allocIdx;
}
function addToEndOfViewTree(lView, lViewOrLContainer) {
  if (lView[import_root_effect_scheduler.CHILD_HEAD]) {
    lView[import_root_effect_scheduler.CHILD_TAIL][import_root_effect_scheduler.NEXT] = lViewOrLContainer;
  } else {
    lView[import_root_effect_scheduler.CHILD_HEAD] = lViewOrLContainer;
  }
  lView[import_root_effect_scheduler.CHILD_TAIL] = lViewOrLContainer;
  return lViewOrLContainer;
}
function \u0275\u0275advance(delta = 1) {
  ngDevMode && (0, import_root_effect_scheduler.assertGreaterThan)(delta, 0, "Can only advance forward");
  selectIndexInternal((0, import_root_effect_scheduler.getTView)(), (0, import_root_effect_scheduler.getLView)(), (0, import_root_effect_scheduler.getSelectedIndex)() + delta, !!ngDevMode && (0, import_root_effect_scheduler.isInCheckNoChangesMode)());
}
function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInDeclRange)(lView[import_root_effect_scheduler.TVIEW], index);
  if (!checkNoChangesMode) {
    const hooksInitPhaseCompleted = (lView[import_root_effect_scheduler.FLAGS] & 3) === 3;
    if (hooksInitPhaseCompleted) {
      const preOrderCheckHooks = tView.preOrderCheckHooks;
      if (preOrderCheckHooks !== null) {
        executeCheckHooks(lView, preOrderCheckHooks, index);
      }
    } else {
      const preOrderHooks = tView.preOrderHooks;
      if (preOrderHooks !== null) {
        executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
      }
    }
  }
  (0, import_root_effect_scheduler.setSelectedIndex)(index);
}
var InputFlags;
(function(InputFlags2) {
  InputFlags2[InputFlags2["None"] = 0] = "None";
  InputFlags2[InputFlags2["SignalBased"] = 1] = "SignalBased";
  InputFlags2[InputFlags2["HasDecoratorInputTransform"] = 2] = "HasDecoratorInputTransform";
})(InputFlags || (InputFlags = {}));
function writeToDirectiveInput(def, instance, publicName, value) {
  const prevConsumer = (0, import_signal.setActiveConsumer)(null);
  try {
    if (ngDevMode) {
      if (!def.inputs.hasOwnProperty(publicName)) {
        throw new Error(`ASSERTION ERROR: Directive ${def.type.name} does not have an input with a public name of "${publicName}"`);
      }
      if (instance instanceof NodeInjectorFactory) {
        throw new Error(`ASSERTION ERROR: Cannot write input to factory for type ${def.type.name}. Directive has not been created yet.`);
      }
    }
    const [privateName, flags, transform] = def.inputs[publicName];
    let inputSignalNode = null;
    if ((flags & InputFlags.SignalBased) !== 0) {
      const field = instance[privateName];
      inputSignalNode = field[import_signal.SIGNAL];
    }
    if (inputSignalNode !== null && inputSignalNode.transformFn !== void 0) {
      value = inputSignalNode.transformFn(value);
    } else if (transform !== null) {
      value = transform.call(instance, value);
    }
    if (def.setInput !== null) {
      def.setInput(instance, inputSignalNode, value, publicName, privateName);
    } else {
      applyValueToInputField(instance, inputSignalNode, privateName, value);
    }
  } finally {
    (0, import_signal.setActiveConsumer)(prevConsumer);
  }
}
var RendererStyleFlags2;
(function(RendererStyleFlags22) {
  RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
  RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
let _icuContainerIterate;
function icuContainerIterate(tIcuContainerNode, lView) {
  return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
  if (_icuContainerIterate === void 0) {
    _icuContainerIterate = loader();
  }
}
function parseCssTimeUnitsToMs(value) {
  if (!value)
    return 0;
  const multiplier = value.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
  return parseFloat(value) * multiplier;
}
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(",").map((part) => part.trim());
}
function getLongestComputedTransition(computedStyle) {
  const transitionedProperties = parseCssPropertyValue(computedStyle, "transition-property");
  const rawDurations = parseCssPropertyValue(computedStyle, "transition-duration");
  const rawDelays = parseCssPropertyValue(computedStyle, "transition-delay");
  const longest = { propertyName: "", duration: 0, animationName: void 0 };
  for (let i = 0; i < transitionedProperties.length; i++) {
    const duration = parseCssTimeUnitsToMs(rawDelays[i]) + parseCssTimeUnitsToMs(rawDurations[i]);
    if (duration > longest.duration) {
      longest.propertyName = transitionedProperties[i];
      longest.duration = duration;
    }
  }
  return longest;
}
function getLongestComputedAnimation(computedStyle) {
  const rawNames = parseCssPropertyValue(computedStyle, "animation-name");
  const rawDelays = parseCssPropertyValue(computedStyle, "animation-delay");
  const rawDurations = parseCssPropertyValue(computedStyle, "animation-duration");
  const longest = { animationName: "", propertyName: void 0, duration: 0 };
  for (let i = 0; i < rawNames.length; i++) {
    const duration = parseCssTimeUnitsToMs(rawDelays[i]) + parseCssTimeUnitsToMs(rawDurations[i]);
    if (duration > longest.duration) {
      longest.animationName = rawNames[i];
      longest.duration = duration;
    }
  }
  return longest;
}
function isShorterThanExistingAnimation(existing, longest) {
  return existing !== void 0 && existing.duration > longest.duration;
}
function longestExists(longest) {
  return (longest.animationName != void 0 || longest.propertyName != void 0) && longest.duration > 0;
}
function determineLongestAnimationFromComputedStyles(el, animationsMap) {
  const computedStyle = getComputedStyle(el);
  const longestAnimation = getLongestComputedAnimation(computedStyle);
  const longestTransition = getLongestComputedTransition(computedStyle);
  const longest = longestAnimation.duration > longestTransition.duration ? longestAnimation : longestTransition;
  if (isShorterThanExistingAnimation(animationsMap.get(el), longest))
    return;
  if (longestExists(longest)) {
    animationsMap.set(el, longest);
  }
}
function determineLongestAnimation(el, animationsMap, areAnimationSupported2) {
  if (!areAnimationSupported2)
    return;
  const animations = el.getAnimations();
  return animations.length === 0 ? (
    // fallback to computed styles if getAnimations is empty. This would happen if styles are
    // currently recalculating due to a reflow happening elsewhere.
    determineLongestAnimationFromComputedStyles(el, animationsMap)
  ) : determineLongestAnimationFromElementAnimations(el, animationsMap, animations);
}
function determineLongestAnimationFromElementAnimations(el, animationsMap, animations) {
  var _a2, _b2;
  let longest = {
    animationName: void 0,
    propertyName: void 0,
    duration: 0
  };
  for (const animation of animations) {
    const timing = (_a2 = animation.effect) == null ? void 0 : _a2.getTiming();
    const animDuration = typeof (timing == null ? void 0 : timing.duration) === "number" ? timing.duration : 0;
    let duration = ((_b2 = timing == null ? void 0 : timing.delay) != null ? _b2 : 0) + animDuration;
    let propertyName;
    let animationName;
    if (animation.animationName) {
      animationName = animation.animationName;
    } else {
      propertyName = animation.transitionProperty;
    }
    if (duration >= longest.duration) {
      longest = { animationName, propertyName, duration };
    }
  }
  if (isShorterThanExistingAnimation(animationsMap.get(el), longest))
    return;
  if (longestExists(longest)) {
    animationsMap.set(el, longest);
  }
}
const allLeavingAnimations = /* @__PURE__ */ new Set();
var TracingAction;
(function(TracingAction2) {
  TracingAction2[TracingAction2["CHANGE_DETECTION"] = 0] = "CHANGE_DETECTION";
  TracingAction2[TracingAction2["AFTER_NEXT_RENDER"] = 1] = "AFTER_NEXT_RENDER";
})(TracingAction || (TracingAction = {}));
const TracingService = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "TracingService" : "");
const markedFeatures = /* @__PURE__ */ new Set();
function performanceMarkFeature(feature) {
  var _a2;
  if (markedFeatures.has(feature)) {
    return;
  }
  markedFeatures.add(feature);
  (_a2 = performance == null ? void 0 : performance.mark) == null ? void 0 : _a2.call(performance, "mark_feature_usage", { detail: { feature } });
}
const SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;
class EventEmitter_ extends import_rxjs.Subject {
  constructor(isAsync = false) {
    var _a2, _b2;
    super();
    // tslint:disable-next-line:require-internal-with-underscore
    __publicField(this, "__isAsync");
    __publicField(this, "destroyRef");
    __publicField(this, "pendingTasks");
    this.__isAsync = isAsync;
    if ((0, import_root_effect_scheduler.isInInjectionContext)()) {
      this.destroyRef = (_a2 = (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.DestroyRef, { optional: true })) != null ? _a2 : void 0;
      this.pendingTasks = (_b2 = (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.PendingTasksInternal, { optional: true })) != null ? _b2 : void 0;
    }
  }
  emit(value) {
    const prevConsumer = (0, import_signal.setActiveConsumer)(null);
    try {
      super.next(value);
    } finally {
      (0, import_signal.setActiveConsumer)(prevConsumer);
    }
  }
  subscribe(observerOrNext, error, complete) {
    var _a2, _b2, _c2;
    let nextFn = observerOrNext;
    let errorFn = error || (() => null);
    let completeFn = complete;
    if (observerOrNext && typeof observerOrNext === "object") {
      const observer = observerOrNext;
      nextFn = (_a2 = observer.next) == null ? void 0 : _a2.bind(observer);
      errorFn = (_b2 = observer.error) == null ? void 0 : _b2.bind(observer);
      completeFn = (_c2 = observer.complete) == null ? void 0 : _c2.bind(observer);
    }
    if (this.__isAsync) {
      errorFn = this.wrapInTimeout(errorFn);
      if (nextFn) {
        nextFn = this.wrapInTimeout(nextFn);
      }
      if (completeFn) {
        completeFn = this.wrapInTimeout(completeFn);
      }
    }
    const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });
    if (observerOrNext instanceof import_rxjs.Subscription) {
      observerOrNext.add(sink);
    }
    return sink;
  }
  wrapInTimeout(fn) {
    return (value) => {
      var _a2;
      const taskId = (_a2 = this.pendingTasks) == null ? void 0 : _a2.add();
      setTimeout(() => {
        var _a3;
        try {
          fn(value);
        } finally {
          if (taskId !== void 0) {
            (_a3 = this.pendingTasks) == null ? void 0 : _a3.remove(taskId);
          }
        }
      });
    };
  }
}
const EventEmitter = EventEmitter_;
function scheduleCallbackWithRafRace(callback) {
  let timeoutId;
  let animationFrameId;
  function cleanup() {
    callback = import_root_effect_scheduler.noop;
    try {
      if (animationFrameId !== void 0 && typeof cancelAnimationFrame === "function") {
        cancelAnimationFrame(animationFrameId);
      }
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
      }
    } catch (e) {
    }
  }
  timeoutId = setTimeout(() => {
    callback();
    cleanup();
  });
  if (typeof requestAnimationFrame === "function") {
    animationFrameId = requestAnimationFrame(() => {
      callback();
      cleanup();
    });
  }
  return () => cleanup();
}
function scheduleCallbackWithMicrotask(callback) {
  queueMicrotask(() => callback());
  return () => {
    callback = import_root_effect_scheduler.noop;
  };
}
class AsyncStackTaggingZoneSpec {
  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
    __publicField(this, "createTask");
    // ZoneSpec implementation below.
    __publicField(this, "name");
    var _a2;
    this.name = "asyncStackTagging for " + namePrefix;
    this.createTask = (_a2 = consoleAsyncStackTaggingImpl == null ? void 0 : consoleAsyncStackTaggingImpl.createTask) != null ? _a2 : (() => null);
  }
  onScheduleTask(delegate, _current, target, task) {
    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
    return delegate.scheduleTask(target, task);
  }
  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
    let ret;
    if (task.consoleTask) {
      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
    } else {
      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
    }
    return ret;
  }
}
const isAngularZoneProperty = "isAngularZone";
const angularZoneInstanceIdProperty = isAngularZoneProperty + "_ID";
let ngZoneInstanceId = 0;
class NgZone {
  constructor(options) {
    __publicField(this, "hasPendingMacrotasks", false);
    __publicField(this, "hasPendingMicrotasks", false);
    /**
     * Whether there are no outstanding microtasks or macrotasks.
     */
    __publicField(this, "isStable", true);
    /**
     * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
     */
    __publicField(this, "onUnstable", new EventEmitter(false));
    /**
     * Notifies when there is no more microtasks enqueued in the current VM Turn.
     * This is a hint for Angular to do change detection, which may enqueue more microtasks.
     * For this reason this event can fire multiple times per VM Turn.
     */
    __publicField(this, "onMicrotaskEmpty", new EventEmitter(false));
    /**
     * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
     * implies we are about to relinquish VM turn.
     * This event gets called just once.
     */
    __publicField(this, "onStable", new EventEmitter(false));
    /**
     * Notifies that an error has been delivered.
     */
    __publicField(this, "onError", new EventEmitter(false));
    const { enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false, shouldCoalesceRunChangeDetection = false, scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT } = options;
    if (typeof Zone == "undefined") {
      throw new import_root_effect_scheduler.RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
    }
    Zone.assertZonePatched();
    const self = this;
    self._nesting = 0;
    self._outer = self._inner = Zone.current;
    if (ngDevMode) {
      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec("Angular"));
    }
    if (Zone["TaskTrackingZoneSpec"]) {
      self._inner = self._inner.fork(new Zone["TaskTrackingZoneSpec"]());
    }
    if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
      self._inner = self._inner.fork(Zone["longStackTraceZoneSpec"]);
    }
    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
    self.callbackScheduled = false;
    self.scheduleInRootZone = scheduleInRootZone;
    forkInnerZoneWithAngularBehavior(self);
  }
  /**
    This method checks whether the method call happens within an Angular Zone instance.
  */
  static isInAngularZone() {
    return typeof Zone !== "undefined" && Zone.current.get(isAngularZoneProperty) === true;
  }
  /**
    Assures that the method is called within the Angular Zone, otherwise throws an error.
  */
  static assertInAngularZone() {
    if (!NgZone.isInAngularZone()) {
      throw new import_root_effect_scheduler.RuntimeError(909, ngDevMode && "Expected to be in Angular Zone, but it is not!");
    }
  }
  /**
    Assures that the method is called outside of the Angular Zone, otherwise throws an error.
  */
  static assertNotInAngularZone() {
    if (NgZone.isInAngularZone()) {
      throw new import_root_effect_scheduler.RuntimeError(909, ngDevMode && "Expected to not be in Angular Zone, but it is!");
    }
  }
  /**
   * Executes the `fn` function synchronously within the Angular zone and returns value returned by
   * the function.
   *
   * Running functions via `run` allows you to reenter Angular zone from a task that was executed
   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * within the Angular zone.
   *
   * If a synchronous error happens it will be rethrown and not reported via `onError`.
   */
  run(fn, applyThis, applyArgs) {
    return this._inner.run(fn, applyThis, applyArgs);
  }
  /**
   * Executes the `fn` function synchronously within the Angular zone as a task and returns value
   * returned by the function.
   *
   * Running functions via `runTask` allows you to reenter Angular zone from a task that was executed
   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * within the Angular zone.
   *
   * If a synchronous error happens it will be rethrown and not reported via `onError`.
   */
  runTask(fn, applyThis, applyArgs, name) {
    const zone = this._inner;
    const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, import_root_effect_scheduler.noop, import_root_effect_scheduler.noop);
    try {
      return zone.runTask(task, applyThis, applyArgs);
    } finally {
      zone.cancelTask(task);
    }
  }
  /**
   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
   * rethrown.
   */
  runGuarded(fn, applyThis, applyArgs) {
    return this._inner.runGuarded(fn, applyThis, applyArgs);
  }
  /**
   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
   * the function.
   *
   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
   * work that
   * doesn't trigger Angular change-detection or is subject to Angular's error handling.
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * outside of the Angular zone.
   *
   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
   */
  runOutsideAngular(fn) {
    return this._outer.run(fn);
  }
}
const EMPTY_PAYLOAD = {};
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.callbackScheduled) {
    return;
  }
  zone.callbackScheduled = true;
  function scheduleCheckStable() {
    scheduleCallbackWithRafRace(() => {
      zone.callbackScheduled = false;
      updateMicroTaskStatus(zone);
      zone.isCheckStableRunning = true;
      checkStable(zone);
      zone.isCheckStableRunning = false;
    });
  }
  if (zone.scheduleInRootZone) {
    Zone.root.run(() => {
      scheduleCheckStable();
    });
  } else {
    zone._outer.run(() => {
      scheduleCheckStable();
    });
  }
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  const instanceId = ngZoneInstanceId++;
  zone._inner = zone._inner.fork({
    name: "angular",
    properties: {
      [isAngularZoneProperty]: true,
      [angularZoneInstanceIdProperty]: instanceId,
      [angularZoneInstanceIdProperty + instanceId]: true
    },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      if (shouldBeIgnoredByZone(applyArgs)) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection && // Do not delay change detection when the task is the scheduler's tick.
        // We need to synchronously trigger the stability logic so that the
        // zone-based scheduler can prevent a duplicate ApplicationRef.tick
        // by first checking if the scheduler tick is running. This does seem a bit roundabout,
        // but we _do_ still want to trigger all the correct events when we exit the zone.run
        // (`onMicrotaskEmpty` and `onStable` _should_ emit; developers can have code which
        // relies on these events happening after change detection runs).
        // Note: `zone.callbackScheduled` is already in delayChangeDetectionForEventsDelegate
        // but is added here as well to prevent reads of applyArgs when not necessary
        !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == "microTask") {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == "macroTask") {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error) => {
      delegate.handleError(target, error);
      zone.runOutsideAngular(() => zone.onError.emit(error));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
class NoopNgZone {
  constructor() {
    __publicField(this, "hasPendingMicrotasks", false);
    __publicField(this, "hasPendingMacrotasks", false);
    __publicField(this, "isStable", true);
    __publicField(this, "onUnstable", new EventEmitter());
    __publicField(this, "onMicrotaskEmpty", new EventEmitter());
    __publicField(this, "onStable", new EventEmitter());
    __publicField(this, "onError", new EventEmitter());
  }
  run(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runGuarded(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return fn();
  }
  runTask(fn, applyThis, applyArgs, name) {
    return fn.apply(applyThis, applyArgs);
  }
}
function shouldBeIgnoredByZone(applyArgs) {
  return hasApplyArgsData(applyArgs, "__ignore_ng_zone__");
}
function isSchedulerTick(applyArgs) {
  return hasApplyArgsData(applyArgs, "__scheduler_tick__");
}
function hasApplyArgsData(applyArgs, key) {
  var _a2, _b2;
  if (!Array.isArray(applyArgs)) {
    return false;
  }
  if (applyArgs.length !== 1) {
    return false;
  }
  return ((_b2 = (_a2 = applyArgs[0]) == null ? void 0 : _a2.data) == null ? void 0 : _b2[key]) === true;
}
function getNgZone(ngZoneToUse = "zone.js", options) {
  if (ngZoneToUse === "noop") {
    return new NoopNgZone();
  }
  if (ngZoneToUse === "zone.js") {
    return new NgZone(options);
  }
  return ngZoneToUse;
}
const _AfterRenderManager = class _AfterRenderManager {
  constructor() {
    __publicField(this, "impl", null);
  }
  execute() {
    var _a2;
    (_a2 = this.impl) == null ? void 0 : _a2.execute();
  }
};
/** @nocollapse */
__publicField(
  _AfterRenderManager,
  "\u0275prov",
  /** @pureOrBreakMyCode */
  /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({
    token: _AfterRenderManager,
    providedIn: "root",
    factory: () => new _AfterRenderManager()
  })
);
let AfterRenderManager = _AfterRenderManager;
const AFTER_RENDER_PHASES = /* @__PURE__ */ (() => [
  0,
  1,
  2,
  3
])();
const _AfterRenderImpl = class _AfterRenderImpl {
  constructor() {
    __publicField(this, "ngZone", (0, import_root_effect_scheduler.inject)(NgZone));
    __publicField(this, "scheduler", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.ChangeDetectionScheduler));
    __publicField(this, "errorHandler", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.ErrorHandler, { optional: true }));
    /** Current set of active sequences. */
    __publicField(this, "sequences", /* @__PURE__ */ new Set());
    /** Tracks registrations made during the current set of executions. */
    __publicField(this, "deferredRegistrations", /* @__PURE__ */ new Set());
    /** Whether the `AfterRenderManager` is currently executing hooks. */
    __publicField(this, "executing", false);
    (0, import_root_effect_scheduler.inject)(TracingService, { optional: true });
  }
  /**
   * Run the sequence of phases of hooks, once through. As a result of executing some hooks, more
   * might be scheduled.
   */
  execute() {
    var _a2;
    const hasSequencesToExecute = this.sequences.size > 0;
    if (hasSequencesToExecute) {
      profiler(
        16
        /* ProfilerEvent.AfterRenderHooksStart */
      );
    }
    this.executing = true;
    for (const phase of AFTER_RENDER_PHASES) {
      for (const sequence of this.sequences) {
        if (sequence.erroredOrDestroyed || !sequence.hooks[phase]) {
          continue;
        }
        try {
          sequence.pipelinedValue = this.ngZone.runOutsideAngular(() => this.maybeTrace(() => {
            const hookFn = sequence.hooks[phase];
            const value = hookFn(sequence.pipelinedValue);
            return value;
          }, sequence.snapshot));
        } catch (err) {
          sequence.erroredOrDestroyed = true;
          (_a2 = this.errorHandler) == null ? void 0 : _a2.handleError(err);
        }
      }
    }
    this.executing = false;
    for (const sequence of this.sequences) {
      sequence.afterRun();
      if (sequence.once) {
        this.sequences.delete(sequence);
        sequence.destroy();
      }
    }
    for (const sequence of this.deferredRegistrations) {
      this.sequences.add(sequence);
    }
    if (this.deferredRegistrations.size > 0) {
      this.scheduler.notify(
        7
        /* NotificationSource.RenderHook */
      );
    }
    this.deferredRegistrations.clear();
    if (hasSequencesToExecute) {
      profiler(
        17
        /* ProfilerEvent.AfterRenderHooksEnd */
      );
    }
  }
  register(sequence) {
    var _a2, _b2;
    const { view } = sequence;
    if (view !== void 0) {
      ((_b2 = view[_a2 = import_root_effect_scheduler.AFTER_RENDER_SEQUENCES_TO_ADD]) != null ? _b2 : view[_a2] = []).push(sequence);
      (0, import_root_effect_scheduler.markAncestorsForTraversal)(view);
      view[import_root_effect_scheduler.FLAGS] |= 8192;
    } else if (!this.executing) {
      this.addSequence(sequence);
    } else {
      this.deferredRegistrations.add(sequence);
    }
  }
  addSequence(sequence) {
    this.sequences.add(sequence);
    this.scheduler.notify(
      7
      /* NotificationSource.RenderHook */
    );
  }
  unregister(sequence) {
    if (this.executing && this.sequences.has(sequence)) {
      sequence.erroredOrDestroyed = true;
      sequence.pipelinedValue = void 0;
      sequence.once = true;
    } else {
      this.sequences.delete(sequence);
      this.deferredRegistrations.delete(sequence);
    }
  }
  maybeTrace(fn, snapshot) {
    return snapshot ? snapshot.run(TracingAction.AFTER_NEXT_RENDER, fn) : fn();
  }
};
/** @nocollapse */
__publicField(
  _AfterRenderImpl,
  "\u0275prov",
  /** @pureOrBreakMyCode */
  /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({
    token: _AfterRenderImpl,
    providedIn: "root",
    factory: () => new _AfterRenderImpl()
  })
);
let AfterRenderImpl = _AfterRenderImpl;
class AfterRenderSequence {
  constructor(impl, hooks, view, once, destroyRef, snapshot = null) {
    __publicField(this, "impl");
    __publicField(this, "hooks");
    __publicField(this, "view");
    __publicField(this, "once");
    __publicField(this, "snapshot");
    /**
     * Whether this sequence errored or was destroyed during this execution, and hooks should no
     * longer run for it.
     */
    __publicField(this, "erroredOrDestroyed", false);
    /**
     * The value returned by the last hook execution (if any), ready to be pipelined into the next
     * one.
     */
    __publicField(this, "pipelinedValue");
    __publicField(this, "unregisterOnDestroy");
    this.impl = impl;
    this.hooks = hooks;
    this.view = view;
    this.once = once;
    this.snapshot = snapshot;
    this.unregisterOnDestroy = destroyRef == null ? void 0 : destroyRef.onDestroy(() => this.destroy());
  }
  afterRun() {
    var _a2;
    this.erroredOrDestroyed = false;
    this.pipelinedValue = void 0;
    (_a2 = this.snapshot) == null ? void 0 : _a2.dispose();
    this.snapshot = null;
  }
  destroy() {
    var _a2, _b2;
    this.impl.unregister(this);
    (_a2 = this.unregisterOnDestroy) == null ? void 0 : _a2.call(this);
    const scheduled = (_b2 = this.view) == null ? void 0 : _b2[import_root_effect_scheduler.AFTER_RENDER_SEQUENCES_TO_ADD];
    if (scheduled) {
      this.view[import_root_effect_scheduler.AFTER_RENDER_SEQUENCES_TO_ADD] = scheduled.filter((s) => s !== this);
    }
  }
}
function afterEveryRender(callbackOrSpec, options) {
  var _a2;
  ngDevMode && (0, import_root_effect_scheduler.assertNotInReactiveContext)(afterEveryRender, "Call `afterEveryRender` outside of a reactive context. For example, schedule the render callback inside the component constructor`.");
  if (ngDevMode && !(options == null ? void 0 : options.injector)) {
    (0, import_root_effect_scheduler.assertInInjectionContext)(afterEveryRender);
  }
  const injector = (_a2 = options == null ? void 0 : options.injector) != null ? _a2 : (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.Injector);
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature("NgAfterRender");
  return afterEveryRenderImpl(
    callbackOrSpec,
    injector,
    options,
    /* once */
    false
  );
}
function afterNextRender(callbackOrSpec, options) {
  var _a2;
  if (ngDevMode && !(options == null ? void 0 : options.injector)) {
    (0, import_root_effect_scheduler.assertInInjectionContext)(afterNextRender);
  }
  const injector = (_a2 = options == null ? void 0 : options.injector) != null ? _a2 : (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.Injector);
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature("NgAfterNextRender");
  return afterEveryRenderImpl(
    callbackOrSpec,
    injector,
    options,
    /* once */
    true
  );
}
function getHooks(callbackOrSpec) {
  if (callbackOrSpec instanceof Function) {
    return [
      void 0,
      void 0,
      /* MixedReadWrite */
      callbackOrSpec,
      void 0
    ];
  } else {
    return [
      callbackOrSpec.earlyRead,
      callbackOrSpec.write,
      callbackOrSpec.mixedReadWrite,
      callbackOrSpec.read
    ];
  }
}
function afterEveryRenderImpl(callbackOrSpec, injector, options, once) {
  var _a2;
  const manager = injector.get(AfterRenderManager);
  (_a2 = manager.impl) != null ? _a2 : manager.impl = injector.get(AfterRenderImpl);
  const tracing = injector.get(TracingService, null, { optional: true });
  const destroyRef = (options == null ? void 0 : options.manualCleanup) !== true ? injector.get(import_root_effect_scheduler.DestroyRef) : null;
  const viewContext = injector.get(import_root_effect_scheduler.ViewContext, null, { optional: true });
  const sequence = new AfterRenderSequence(manager.impl, getHooks(callbackOrSpec), viewContext == null ? void 0 : viewContext.view, once, destroyRef, tracing == null ? void 0 : tracing.snapshot(null));
  manager.impl.register(sequence);
  return sequence;
}
const NOOP_AFTER_RENDER_REF = {
  destroy() {
  }
};
const ANIMATION_QUEUE = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "AnimationQueue" : "", {
  providedIn: "root",
  factory: () => {
    return {
      queue: /* @__PURE__ */ new Set(),
      isScheduled: false,
      scheduler: null
    };
  }
});
function addToAnimationQueue(injector, animationFns, animationData) {
  var _a2, _b2;
  const animationQueue = injector.get(ANIMATION_QUEUE);
  if (Array.isArray(animationFns)) {
    for (const animateFn of animationFns) {
      animationQueue.queue.add(animateFn);
      (_a2 = animationData == null ? void 0 : animationData.detachedLeaveAnimationFns) == null ? void 0 : _a2.push(animateFn);
    }
  } else {
    animationQueue.queue.add(animationFns);
    (_b2 = animationData == null ? void 0 : animationData.detachedLeaveAnimationFns) == null ? void 0 : _b2.push(animationFns);
  }
  animationQueue.scheduler && animationQueue.scheduler(injector);
}
function removeFromAnimationQueue(injector, animationData) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  if (animationData.detachedLeaveAnimationFns) {
    for (const animationFn of animationData.detachedLeaveAnimationFns) {
      animationQueue.queue.delete(animationFn);
    }
    animationData.detachedLeaveAnimationFns = void 0;
  }
}
function scheduleAnimationQueue(injector) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  if (!animationQueue.isScheduled) {
    afterNextRender(() => {
      animationQueue.isScheduled = false;
      for (let animateFn of animationQueue.queue) {
        animateFn();
      }
      animationQueue.queue.clear();
    }, { injector });
    animationQueue.isScheduled = true;
  }
}
function initializeAnimationQueueScheduler(injector) {
  const animationQueue = injector.get(ANIMATION_QUEUE);
  animationQueue.scheduler = scheduleAnimationQueue;
  animationQueue.scheduler(injector);
}
function queueEnterAnimations(injector, enterAnimations) {
  for (const [_, nodeAnimations] of enterAnimations) {
    addToAnimationQueue(injector, nodeAnimations.animateFns);
  }
}
function maybeQueueEnterAnimation(parentLView, parent, tNode, injector) {
  var _a2;
  const enterAnimations = (_a2 = parentLView == null ? void 0 : parentLView[import_root_effect_scheduler.ANIMATIONS]) == null ? void 0 : _a2.enter;
  if (parent !== null && enterAnimations && enterAnimations.has(tNode.index)) {
    queueEnterAnimations(injector, enterAnimations);
  }
}
function applyToElementOrContainer(action, renderer, injector, parent, lNodeToHandle, tNode, beforeNode, parentLView) {
  if (lNodeToHandle != null) {
    let lContainer;
    let isComponent2 = false;
    if ((0, import_root_effect_scheduler.isLContainer)(lNodeToHandle)) {
      lContainer = lNodeToHandle;
    } else if ((0, import_root_effect_scheduler.isLView)(lNodeToHandle)) {
      isComponent2 = true;
      ngDevMode && (0, import_root_effect_scheduler.assertDefined)(lNodeToHandle[import_root_effect_scheduler.HOST], "HOST must be defined for a component LView");
      lNodeToHandle = lNodeToHandle[import_root_effect_scheduler.HOST];
    }
    const rNode = (0, import_root_effect_scheduler.unwrapRNode)(lNodeToHandle);
    if (action === 0 && parent !== null) {
      maybeQueueEnterAnimation(parentLView, parent, tNode, injector);
      if (beforeNode == null) {
        nativeAppendChild(renderer, parent, rNode);
      } else {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      }
    } else if (action === 1 && parent !== null) {
      maybeQueueEnterAnimation(parentLView, parent, tNode, injector);
      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
    } else if (action === 2) {
      runLeaveAnimationsWithCallback(parentLView, tNode, injector, (nodeHasLeaveAnimations) => {
        nativeRemoveNode(renderer, rNode, isComponent2, nodeHasLeaveAnimations);
      });
    } else if (action === 3) {
      runLeaveAnimationsWithCallback(parentLView, tNode, injector, () => {
        renderer.destroyNode(rNode);
      });
    }
    if (lContainer != null) {
      applyContainer(renderer, action, injector, lContainer, tNode, parent, beforeNode);
    }
  }
}
function removeViewFromDOM(tView, lView) {
  detachViewFromDOM(tView, lView);
  lView[import_root_effect_scheduler.HOST] = null;
  lView[import_root_effect_scheduler.T_HOST] = null;
}
function addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
  lView[import_root_effect_scheduler.HOST] = parentNativeNode;
  lView[import_root_effect_scheduler.T_HOST] = parentTNode;
  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
}
function detachViewFromDOM(tView, lView) {
  var _a2;
  (_a2 = lView[import_root_effect_scheduler.ENVIRONMENT].changeDetectionScheduler) == null ? void 0 : _a2.notify(9);
  applyView(tView, lView, lView[import_root_effect_scheduler.RENDERER], 2, null, null);
}
function destroyViewTree(rootView) {
  let lViewOrLContainer = rootView[import_root_effect_scheduler.CHILD_HEAD];
  if (!lViewOrLContainer) {
    return cleanUpView(rootView[import_root_effect_scheduler.TVIEW], rootView);
  }
  while (lViewOrLContainer) {
    let next = null;
    if ((0, import_root_effect_scheduler.isLView)(lViewOrLContainer)) {
      next = lViewOrLContainer[import_root_effect_scheduler.CHILD_HEAD];
    } else {
      ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(lViewOrLContainer);
      const firstView = lViewOrLContainer[import_root_effect_scheduler.CONTAINER_HEADER_OFFSET];
      if (firstView)
        next = firstView;
    }
    if (!next) {
      while (lViewOrLContainer && !lViewOrLContainer[import_root_effect_scheduler.NEXT] && lViewOrLContainer !== rootView) {
        if ((0, import_root_effect_scheduler.isLView)(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[import_root_effect_scheduler.TVIEW], lViewOrLContainer);
        }
        lViewOrLContainer = lViewOrLContainer[import_root_effect_scheduler.PARENT];
      }
      if (lViewOrLContainer === null)
        lViewOrLContainer = rootView;
      if ((0, import_root_effect_scheduler.isLView)(lViewOrLContainer)) {
        cleanUpView(lViewOrLContainer[import_root_effect_scheduler.TVIEW], lViewOrLContainer);
      }
      next = lViewOrLContainer && lViewOrLContainer[import_root_effect_scheduler.NEXT];
    }
    lViewOrLContainer = next;
  }
}
function detachMovedView(declarationContainer, lView) {
  ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(declarationContainer);
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(declarationContainer[import_root_effect_scheduler.MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
  const movedViews = declarationContainer[import_root_effect_scheduler.MOVED_VIEWS];
  const declarationViewIndex = movedViews.indexOf(lView);
  movedViews.splice(declarationViewIndex, 1);
}
function destroyLView(tView, lView) {
  if ((0, import_root_effect_scheduler.isDestroyed)(lView)) {
    return;
  }
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  if (renderer.destroyNode) {
    applyView(tView, lView, renderer, 3, null, null);
  }
  destroyViewTree(lView);
}
function cleanUpView(tView, lView) {
  if ((0, import_root_effect_scheduler.isDestroyed)(lView)) {
    return;
  }
  const prevConsumer = (0, import_signal.setActiveConsumer)(null);
  try {
    lView[import_root_effect_scheduler.FLAGS] &= ~128;
    lView[import_root_effect_scheduler.FLAGS] |= 256;
    lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER] && (0, import_signal.consumerDestroy)(lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER]);
    executeOnDestroys(tView, lView);
    processCleanups(tView, lView);
    if (lView[import_root_effect_scheduler.TVIEW].type === 1) {
      lView[import_root_effect_scheduler.RENDERER].destroy();
    }
    const declarationContainer = lView[import_root_effect_scheduler.DECLARATION_LCONTAINER];
    if (declarationContainer !== null && (0, import_root_effect_scheduler.isLContainer)(lView[import_root_effect_scheduler.PARENT])) {
      if (declarationContainer !== lView[import_root_effect_scheduler.PARENT]) {
        detachMovedView(declarationContainer, lView);
      }
      const lQueries = lView[import_root_effect_scheduler.QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(tView);
      }
    }
    unregisterLView(lView);
  } finally {
    (0, import_signal.setActiveConsumer)(prevConsumer);
  }
}
function runLeaveAnimationsWithCallback(lView, tNode, injector, callback) {
  const animations = lView == null ? void 0 : lView[import_root_effect_scheduler.ANIMATIONS];
  if (animations == null || animations.leave == void 0 || !animations.leave.has(tNode.index))
    return callback(false);
  if (lView)
    allLeavingAnimations.add(lView);
  addToAnimationQueue(injector, () => {
    if (animations.leave && animations.leave.has(tNode.index)) {
      const leaveAnimationMap = animations.leave;
      const leaveAnimations = leaveAnimationMap.get(tNode.index);
      const runningAnimations = [];
      if (leaveAnimations) {
        for (let index = 0; index < leaveAnimations.animateFns.length; index++) {
          const animationFn = leaveAnimations.animateFns[index];
          const { promise } = animationFn();
          runningAnimations.push(promise);
        }
        animations.detachedLeaveAnimationFns = void 0;
      }
      animations.running = Promise.allSettled(runningAnimations);
      runAfterLeaveAnimations(lView, callback);
    } else {
      if (lView)
        allLeavingAnimations.delete(lView);
      callback(false);
    }
  }, animations);
}
function runAfterLeaveAnimations(lView, callback) {
  var _a2;
  const runningAnimations = (_a2 = lView[import_root_effect_scheduler.ANIMATIONS]) == null ? void 0 : _a2.running;
  if (runningAnimations) {
    runningAnimations.then(() => {
      lView[import_root_effect_scheduler.ANIMATIONS].running = void 0;
      allLeavingAnimations.delete(lView);
      callback(true);
    });
    return;
  }
  callback(false);
}
function processCleanups(tView, lView) {
  ngDevMode && (0, import_root_effect_scheduler.assertNotReactive)(processCleanups.name);
  const tCleanup = tView.cleanup;
  const lCleanup = lView[import_root_effect_scheduler.CLEANUP];
  if (tCleanup !== null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      if (typeof tCleanup[i] === "string") {
        const targetIdx = tCleanup[i + 3];
        ngDevMode && (0, import_root_effect_scheduler.assertNumber)(targetIdx, "cleanup target must be a number");
        if (targetIdx >= 0) {
          lCleanup[targetIdx]();
        } else {
          lCleanup[-targetIdx].unsubscribe();
        }
        i += 2;
      } else {
        const context = lCleanup[tCleanup[i + 1]];
        tCleanup[i].call(context);
      }
    }
  }
  if (lCleanup !== null) {
    lView[import_root_effect_scheduler.CLEANUP] = null;
  }
  const destroyHooks = lView[import_root_effect_scheduler.ON_DESTROY_HOOKS];
  if (destroyHooks !== null) {
    lView[import_root_effect_scheduler.ON_DESTROY_HOOKS] = null;
    for (let i = 0; i < destroyHooks.length; i++) {
      const destroyHooksFn = destroyHooks[i];
      ngDevMode && (0, import_root_effect_scheduler.assertFunction)(destroyHooksFn, "Expecting destroy hook to be a function.");
      destroyHooksFn();
    }
  }
  const effects = lView[import_root_effect_scheduler.EFFECTS];
  if (effects !== null) {
    lView[import_root_effect_scheduler.EFFECTS] = null;
    for (const effect of effects) {
      effect.destroy();
    }
  }
}
function executeOnDestroys(tView, lView) {
  ngDevMode && (0, import_root_effect_scheduler.assertNotReactive)(executeOnDestroys.name);
  let destroyHooks;
  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
    for (let i = 0; i < destroyHooks.length; i += 2) {
      const context = lView[destroyHooks[i]];
      if (!(context instanceof NodeInjectorFactory)) {
        const toCall = destroyHooks[i + 1];
        if (Array.isArray(toCall)) {
          for (let j = 0; j < toCall.length; j += 2) {
            const callContext = context[toCall[j]];
            const hook = toCall[j + 1];
            profiler(4, callContext, hook);
            try {
              hook.call(callContext);
            } finally {
              profiler(5, callContext, hook);
            }
          }
        } else {
          profiler(4, context, toCall);
          try {
            toCall.call(context);
          } finally {
            profiler(5, context, toCall);
          }
        }
      }
    }
  }
}
function getParentRElement(tView, tNode, lView) {
  return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
  let parentTNode = tNode;
  while (parentTNode !== null && parentTNode.type & (8 | 32 | 128)) {
    tNode = parentTNode;
    parentTNode = tNode.parent;
  }
  if (parentTNode === null) {
    return lView[import_root_effect_scheduler.HOST];
  } else {
    ngDevMode && assertTNodeType(
      parentTNode,
      3 | 4
      /* TNodeType.Container */
    );
    if ((0, import_root_effect_scheduler.isComponentHost)(parentTNode)) {
      ngDevMode && (0, import_root_effect_scheduler.assertTNodeForLView)(parentTNode, lView);
      const { encapsulation } = tView.data[parentTNode.directiveStart + parentTNode.componentOffset];
      if (encapsulation === ViewEncapsulation.None || encapsulation === ViewEncapsulation.Emulated) {
        return null;
      }
    }
    return (0, import_root_effect_scheduler.getNativeByTNode)(parentTNode, lView);
  }
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
  if (parentTNode.type & (8 | 32)) {
    return (0, import_root_effect_scheduler.getNativeByTNode)(parentTNode, lView);
  }
  return null;
}
let _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
let _processI18nInsertBefore;
function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
  _processI18nInsertBefore = processI18nInsertBefore2;
}
function appendChild(tView, lView, childRNode, childTNode) {
  const parentRNode = getParentRElement(tView, childTNode, lView);
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  const parentTNode = childTNode.parent || lView[import_root_effect_scheduler.T_HOST];
  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
  if (parentRNode != null) {
    if (Array.isArray(childRNode)) {
      for (let i = 0; i < childRNode.length; i++) {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
      }
    } else {
      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
  }
  _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
  if (tNode !== null) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 32 | 16 | 128
      /* TNodeType.LetDeclaration */
    );
    const tNodeType = tNode.type;
    if (tNodeType & 3) {
      return (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
    } else if (tNodeType & 4) {
      return getBeforeNodeForView(-1, lView[tNode.index]);
    } else if (tNodeType & 8) {
      const elIcuContainerChild = tNode.child;
      if (elIcuContainerChild !== null) {
        return getFirstNativeNode(lView, elIcuContainerChild);
      } else {
        const rNodeOrLContainer = lView[tNode.index];
        if ((0, import_root_effect_scheduler.isLContainer)(rNodeOrLContainer)) {
          return getBeforeNodeForView(-1, rNodeOrLContainer);
        } else {
          return (0, import_root_effect_scheduler.unwrapRNode)(rNodeOrLContainer);
        }
      }
    } else if (tNodeType & 128) {
      return getFirstNativeNode(lView, tNode.next);
    } else if (tNodeType & 32) {
      let nextRNode = icuContainerIterate(tNode, lView);
      let rNode = nextRNode();
      return rNode || (0, import_root_effect_scheduler.unwrapRNode)(lView[tNode.index]);
    } else {
      const projectionNodes = getProjectionNodes(lView, tNode);
      if (projectionNodes !== null) {
        if (Array.isArray(projectionNodes)) {
          return projectionNodes[0];
        }
        const parentView = (0, import_root_effect_scheduler.getLViewParent)(lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW]);
        ngDevMode && (0, import_root_effect_scheduler.assertParentView)(parentView);
        return getFirstNativeNode(parentView, projectionNodes);
      } else {
        return getFirstNativeNode(lView, tNode.next);
      }
    }
  }
  return null;
}
function getProjectionNodes(lView, tNode) {
  if (tNode !== null) {
    const componentView = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[import_root_effect_scheduler.T_HOST];
    const slotIdx = tNode.projection;
    ngDevMode && (0, import_root_effect_scheduler.assertProjectionSlots)(lView);
    return componentHost.projection[slotIdx];
  }
  return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
  const nextViewIndex = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
  if (nextViewIndex < lContainer.length) {
    const lView = lContainer[nextViewIndex];
    const firstTNodeOfView = lView[import_root_effect_scheduler.TVIEW].firstChild;
    if (firstTNodeOfView !== null) {
      return getFirstNativeNode(lView, firstTNodeOfView);
    }
  }
  return lContainer[import_root_effect_scheduler.NATIVE];
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
  while (tNode != null) {
    ngDevMode && (0, import_root_effect_scheduler.assertTNodeForLView)(tNode, lView);
    const injector = lView[import_root_effect_scheduler.INJECTOR$1];
    if (tNode.type === 128) {
      tNode = tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const rawSlotValue = lView[tNode.index];
    const tNodeType = tNode.type;
    if (isProjection) {
      if (action === 0) {
        rawSlotValue && attachPatchData((0, import_root_effect_scheduler.unwrapRNode)(rawSlotValue), lView);
        tNode.flags |= 2;
      }
    }
    if (!isDetachedByI18n(tNode)) {
      if (tNodeType & 8) {
        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
        applyToElementOrContainer(action, renderer, injector, parentRElement, rawSlotValue, tNode, beforeNode, lView);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          applyToElementOrContainer(action, renderer, injector, parentRElement, rNode, tNode, beforeNode, lView);
        }
        applyToElementOrContainer(action, renderer, injector, parentRElement, rawSlotValue, tNode, beforeNode, lView);
      } else if (tNodeType & 16) {
        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
      } else {
        ngDevMode && assertTNodeType(
          tNode,
          3 | 4
          /* TNodeType.Container */
        );
        applyToElementOrContainer(action, renderer, injector, parentRElement, rawSlotValue, tNode, beforeNode, lView);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
  const parentTNode = tProjectionNode.parent || lView[import_root_effect_scheduler.T_HOST];
  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
  const componentLView = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW];
  const componentNode = componentLView[import_root_effect_scheduler.T_HOST];
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(typeof tProjectionNode.projection, "number", "expecting projection index");
  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
  if (Array.isArray(nodeToProjectOrRNodes)) {
    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
      const rNode = nodeToProjectOrRNodes[i];
      applyToElementOrContainer(action, renderer, lView[import_root_effect_scheduler.INJECTOR$1], parentRElement, rNode, tProjectionNode, beforeNode, lView);
    }
  } else {
    let nodeToProject = nodeToProjectOrRNodes;
    const projectedComponentLView = componentLView[import_root_effect_scheduler.PARENT];
    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {
      nodeToProject.flags |= 128;
    }
    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
  }
}
function applyContainer(renderer, action, injector, lContainer, tNode, parentRElement, beforeNode) {
  ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(lContainer);
  const anchor = lContainer[import_root_effect_scheduler.NATIVE];
  const native = (0, import_root_effect_scheduler.unwrapRNode)(lContainer);
  if (anchor !== native) {
    applyToElementOrContainer(action, renderer, injector, parentRElement, anchor, tNode, beforeNode);
  }
  for (let i = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lView = lContainer[i];
    applyView(lView[import_root_effect_scheduler.TVIEW], lView, renderer, action, parentRElement, anchor);
  }
}
function applyStyling(renderer, isClassBased, rNode, prop, value) {
  if (isClassBased) {
    if (!value) {
      renderer.removeClass(rNode, prop);
    } else {
      renderer.addClass(rNode, prop);
    }
  } else {
    let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value == null) {
      renderer.removeStyle(rNode, prop, flags);
    } else {
      const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
      if (isImportant) {
        value = value.slice(0, -10);
        flags |= RendererStyleFlags2.Important;
      }
      renderer.setStyle(rNode, prop, value, flags);
    }
  }
}
function executeTemplate(tView, lView, templateFn, rf, context) {
  const prevSelectedIndex = (0, import_root_effect_scheduler.getSelectedIndex)();
  const isUpdatePhase = rf & 2;
  try {
    (0, import_root_effect_scheduler.setSelectedIndex)(-1);
    if (isUpdatePhase && lView.length > import_root_effect_scheduler.HEADER_OFFSET) {
      selectIndexInternal(tView, lView, import_root_effect_scheduler.HEADER_OFFSET, !!ngDevMode && (0, import_root_effect_scheduler.isInCheckNoChangesMode)());
    }
    const preHookType = isUpdatePhase ? 2 : 0;
    profiler(preHookType, context, templateFn);
    templateFn(rf, context);
  } finally {
    (0, import_root_effect_scheduler.setSelectedIndex)(prevSelectedIndex);
    const postHookType = isUpdatePhase ? 3 : 1;
    profiler(postHookType, context, templateFn);
  }
}
function createDirectivesInstances(tView, lView, tNode) {
  instantiateAllDirectives(tView, lView, tNode);
  if ((tNode.flags & 64) === 64) {
    invokeDirectivesHostBindings(tView, lView, tNode);
  }
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = import_root_effect_scheduler.getNativeByTNode) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    let localIndex = tNode.index + 1;
    for (let i = 0; i < localNames.length; i += 2) {
      const index = localNames[i + 1];
      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
      viewData[localIndex++] = value;
    }
  }
}
function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation.ShadowDom;
  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
  applyRootElementTransform(rootElement);
  return rootElement;
}
function applyRootElementTransform(rootElement) {
  _applyRootElementTransformImpl(rootElement);
}
let _applyRootElementTransformImpl = () => null;
function applyRootElementTransformImpl(rootElement) {
  if (hasSkipHydrationAttrOnRElement(rootElement)) {
    clearElementContents(rootElement);
  } else {
    processTextNodeMarkersBeforeHydration(rootElement);
  }
}
function enableApplyRootElementTransformImpl() {
  _applyRootElementTransformImpl = applyRootElementTransformImpl;
}
function mapPropName(name) {
  if (name === "class")
    return "className";
  if (name === "for")
    return "htmlFor";
  if (name === "formaction")
    return "formAction";
  if (name === "innerHtml")
    return "innerHTML";
  if (name === "readonly")
    return "readOnly";
  if (name === "tabindex")
    return "tabIndex";
  return name;
}
function setPropertyAndInputs(tNode, lView, propName, value, renderer, sanitizer) {
  ngDevMode && (0, import_root_effect_scheduler.assertNotSame)(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const hasSetInput = setAllInputsForProperty(tNode, tView, lView, propName, value);
  if (hasSetInput) {
    (0, import_root_effect_scheduler.isComponentHost)(tNode) && markDirtyIfOnPush(lView, tNode.index);
    ngDevMode && setNgReflectProperties(lView, tView, tNode, propName, value);
    return;
  }
  if (tNode.type & 3) {
    propName = mapPropName(propName);
  }
  setDomProperty(tNode, lView, propName, value, renderer, sanitizer);
}
function setDomProperty(tNode, lView, propName, value, renderer, sanitizer) {
  if (tNode.type & 3) {
    const element = (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
    if (ngDevMode) {
      validateAgainstEventProperties(propName);
      if (!isPropertyValid(element, propName, tNode.value, lView[import_root_effect_scheduler.TVIEW].schemas)) {
        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
      }
    }
    value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
    renderer.setProperty(element, propName, value);
  } else if (tNode.type & 12) {
    if (ngDevMode && !matchingSchemas(lView[import_root_effect_scheduler.TVIEW].schemas, tNode.value)) {
      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
  }
}
function markDirtyIfOnPush(lView, viewIndex) {
  ngDevMode && (0, import_root_effect_scheduler.assertLView)(lView);
  const childComponentLView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(viewIndex, lView);
  if (!(childComponentLView[import_root_effect_scheduler.FLAGS] & 16)) {
    childComponentLView[import_root_effect_scheduler.FLAGS] |= 64;
  }
}
function setNgReflectProperty(lView, tNode, attrName, value) {
  const environment = lView[import_root_effect_scheduler.ENVIRONMENT];
  if (!environment.ngReflect) {
    return;
  }
  const element = (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  attrName = normalizeDebugBindingName(attrName);
  const debugValue = normalizeDebugBindingValue(value);
  if (tNode.type & 3) {
    if (value == null) {
      renderer.removeAttribute(element, attrName);
    } else {
      renderer.setAttribute(element, attrName, debugValue);
    }
  } else {
    const textContent = escapeCommentText(`bindings=${JSON.stringify({ [attrName]: debugValue }, null, 2)}`);
    renderer.setValue(element, textContent);
  }
}
function setNgReflectProperties(lView, tView, tNode, publicName, value) {
  var _a2, _b2;
  const environment = lView[import_root_effect_scheduler.ENVIRONMENT];
  if (!environment.ngReflect || !(tNode.type & (3 | 4))) {
    return;
  }
  const inputConfig = (_a2 = tNode.inputs) == null ? void 0 : _a2[publicName];
  const hostInputConfig = (_b2 = tNode.hostDirectiveInputs) == null ? void 0 : _b2[publicName];
  if (hostInputConfig) {
    for (let i = 0; i < hostInputConfig.length; i += 2) {
      const index = hostInputConfig[i];
      const publicName2 = hostInputConfig[i + 1];
      const def = tView.data[index];
      setNgReflectProperty(lView, tNode, def.inputs[publicName2][0], value);
    }
  }
  if (inputConfig) {
    for (const index of inputConfig) {
      const def = tView.data[index];
      setNgReflectProperty(lView, tNode, def.inputs[publicName][0], value);
    }
  }
}
function instantiateAllDirectives(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  if ((0, import_root_effect_scheduler.isComponentHost)(tNode)) {
    ngDevMode && assertTNodeType(
      tNode,
      3
      /* TNodeType.AnyRNode */
    );
    createComponentLView(lView, tNode, tView.data[start + tNode.componentOffset]);
  }
  if (!tView.firstCreatePass) {
    getOrCreateNodeInjectorForNode(tNode, lView);
  }
  const initialInputs = tNode.initialInputs;
  for (let i = start; i < end; i++) {
    const def = tView.data[i];
    const directive = getNodeInjectable(lView, tView, i, tNode);
    attachPatchData(directive, lView);
    if (initialInputs !== null) {
      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
    }
    if ((0, import_root_effect_scheduler.isComponentDef)(def)) {
      const componentView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(tNode.index, lView);
      componentView[import_root_effect_scheduler.CONTEXT] = getNodeInjectable(lView, tView, i, tNode);
    }
  }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const elementIndex = tNode.index;
  const currentDirectiveIndex = (0, import_root_effect_scheduler.getCurrentDirectiveIndex)();
  try {
    (0, import_root_effect_scheduler.setSelectedIndex)(elementIndex);
    for (let dirIndex = start; dirIndex < end; dirIndex++) {
      const def = tView.data[dirIndex];
      const directive = lView[dirIndex];
      (0, import_root_effect_scheduler.setCurrentDirectiveIndex)(dirIndex);
      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
        invokeHostBindingsInCreationMode(def, directive);
      }
    }
  } finally {
    (0, import_root_effect_scheduler.setSelectedIndex)(-1);
    (0, import_root_effect_scheduler.setCurrentDirectiveIndex)(currentDirectiveIndex);
  }
}
function invokeHostBindingsInCreationMode(def, directive) {
  if (def.hostBindings !== null) {
    def.hostBindings(1, directive);
  }
}
function findDirectiveDefMatches(tView, tNode) {
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  const registry = tView.directiveRegistry;
  let matches = null;
  if (registry) {
    for (let i = 0; i < registry.length; i++) {
      const def = registry[i];
      if (isNodeMatchingSelectorList(
        tNode,
        def.selectors,
        /* isProjectionMode */
        false
      )) {
        matches != null ? matches : matches = [];
        if ((0, import_root_effect_scheduler.isComponentDef)(def)) {
          if (ngDevMode) {
            assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${(0, import_root_effect_scheduler.stringify)(def.type)} component.`);
            if (matches.length && (0, import_root_effect_scheduler.isComponentDef)(matches[0])) {
              throwMultipleComponentError(tNode, matches.find(import_root_effect_scheduler.isComponentDef).type, def.type);
            }
          }
          matches.unshift(def);
        } else {
          matches.push(def);
        }
      }
    }
  }
  return matches;
}
function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
  if (ngDevMode) {
    (0, import_root_effect_scheduler.assertNotSame)(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    validateAgainstEventAttributes(name);
    assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
  }
  const element = (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
  setElementAttribute(lView[import_root_effect_scheduler.RENDERER], element, namespace, tNode.value, name, value, sanitizer);
}
function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
  if (value == null) {
    renderer.removeAttribute(element, name, namespace);
  } else {
    const strValue = sanitizer == null ? (0, import_root_effect_scheduler.renderStringify)(value) : sanitizer(value, tagName || "", name);
    renderer.setAttribute(element, name, strValue, namespace);
  }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
  const initialInputs = initialInputData[directiveIndex];
  if (initialInputs !== null) {
    for (let i = 0; i < initialInputs.length; i += 2) {
      const lookupName = initialInputs[i];
      const value = initialInputs[i + 1];
      writeToDirectiveInput(def, instance, lookupName, value);
      if (ngDevMode) {
        setNgReflectProperty(lView, tNode, def.inputs[lookupName][0], value);
      }
    }
  }
}
function elementLikeStartShared(tNode, lView, index, name, locateOrCreateNativeNode) {
  const adjustedIndex = import_root_effect_scheduler.HEADER_OFFSET + index;
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const native = locateOrCreateNativeNode(tView, lView, tNode, name, index);
  lView[adjustedIndex] = native;
  (0, import_root_effect_scheduler.setCurrentTNode)(tNode, true);
  const isElement = tNode.type === 2;
  if (isElement) {
    setupStaticAttributes(lView[import_root_effect_scheduler.RENDERER], native, tNode);
    if ((0, import_root_effect_scheduler.getElementDepthCount)() === 0 || (0, import_root_effect_scheduler.isDirectiveHost)(tNode)) {
      attachPatchData(native, lView);
    }
    (0, import_root_effect_scheduler.increaseElementDepthCount)();
  } else {
    attachPatchData(native, lView);
  }
  if ((0, import_root_effect_scheduler.wasLastNodeCreated)() && (!isElement || !isDetachedByI18n(tNode))) {
    appendChild(tView, lView, native, tNode);
  }
  return tNode;
}
function elementLikeEndShared(tNode) {
  let currentTNode = tNode;
  if ((0, import_root_effect_scheduler.isCurrentTNodeParent)()) {
    (0, import_root_effect_scheduler.setCurrentTNodeAsNotParent)();
  } else {
    ngDevMode && (0, import_root_effect_scheduler.assertHasParent)((0, import_root_effect_scheduler.getCurrentTNode)());
    currentTNode = currentTNode.parent;
    (0, import_root_effect_scheduler.setCurrentTNode)(currentTNode, false);
  }
  return currentTNode;
}
function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
  var _a2, _b2;
  if (tData[bindingIndex] === null) {
    if (!((_a2 = tNode.inputs) == null ? void 0 : _a2[propertyName]) && !((_b2 = tNode.hostDirectiveInputs) == null ? void 0 : _b2[propertyName])) {
      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
      propBindingIdxs.push(bindingIndex);
      let bindingMetadata = propertyName;
      if (interpolationParts.length > 0) {
        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
      }
      tData[bindingIndex] = bindingMetadata;
    }
  }
}
function loadComponentRenderer(currentDef, tNode, lView) {
  if (currentDef === null || (0, import_root_effect_scheduler.isComponentDef)(currentDef)) {
    lView = (0, import_root_effect_scheduler.unwrapLView)(lView[tNode.index]);
  }
  return lView[import_root_effect_scheduler.RENDERER];
}
function handleUncaughtError(lView, error) {
  const injector = lView[import_root_effect_scheduler.INJECTOR$1];
  if (!injector) {
    return;
  }
  let errorHandler;
  try {
    errorHandler = injector.get(import_root_effect_scheduler.INTERNAL_APPLICATION_ERROR_HANDLER, null);
  } catch (e) {
    errorHandler = null;
  }
  errorHandler == null ? void 0 : errorHandler(error);
}
function setAllInputsForProperty(tNode, tView, lView, publicName, value) {
  var _a2, _b2;
  const inputs = (_a2 = tNode.inputs) == null ? void 0 : _a2[publicName];
  const hostDirectiveInputs = (_b2 = tNode.hostDirectiveInputs) == null ? void 0 : _b2[publicName];
  let hasMatch = false;
  if (hostDirectiveInputs) {
    for (let i = 0; i < hostDirectiveInputs.length; i += 2) {
      const index = hostDirectiveInputs[i];
      ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, index);
      const publicName2 = hostDirectiveInputs[i + 1];
      const def = tView.data[index];
      writeToDirectiveInput(def, lView[index], publicName2, value);
      hasMatch = true;
    }
  }
  if (inputs) {
    for (const index of inputs) {
      ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, index);
      const instance = lView[index];
      const def = tView.data[index];
      writeToDirectiveInput(def, instance, publicName, value);
      hasMatch = true;
    }
  }
  return hasMatch;
}
function setDirectiveInput(tNode, tView, lView, target, publicName, value) {
  var _a2, _b2;
  let hostIndex = null;
  let hostDirectivesStart = null;
  let hostDirectivesEnd = null;
  let hasSet = false;
  if (ngDevMode && !((_a2 = tNode.directiveToIndex) == null ? void 0 : _a2.has(target.type))) {
    throw new Error(`Node does not have a directive with type ${target.type.name}`);
  }
  const data = tNode.directiveToIndex.get(target.type);
  if (typeof data === "number") {
    hostIndex = data;
  } else {
    [hostIndex, hostDirectivesStart, hostDirectivesEnd] = data;
  }
  if (hostDirectivesStart !== null && hostDirectivesEnd !== null && ((_b2 = tNode.hostDirectiveInputs) == null ? void 0 : _b2.hasOwnProperty(publicName))) {
    const hostDirectiveInputs = tNode.hostDirectiveInputs[publicName];
    for (let i = 0; i < hostDirectiveInputs.length; i += 2) {
      const index = hostDirectiveInputs[i];
      if (index >= hostDirectivesStart && index <= hostDirectivesEnd) {
        ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, index);
        const def = tView.data[index];
        const hostDirectivePublicName = hostDirectiveInputs[i + 1];
        writeToDirectiveInput(def, lView[index], hostDirectivePublicName, value);
        hasSet = true;
      } else if (index > hostDirectivesEnd) {
        break;
      }
    }
  }
  if (hostIndex !== null && target.inputs.hasOwnProperty(publicName)) {
    ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, hostIndex);
    writeToDirectiveInput(target, lView[hostIndex], publicName, value);
    hasSet = true;
  }
  return hasSet;
}
function renderComponent(hostLView, componentHostIdx) {
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)((0, import_root_effect_scheduler.isCreationMode)(hostLView), true, "Should be run in creation mode");
  const componentView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(componentHostIdx, hostLView);
  const componentTView = componentView[import_root_effect_scheduler.TVIEW];
  syncViewWithBlueprint(componentTView, componentView);
  const hostRNode = componentView[import_root_effect_scheduler.HOST];
  if (hostRNode !== null && componentView[import_root_effect_scheduler.HYDRATION] === null) {
    componentView[import_root_effect_scheduler.HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[import_root_effect_scheduler.INJECTOR$1]);
  }
  profiler(
    18
    /* ProfilerEvent.ComponentStart */
  );
  renderView(componentTView, componentView, componentView[import_root_effect_scheduler.CONTEXT]);
  profiler(19, componentView[import_root_effect_scheduler.CONTEXT]);
}
function syncViewWithBlueprint(tView, lView) {
  for (let i = lView.length; i < tView.blueprint.length; i++) {
    lView.push(tView.blueprint[i]);
  }
}
function renderView(tView, lView, context) {
  var _a2;
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)((0, import_root_effect_scheduler.isCreationMode)(lView), true, "Should be run in creation mode");
  ngDevMode && (0, import_root_effect_scheduler.assertNotReactive)(renderView.name);
  (0, import_root_effect_scheduler.enterView)(lView);
  try {
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(1, viewQuery, context);
    }
    const templateFn = tView.template;
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 1, context);
    }
    if (tView.firstCreatePass) {
      tView.firstCreatePass = false;
    }
    (_a2 = lView[import_root_effect_scheduler.QUERIES]) == null ? void 0 : _a2.finishViewCreation(tView);
    if (tView.staticContentQueries) {
      refreshContentQueries(tView, lView);
    }
    if (tView.staticViewQueries) {
      executeViewQueryFn(2, tView.viewQuery, context);
    }
    const components = tView.components;
    if (components !== null) {
      renderChildComponents(lView, components);
    }
  } catch (error) {
    if (tView.firstCreatePass) {
      tView.incompleteFirstPass = true;
      tView.firstCreatePass = false;
    }
    throw error;
  } finally {
    lView[import_root_effect_scheduler.FLAGS] &= ~4;
    (0, import_root_effect_scheduler.leaveView)();
  }
}
function renderChildComponents(hostLView, components) {
  for (let i = 0; i < components.length; i++) {
    renderComponent(hostLView, components[i]);
  }
}
function createAndRenderEmbeddedLView(declarationLView, templateTNode, context, options) {
  var _a2, _b2, _c2;
  const prevConsumer = (0, import_signal.setActiveConsumer)(null);
  try {
    const embeddedTView = templateTNode.tView;
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(embeddedTView, "TView must be defined for a template node.");
    ngDevMode && (0, import_root_effect_scheduler.assertTNodeForLView)(templateTNode, declarationLView);
    const isSignalView = declarationLView[import_root_effect_scheduler.FLAGS] & 4096;
    const viewFlags = isSignalView ? 4096 : 16;
    const embeddedLView = createLView(declarationLView, embeddedTView, context, viewFlags, null, templateTNode, null, null, (_a2 = options == null ? void 0 : options.injector) != null ? _a2 : null, (_b2 = options == null ? void 0 : options.embeddedViewInjector) != null ? _b2 : null, (_c2 = options == null ? void 0 : options.dehydratedView) != null ? _c2 : null);
    const declarationLContainer = declarationLView[templateTNode.index];
    ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(declarationLContainer);
    embeddedLView[import_root_effect_scheduler.DECLARATION_LCONTAINER] = declarationLContainer;
    const declarationViewLQueries = declarationLView[import_root_effect_scheduler.QUERIES];
    if (declarationViewLQueries !== null) {
      embeddedLView[import_root_effect_scheduler.QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
    }
    renderView(embeddedTView, embeddedLView, context);
    return embeddedLView;
  } finally {
    (0, import_signal.setActiveConsumer)(prevConsumer);
  }
}
function shouldAddViewToDom(tNode, dehydratedView) {
  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);
}
const USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT = false;
const UseExhaustiveCheckNoChanges = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "exhaustive checkNoChanges" : "");
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
  while (tNode !== null) {
    if (tNode.type === 128) {
      tNode = isProjection ? tNode.projectionNext : tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const lNode = lView[tNode.index];
    if (lNode !== null) {
      result.push((0, import_root_effect_scheduler.unwrapRNode)(lNode));
    }
    if ((0, import_root_effect_scheduler.isLContainer)(lNode)) {
      collectNativeNodesInLContainer(lNode, result);
    }
    const tNodeType = tNode.type;
    if (tNodeType & 8) {
      collectNativeNodes(tView, lView, tNode.child, result);
    } else if (tNodeType & 32) {
      const nextRNode = icuContainerIterate(tNode, lView);
      let rNode;
      while (rNode = nextRNode()) {
        result.push(rNode);
      }
    } else if (tNodeType & 16) {
      const nodesInSlot = getProjectionNodes(lView, tNode);
      if (Array.isArray(nodesInSlot)) {
        result.push(...nodesInSlot);
      } else {
        const parentView = (0, import_root_effect_scheduler.getLViewParent)(lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW]);
        ngDevMode && (0, import_root_effect_scheduler.assertParentView)(parentView);
        collectNativeNodes(parentView[import_root_effect_scheduler.TVIEW], parentView, nodesInSlot, result, true);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
  return result;
}
function collectNativeNodesInLContainer(lContainer, result) {
  for (let i = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lViewInAContainer = lContainer[i];
    const lViewFirstChildTNode = lViewInAContainer[import_root_effect_scheduler.TVIEW].firstChild;
    if (lViewFirstChildTNode !== null) {
      collectNativeNodes(lViewInAContainer[import_root_effect_scheduler.TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
    }
  }
  if (lContainer[import_root_effect_scheduler.NATIVE] !== lContainer[import_root_effect_scheduler.HOST]) {
    result.push(lContainer[import_root_effect_scheduler.NATIVE]);
  }
}
function addAfterRenderSequencesForView(lView) {
  if (lView[import_root_effect_scheduler.AFTER_RENDER_SEQUENCES_TO_ADD] !== null) {
    for (const sequence of lView[import_root_effect_scheduler.AFTER_RENDER_SEQUENCES_TO_ADD]) {
      sequence.impl.addSequence(sequence);
    }
    lView[import_root_effect_scheduler.AFTER_RENDER_SEQUENCES_TO_ADD].length = 0;
  }
}
let freeConsumers = [];
function getOrBorrowReactiveLViewConsumer(lView) {
  var _a2;
  return (_a2 = lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER]) != null ? _a2 : borrowReactiveLViewConsumer(lView);
}
function borrowReactiveLViewConsumer(lView) {
  var _a2;
  const consumer = (_a2 = freeConsumers.pop()) != null ? _a2 : Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function maybeReturnReactiveLViewConsumer(consumer) {
  if (consumer.lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER] === consumer) {
    return;
  }
  consumer.lView = null;
  freeConsumers.push(consumer);
}
const REACTIVE_LVIEW_CONSUMER_NODE = __spreadProps(__spreadValues({}, import_signal.REACTIVE_NODE), {
  consumerIsAlwaysLive: true,
  kind: "template",
  consumerMarkedDirty: (node) => {
    (0, import_root_effect_scheduler.markAncestorsForTraversal)(node.lView);
  },
  consumerOnSignalRead() {
    this.lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER] = this;
  }
});
function getOrCreateTemporaryConsumer(lView) {
  var _a2;
  const consumer = (_a2 = lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER]) != null ? _a2 : Object.create(TEMPORARY_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
const TEMPORARY_CONSUMER_NODE = __spreadProps(__spreadValues({}, import_signal.REACTIVE_NODE), {
  consumerIsAlwaysLive: true,
  kind: "template",
  consumerMarkedDirty: (node) => {
    let parent = (0, import_root_effect_scheduler.getLViewParent)(node.lView);
    while (parent && !viewShouldHaveReactiveConsumer(parent[import_root_effect_scheduler.TVIEW])) {
      parent = (0, import_root_effect_scheduler.getLViewParent)(parent);
    }
    if (!parent) {
      return;
    }
    (0, import_root_effect_scheduler.markViewForRefresh)(parent);
  },
  consumerOnSignalRead() {
    this.lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER] = this;
  }
});
function viewShouldHaveReactiveConsumer(tView) {
  return tView.type !== 2;
}
function isReactiveLViewConsumer(node) {
  return node.kind === "template";
}
function runEffectsInView(view) {
  if (view[import_root_effect_scheduler.EFFECTS] === null) {
    return;
  }
  let tryFlushEffects = true;
  while (tryFlushEffects) {
    let foundDirtyEffect = false;
    for (const effect of view[import_root_effect_scheduler.EFFECTS]) {
      if (!effect.dirty) {
        continue;
      }
      foundDirtyEffect = true;
      if (effect.zone === null || Zone.current === effect.zone) {
        effect.run();
      } else {
        effect.zone.run(() => effect.run());
      }
    }
    tryFlushEffects = foundDirtyEffect && !!(view[import_root_effect_scheduler.FLAGS] & 8192);
  }
}
const MAXIMUM_REFRESH_RERUNS$1 = 100;
function detectChangesInternal(lView, mode = 0) {
  var _a2, _b2;
  const environment = lView[import_root_effect_scheduler.ENVIRONMENT];
  const rendererFactory = environment.rendererFactory;
  const checkNoChangesMode = !!ngDevMode && (0, import_root_effect_scheduler.isInCheckNoChangesMode)();
  if (!checkNoChangesMode) {
    (_a2 = rendererFactory.begin) == null ? void 0 : _a2.call(rendererFactory);
  }
  try {
    detectChangesInViewWhileDirty(lView, mode);
  } finally {
    if (!checkNoChangesMode) {
      (_b2 = rendererFactory.end) == null ? void 0 : _b2.call(rendererFactory);
    }
  }
}
function detectChangesInViewWhileDirty(lView, mode) {
  const lastIsRefreshingViewsValue = (0, import_root_effect_scheduler.isRefreshingViews)();
  try {
    (0, import_root_effect_scheduler.setIsRefreshingViews)(true);
    detectChangesInView(lView, mode);
    if (ngDevMode && (0, import_root_effect_scheduler.isExhaustiveCheckNoChanges)()) {
      return;
    }
    let retries = 0;
    while ((0, import_root_effect_scheduler.requiresRefreshOrTraversal)(lView)) {
      if (retries === MAXIMUM_REFRESH_RERUNS$1) {
        throw new import_root_effect_scheduler.RuntimeError(103, ngDevMode && "Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.");
      }
      retries++;
      detectChangesInView(
        lView,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  } finally {
    (0, import_root_effect_scheduler.setIsRefreshingViews)(lastIsRefreshingViewsValue);
  }
}
function checkNoChangesInternal(lView, exhaustive) {
  (0, import_root_effect_scheduler.setIsInCheckNoChangesMode)(exhaustive ? import_root_effect_scheduler.CheckNoChangesMode.Exhaustive : import_root_effect_scheduler.CheckNoChangesMode.OnlyDirtyViews);
  try {
    detectChangesInternal(lView);
  } finally {
    (0, import_root_effect_scheduler.setIsInCheckNoChangesMode)(import_root_effect_scheduler.CheckNoChangesMode.Off);
  }
}
function refreshView(tView, lView, templateFn, context) {
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)((0, import_root_effect_scheduler.isCreationMode)(lView), false, "Should be run in update mode");
  if ((0, import_root_effect_scheduler.isDestroyed)(lView))
    return;
  const flags = lView[import_root_effect_scheduler.FLAGS];
  const isInCheckNoChangesPass = ngDevMode && (0, import_root_effect_scheduler.isInCheckNoChangesMode)();
  const isInExhaustiveCheckNoChangesPass = ngDevMode && (0, import_root_effect_scheduler.isExhaustiveCheckNoChanges)();
  (0, import_root_effect_scheduler.enterView)(lView);
  let returnConsumerToPool = true;
  let prevConsumer = null;
  let currentConsumer = null;
  if (!isInCheckNoChangesPass) {
    if (viewShouldHaveReactiveConsumer(tView)) {
      currentConsumer = getOrBorrowReactiveLViewConsumer(lView);
      prevConsumer = (0, import_signal.consumerBeforeComputation)(currentConsumer);
    } else if ((0, import_signal.getActiveConsumer)() === null) {
      returnConsumerToPool = false;
      currentConsumer = getOrCreateTemporaryConsumer(lView);
      prevConsumer = (0, import_signal.consumerBeforeComputation)(currentConsumer);
    } else if (lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER]) {
      (0, import_signal.consumerDestroy)(lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER]);
      lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER] = null;
    }
  }
  try {
    (0, import_root_effect_scheduler.resetPreOrderHookFlags)(lView);
    (0, import_root_effect_scheduler.setBindingIndex)(tView.bindingStartIndex);
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 2, context);
    }
    const hooksInitPhaseCompleted = (flags & 3) === 3;
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, null);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
        }
        incrementInitPhaseFlags(
          lView,
          0
          /* InitPhaseState.OnInitHooksToBeRun */
        );
      }
    }
    if (!isInExhaustiveCheckNoChangesPass) {
      markTransplantedViewsForRefresh(lView);
    }
    runEffectsInView(lView);
    detectChangesInEmbeddedViews(
      lView,
      0
      /* ChangeDetectionMode.Global */
    );
    if (tView.contentQueries !== null) {
      refreshContentQueries(tView, lView);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const contentCheckHooks = tView.contentCheckHooks;
        if (contentCheckHooks !== null) {
          executeCheckHooks(lView, contentCheckHooks);
        }
      } else {
        const contentHooks = tView.contentHooks;
        if (contentHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            contentHooks,
            1
            /* InitPhaseState.AfterContentInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          1
          /* InitPhaseState.AfterContentInitHooksToBeRun */
        );
      }
    }
    processHostBindingOpCodes(tView, lView);
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        0
        /* ChangeDetectionMode.Global */
      );
    }
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(2, viewQuery, context);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const viewCheckHooks = tView.viewCheckHooks;
        if (viewCheckHooks !== null) {
          executeCheckHooks(lView, viewCheckHooks);
        }
      } else {
        const viewHooks = tView.viewHooks;
        if (viewHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            viewHooks,
            2
            /* InitPhaseState.AfterViewInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          2
          /* InitPhaseState.AfterViewInitHooksToBeRun */
        );
      }
    }
    if (tView.firstUpdatePass === true) {
      tView.firstUpdatePass = false;
    }
    if (lView[import_root_effect_scheduler.EFFECTS_TO_SCHEDULE]) {
      for (const notifyEffect of lView[import_root_effect_scheduler.EFFECTS_TO_SCHEDULE]) {
        notifyEffect();
      }
      lView[import_root_effect_scheduler.EFFECTS_TO_SCHEDULE] = null;
    }
    if (!isInCheckNoChangesPass) {
      addAfterRenderSequencesForView(lView);
      lView[import_root_effect_scheduler.FLAGS] &= ~(64 | 8);
    }
  } catch (e) {
    if (!isInCheckNoChangesPass) {
      (0, import_root_effect_scheduler.markAncestorsForTraversal)(lView);
    }
    throw e;
  } finally {
    if (currentConsumer !== null) {
      (0, import_signal.consumerAfterComputation)(currentConsumer, prevConsumer);
      if (returnConsumerToPool) {
        maybeReturnReactiveLViewConsumer(currentConsumer);
      }
    }
    (0, import_root_effect_scheduler.leaveView)();
  }
}
function detectChangesInEmbeddedViews(lView, mode) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const embeddedLView = lContainer[i];
      detectChangesInViewIfAttached(embeddedLView, mode);
    }
  }
}
function markTransplantedViewsForRefresh(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    if (!(lContainer[import_root_effect_scheduler.FLAGS] & 2))
      continue;
    const movedViews = lContainer[import_root_effect_scheduler.MOVED_VIEWS];
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
    for (let i = 0; i < movedViews.length; i++) {
      const movedLView = movedViews[i];
      (0, import_root_effect_scheduler.markViewForRefresh)(movedLView);
    }
  }
}
function detectChangesInComponent(hostLView, componentHostIdx, mode) {
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)((0, import_root_effect_scheduler.isCreationMode)(hostLView), false, "Should be run in update mode");
  profiler(
    18
    /* ProfilerEvent.ComponentStart */
  );
  const componentView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(componentHostIdx, hostLView);
  detectChangesInViewIfAttached(componentView, mode);
  profiler(19, componentView[import_root_effect_scheduler.CONTEXT]);
}
function detectChangesInViewIfAttached(lView, mode) {
  if (!(0, import_root_effect_scheduler.viewAttachedToChangeDetector)(lView)) {
    return;
  }
  detectChangesInView(lView, mode);
}
function detectChangesInView(lView, mode) {
  const isInCheckNoChangesPass = ngDevMode && (0, import_root_effect_scheduler.isInCheckNoChangesMode)();
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const flags = lView[import_root_effect_scheduler.FLAGS];
  const consumer = lView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER];
  let shouldRefreshView = !!(mode === 0 && flags & 16);
  shouldRefreshView || (shouldRefreshView = !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass));
  shouldRefreshView || (shouldRefreshView = !!(flags & 1024));
  shouldRefreshView || (shouldRefreshView = !!((consumer == null ? void 0 : consumer.dirty) && (0, import_signal.consumerPollProducersForChange)(consumer)));
  shouldRefreshView || (shouldRefreshView = !!(ngDevMode && (0, import_root_effect_scheduler.isExhaustiveCheckNoChanges)()));
  if (consumer) {
    consumer.dirty = false;
  }
  lView[import_root_effect_scheduler.FLAGS] &= ~(8192 | 1024);
  if (shouldRefreshView) {
    refreshView(tView, lView, tView.template, lView[import_root_effect_scheduler.CONTEXT]);
  } else if (flags & 8192) {
    const prevConsumer = (0, import_signal.setActiveConsumer)(null);
    try {
      if (!isInCheckNoChangesPass) {
        runEffectsInView(lView);
      }
      detectChangesInEmbeddedViews(
        lView,
        1
        /* ChangeDetectionMode.Targeted */
      );
      const components = tView.components;
      if (components !== null) {
        detectChangesInChildComponents(
          lView,
          components,
          1
          /* ChangeDetectionMode.Targeted */
        );
      }
      if (!isInCheckNoChangesPass) {
        addAfterRenderSequencesForView(lView);
      }
    } finally {
      (0, import_signal.setActiveConsumer)(prevConsumer);
    }
  }
}
function detectChangesInChildComponents(hostLView, components, mode) {
  for (let i = 0; i < components.length; i++) {
    detectChangesInComponent(hostLView, components[i], mode);
  }
}
function processHostBindingOpCodes(tView, lView) {
  const hostBindingOpCodes = tView.hostBindingOpCodes;
  if (hostBindingOpCodes === null)
    return;
  try {
    for (let i = 0; i < hostBindingOpCodes.length; i++) {
      const opCode = hostBindingOpCodes[i];
      if (opCode < 0) {
        (0, import_root_effect_scheduler.setSelectedIndex)(~opCode);
      } else {
        const directiveIdx = opCode;
        const bindingRootIndx = hostBindingOpCodes[++i];
        const hostBindingFn = hostBindingOpCodes[++i];
        (0, import_root_effect_scheduler.setBindingRootForHostBindings)(bindingRootIndx, directiveIdx);
        const context = lView[directiveIdx];
        profiler(24, context);
        hostBindingFn(2, context);
        profiler(25, context);
      }
    }
  } finally {
    (0, import_root_effect_scheduler.setSelectedIndex)(-1);
  }
}
function markViewDirty(lView, source) {
  var _a2;
  const dirtyBitsToUse = (0, import_root_effect_scheduler.isRefreshingViews)() ? (
    // When we are actively refreshing views, we only use the `Dirty` bit to mark a view
    64
  ) : (
    // When we are not actively refreshing a view tree, it is absolutely
    // valid to update state and mark views dirty. We use the `RefreshView` flag in this
    // case to allow synchronously rerunning change detection. This applies today to
    // afterRender hooks as well as animation listeners which execute after detecting
    // changes in a view when the render factory flushes.
    1024 | 64
  );
  (_a2 = lView[import_root_effect_scheduler.ENVIRONMENT].changeDetectionScheduler) == null ? void 0 : _a2.notify(source);
  while (lView) {
    lView[import_root_effect_scheduler.FLAGS] |= dirtyBitsToUse;
    const parent = (0, import_root_effect_scheduler.getLViewParent)(lView);
    if ((0, import_root_effect_scheduler.isRootView)(lView) && !parent) {
      return lView;
    }
    lView = parent;
  }
  return null;
}
function createLContainer(hostNative, currentView, native, tNode) {
  ngDevMode && (0, import_root_effect_scheduler.assertLView)(currentView);
  const lContainer = [
    hostNative,
    // host native
    true,
    // Boolean `true` in this position signifies that this is an `LContainer`
    0,
    // flags
    currentView,
    // parent
    null,
    // next
    tNode,
    // t_host
    null,
    // dehydrated views
    native,
    // native,
    null,
    // view refs
    null
    // moved views
  ];
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(lContainer.length, import_root_effect_scheduler.CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
  return lContainer;
}
function getLViewFromLContainer(lContainer, index) {
  const adjustedIndex = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET + index;
  if (adjustedIndex < lContainer.length) {
    const lView = lContainer[adjustedIndex];
    ngDevMode && (0, import_root_effect_scheduler.assertLView)(lView);
    return lView;
  }
  return void 0;
}
function addLViewToLContainer(lContainer, lView, index, addToDOM = true) {
  const tView = lView[import_root_effect_scheduler.TVIEW];
  insertView(tView, lView, lContainer, index);
  if (addToDOM) {
    const beforeNode = getBeforeNodeForView(index, lContainer);
    const renderer = lView[import_root_effect_scheduler.RENDERER];
    const parentRNode = renderer.parentNode(lContainer[import_root_effect_scheduler.NATIVE]);
    if (parentRNode !== null) {
      addViewToDOM(tView, lContainer[import_root_effect_scheduler.T_HOST], renderer, lView, parentRNode, beforeNode);
    }
  }
  const hydrationInfo = lView[import_root_effect_scheduler.HYDRATION];
  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {
    hydrationInfo.firstChild = null;
  }
}
function removeLViewFromLContainer(lContainer, index) {
  const lView = detachView(lContainer, index);
  if (lView !== void 0) {
    destroyLView(lView[import_root_effect_scheduler.TVIEW], lView);
  }
  return lView;
}
function detachView(lContainer, removeIndex) {
  if (lContainer.length <= import_root_effect_scheduler.CONTAINER_HEADER_OFFSET)
    return;
  const indexInContainer = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET + removeIndex;
  const viewToDetach = lContainer[indexInContainer];
  if (viewToDetach) {
    const declarationLContainer = viewToDetach[import_root_effect_scheduler.DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && declarationLContainer !== lContainer) {
      detachMovedView(declarationLContainer, viewToDetach);
    }
    if (removeIndex > 0) {
      lContainer[indexInContainer - 1][import_root_effect_scheduler.NEXT] = viewToDetach[import_root_effect_scheduler.NEXT];
    }
    const removedLView = (0, import_root_effect_scheduler.removeFromArray)(lContainer, import_root_effect_scheduler.CONTAINER_HEADER_OFFSET + removeIndex);
    removeViewFromDOM(viewToDetach[import_root_effect_scheduler.TVIEW], viewToDetach);
    const lQueries = removedLView[import_root_effect_scheduler.QUERIES];
    if (lQueries !== null) {
      lQueries.detachView(removedLView[import_root_effect_scheduler.TVIEW]);
    }
    viewToDetach[import_root_effect_scheduler.PARENT] = null;
    viewToDetach[import_root_effect_scheduler.NEXT] = null;
    viewToDetach[import_root_effect_scheduler.FLAGS] &= ~128;
  }
  return viewToDetach;
}
function insertView(tView, lView, lContainer, index) {
  ngDevMode && (0, import_root_effect_scheduler.assertLView)(lView);
  ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(lContainer);
  const indexInContainer = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET + index;
  const containerLength = lContainer.length;
  if (index > 0) {
    lContainer[indexInContainer - 1][import_root_effect_scheduler.NEXT] = lView;
  }
  if (index < containerLength - import_root_effect_scheduler.CONTAINER_HEADER_OFFSET) {
    lView[import_root_effect_scheduler.NEXT] = lContainer[indexInContainer];
    (0, import_root_effect_scheduler.addToArray)(lContainer, import_root_effect_scheduler.CONTAINER_HEADER_OFFSET + index, lView);
  } else {
    lContainer.push(lView);
    lView[import_root_effect_scheduler.NEXT] = null;
  }
  lView[import_root_effect_scheduler.PARENT] = lContainer;
  const declarationLContainer = lView[import_root_effect_scheduler.DECLARATION_LCONTAINER];
  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
    trackMovedView(declarationLContainer, lView);
  }
  const lQueries = lView[import_root_effect_scheduler.QUERIES];
  if (lQueries !== null) {
    lQueries.insertView(tView);
  }
  (0, import_root_effect_scheduler.updateAncestorTraversalFlagsOnAttach)(lView);
  lView[import_root_effect_scheduler.FLAGS] |= 128;
}
function trackMovedView(declarationContainer, lView) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(lView, "LView required");
  ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(declarationContainer);
  const movedViews = declarationContainer[import_root_effect_scheduler.MOVED_VIEWS];
  const parent = lView[import_root_effect_scheduler.PARENT];
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(parent, "missing parent");
  if ((0, import_root_effect_scheduler.isLView)(parent)) {
    declarationContainer[import_root_effect_scheduler.FLAGS] |= 2;
  } else {
    const insertedComponentLView = parent[import_root_effect_scheduler.PARENT][import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW];
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(insertedComponentLView, "Missing insertedComponentLView");
    const declaredComponentLView = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW];
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(declaredComponentLView, "Missing declaredComponentLView");
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[import_root_effect_scheduler.FLAGS] |= 2;
    }
  }
  if (movedViews === null) {
    declarationContainer[import_root_effect_scheduler.MOVED_VIEWS] = [lView];
  } else {
    movedViews.push(lView);
  }
}
class ViewRef {
  constructor(_lView, _cdRefInjectingView) {
    __publicField(this, "_lView");
    __publicField(this, "_cdRefInjectingView");
    __publicField(this, "_appRef", null);
    __publicField(this, "_attachedToViewContainer", false);
    __publicField(this, "exhaustive");
    this._lView = _lView;
    this._cdRefInjectingView = _cdRefInjectingView;
  }
  get rootNodes() {
    const lView = this._lView;
    const tView = lView[import_root_effect_scheduler.TVIEW];
    return collectNativeNodes(tView, lView, tView.firstChild, []);
  }
  get context() {
    return this._lView[import_root_effect_scheduler.CONTEXT];
  }
  /**
   * @deprecated Replacing the full context object is not supported. Modify the context
   *   directly, or consider using a `Proxy` if you need to replace the full object.
   * // TODO(devversion): Remove this.
   */
  set context(value) {
    if (ngDevMode) {
      console.warn("Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.");
    }
    this._lView[import_root_effect_scheduler.CONTEXT] = value;
  }
  get destroyed() {
    return (0, import_root_effect_scheduler.isDestroyed)(this._lView);
  }
  destroy() {
    if (this._appRef) {
      this._appRef.detachView(this);
    } else if (this._attachedToViewContainer) {
      const parent = this._lView[import_root_effect_scheduler.PARENT];
      if ((0, import_root_effect_scheduler.isLContainer)(parent)) {
        const viewRefs = parent[import_root_effect_scheduler.VIEW_REFS];
        const index = viewRefs ? viewRefs.indexOf(this) : -1;
        if (index > -1) {
          ngDevMode && (0, import_root_effect_scheduler.assertEqual)(index, parent.indexOf(this._lView) - import_root_effect_scheduler.CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
          detachView(parent, index);
          (0, import_root_effect_scheduler.removeFromArray)(viewRefs, index);
        }
      }
      this._attachedToViewContainer = false;
    }
    destroyLView(this._lView[import_root_effect_scheduler.TVIEW], this._lView);
  }
  onDestroy(callback) {
    (0, import_root_effect_scheduler.storeLViewOnDestroy)(this._lView, callback);
  }
  /**
   * Marks a view and all of its ancestors dirty.
   *
   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is
   * checked when it needs to be re-rendered but the two normal triggers haven't marked it
   * dirty (i.e. inputs haven't changed and events haven't fired in the view).
   *
   * <!-- TODO: Add a link to a chapter on OnPush components -->
   *
   * @usageNotes
   * ### Example
   *
   * ```ts
   * @Component({
   *   selector: 'app-root',
   *   template: `Number of ticks: {{numberOfTicks}}`
   *   changeDetection: ChangeDetectionStrategy.OnPush,
   * })
   * class AppComponent {
   *   numberOfTicks = 0;
   *
   *   constructor(private ref: ChangeDetectorRef) {
   *     setInterval(() => {
   *       this.numberOfTicks++;
   *       // the following is required, otherwise the view will not be updated
   *       this.ref.markForCheck();
   *     }, 1000);
   *   }
   * }
   * ```
   */
  markForCheck() {
    markViewDirty(
      this._cdRefInjectingView || this._lView,
      4
      /* NotificationSource.MarkForCheck */
    );
  }
  /**
   * Detaches the view from the change detection tree.
   *
   * Detached views will not be checked during change detection runs until they are
   * re-attached, even if they are dirty. `detach` can be used in combination with
   * {@link ChangeDetectorRef#detectChanges} to implement local change
   * detection checks.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example defines a component with a large list of readonly data.
   * Imagine the data changes constantly, many times per second. For performance reasons,
   * we want to check and update the list every five seconds. We can do that by detaching
   * the component's change detector and doing a local check every five seconds.
   *
   * ```ts
   * class DataProvider {
   *   // in a real application the returned data will be different every time
   *   get data() {
   *     return [1,2,3,4,5];
   *   }
   * }
   *
   * @Component({
   *   selector: 'giant-list',
   *   template: `
   *     @for(d of dataProvider.data; track $index) {
   *        <li>Data {{d}}</li>
   *     }
   *   `,
   * })
   * class GiantList {
   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
   *     ref.detach();
   *     setInterval(() => {
   *       this.ref.detectChanges();
   *     }, 5000);
   *   }
   * }
   *
   * @Component({
   *   selector: 'app',
   *   providers: [DataProvider],
   *   template: `
   *     <giant-list><giant-list>
   *   `,
   * })
   * class App {
   * }
   * ```
   */
  detach() {
    this._lView[import_root_effect_scheduler.FLAGS] &= ~128;
  }
  /**
   * Re-attaches a view to the change detection tree.
   *
   * This can be used to re-attach views that were previously detached from the tree
   * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example creates a component displaying `live` data. The component will detach
   * its change detector from the main change detector tree when the component's live property
   * is set to false.
   *
   * ```ts
   * class DataProvider {
   *   data = 1;
   *
   *   constructor() {
   *     setInterval(() => {
   *       this.data = this.data * 2;
   *     }, 500);
   *   }
   * }
   *
   * @Component({
   *   selector: 'live-data',
   *   inputs: ['live'],
   *   template: 'Data: {{dataProvider.data}}'
   * })
   * class LiveData {
   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
   *
   *   set live(value) {
   *     if (value) {
   *       this.ref.reattach();
   *     } else {
   *       this.ref.detach();
   *     }
   *   }
   * }
   *
   * @Component({
   *   selector: 'app-root',
   *   providers: [DataProvider],
   *   template: `
   *     Live Update: <input type="checkbox" [(ngModel)]="live">
   *     <live-data [live]="live"><live-data>
   *   `,
   * })
   * class AppComponent {
   *   live = true;
   * }
   * ```
   */
  reattach() {
    (0, import_root_effect_scheduler.updateAncestorTraversalFlagsOnAttach)(this._lView);
    this._lView[import_root_effect_scheduler.FLAGS] |= 128;
  }
  /**
   * Checks the view and its children.
   *
   * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement
   * local change detection checks.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example defines a component with a large list of readonly data.
   * Imagine, the data changes constantly, many times per second. For performance reasons,
   * we want to check and update the list every five seconds.
   *
   * We can do that by detaching the component's change detector and doing a local change detection
   * check every five seconds.
   *
   * See {@link ChangeDetectorRef#detach} for more information.
   */
  detectChanges() {
    this._lView[import_root_effect_scheduler.FLAGS] |= 1024;
    detectChangesInternal(this._lView);
  }
  /**
   * Checks the change detector and its children, and throws if any changes are detected.
   *
   * This is used in development mode to verify that running change detection doesn't
   * introduce other changes.
   */
  checkNoChanges() {
    var _a2;
    if (ngDevMode) {
      try {
        (_a2 = this.exhaustive) != null ? _a2 : this.exhaustive = this._lView[import_root_effect_scheduler.INJECTOR$1].get(UseExhaustiveCheckNoChanges, USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT);
      } catch (e) {
        this.exhaustive = USE_EXHAUSTIVE_CHECK_NO_CHANGES_DEFAULT;
      }
      checkNoChangesInternal(this._lView, this.exhaustive);
    }
  }
  attachToViewContainerRef() {
    if (this._appRef) {
      throw new import_root_effect_scheduler.RuntimeError(902, ngDevMode && "This view is already attached directly to the ApplicationRef!");
    }
    this._attachedToViewContainer = true;
  }
  detachFromAppRef() {
    this._appRef = null;
    const isRoot = (0, import_root_effect_scheduler.isRootView)(this._lView);
    const declarationContainer = this._lView[import_root_effect_scheduler.DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      detachMovedView(declarationContainer, this._lView);
    }
    detachViewFromDOM(this._lView[import_root_effect_scheduler.TVIEW], this._lView);
  }
  attachToAppRef(appRef) {
    if (this._attachedToViewContainer) {
      throw new import_root_effect_scheduler.RuntimeError(902, ngDevMode && "This view is already attached to a ViewContainer!");
    }
    this._appRef = appRef;
    const isRoot = (0, import_root_effect_scheduler.isRootView)(this._lView);
    const declarationContainer = this._lView[import_root_effect_scheduler.DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      trackMovedView(declarationContainer, this._lView);
    }
    (0, import_root_effect_scheduler.updateAncestorTraversalFlagsOnAttach)(this._lView);
  }
}
function isViewDirty(view) {
  return (0, import_root_effect_scheduler.requiresRefreshOrTraversal)(view._lView) || !!(view._lView[import_root_effect_scheduler.FLAGS] & 64);
}
function markForRefresh(view) {
  (0, import_root_effect_scheduler.markViewForRefresh)(view._lView);
}
class TemplateRef {
  /** @internal */
  constructor(_declarationLView, _declarationTContainer, elementRef) {
    __publicField(this, "_declarationLView");
    __publicField(this, "_declarationTContainer");
    /**
     * The anchor element in the parent view for this embedded view.
     *
     * The data-binding and [injection contexts](guide/di/dependency-injection-context) of embedded
     * views created from this `TemplateRef` inherit from the contexts of this location.
     *
     * Typically new embedded views are attached to the view container of this location, but in
     * advanced use-cases, the view can be attached to a different container while keeping the
     * data-binding and injection context from the original location.
     *
     */
    __publicField(this, "elementRef");
    this._declarationLView = _declarationLView;
    this._declarationTContainer = _declarationTContainer;
    this.elementRef = elementRef;
  }
  /**
   * Returns an `ssrId` associated with a TView, which was used to
   * create this instance of the `TemplateRef`.
   *
   * @internal
   */
  get ssrId() {
    var _a2;
    return ((_a2 = this._declarationTContainer.tView) == null ? void 0 : _a2.ssrId) || null;
  }
  /**
   * Instantiates an unattached embedded view based on this template.
   * @param context The data-binding context of the embedded view, as declared
   * in the `<ng-template>` usage.
   * @param injector Injector to be used within the embedded view.
   * @returns The new embedded view object.
   */
  createEmbeddedView(context, injector) {
    return this.createEmbeddedViewImpl(context, injector);
  }
  /**
   * Implementation of the `createEmbeddedView` function.
   *
   * This implementation is internal and allows framework code
   * to invoke it with extra parameters (e.g. for hydration) without
   * affecting public API.
   *
   * @internal
   */
  createEmbeddedViewImpl(context, injector, dehydratedView) {
    const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context, { embeddedViewInjector: injector, dehydratedView });
    return new ViewRef(embeddedLView);
  }
}
/**
 * @internal
 * @nocollapse
 */
__publicField(TemplateRef, "__NG_ELEMENT_ID__", injectTemplateRef);
function injectTemplateRef() {
  return createTemplateRef((0, import_root_effect_scheduler.getCurrentTNode)(), (0, import_root_effect_scheduler.getLView)());
}
function createTemplateRef(hostTNode, hostLView) {
  if (hostTNode.type & 4) {
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(hostTNode.tView, "TView must be allocated");
    return new TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
  }
  return null;
}
const AT_THIS_LOCATION = "<-- AT THIS LOCATION";
function getFriendlyStringFromTNodeType(tNodeType) {
  switch (tNodeType) {
    case 4:
      return "view container";
    case 2:
      return "element";
    case 8:
      return "ng-container";
    case 32:
      return "icu";
    case 64:
      return "i18n";
    case 16:
      return "projection";
    case 1:
      return "text";
    case 128:
      return "@let";
    default:
      return "<unknown>";
  }
}
function validateMatchingNode(node, nodeType, tagName, lView, tNode, isViewContainerAnchor = false) {
  var _a2, _b2, _c2;
  if (!node || node.nodeType !== nodeType || node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() !== (tagName == null ? void 0 : tagName.toLowerCase())) {
    const expectedNode = shortRNodeDescription(nodeType, tagName, null);
    let header = `During hydration Angular expected ${expectedNode} but `;
    const hostComponentDef = getDeclarationComponentDef(lView);
    const componentClassName = (_a2 = hostComponentDef == null ? void 0 : hostComponentDef.type) == null ? void 0 : _a2.name;
    const expectedDom = describeExpectedDom(lView, tNode, isViewContainerAnchor);
    const expected = `Angular expected this DOM:

${expectedDom}

`;
    let actual = "";
    const componentHostElement = (0, import_root_effect_scheduler.unwrapRNode)(lView[import_root_effect_scheduler.HOST]);
    if (!node) {
      header += `the node was not found.

`;
      markRNodeAsHavingHydrationMismatch(componentHostElement, expectedDom);
    } else {
      const actualNode = shortRNodeDescription(node.nodeType, (_b2 = node.tagName) != null ? _b2 : null, (_c2 = node.textContent) != null ? _c2 : null);
      header += `found ${actualNode}.

`;
      const actualDom = describeDomFromNode(node);
      actual = `Actual DOM is:

${actualDom}

`;
      markRNodeAsHavingHydrationMismatch(componentHostElement, expectedDom, actualDom);
    }
    const footer = getHydrationErrorFooter(componentClassName);
    const message = header + expected + actual + getHydrationAttributeNote() + footer;
    throw new import_root_effect_scheduler.RuntimeError(-500, message);
  }
}
function validateSiblingNodeExists(node) {
  validateNodeExists(node);
  if (!node.nextSibling) {
    const header = "During hydration Angular expected more sibling nodes to be present.\n\n";
    const actual = `Actual DOM is:

${describeDomFromNode(node)}

`;
    const footer = getHydrationErrorFooter();
    const message = header + actual + footer;
    markRNodeAsHavingHydrationMismatch(node, "", actual);
    throw new import_root_effect_scheduler.RuntimeError(-501, message);
  }
}
function validateNodeExists(node, lView = null, tNode = null) {
  if (!node) {
    const header = "During hydration, Angular expected an element to be present at this location.\n\n";
    let expected = "";
    let footer = "";
    if (lView !== null && tNode !== null) {
      expected = describeExpectedDom(lView, tNode, false);
      footer = getHydrationErrorFooter();
      markRNodeAsHavingHydrationMismatch((0, import_root_effect_scheduler.unwrapRNode)(lView[import_root_effect_scheduler.HOST]), expected, "");
    }
    throw new import_root_effect_scheduler.RuntimeError(-502, `${header}${expected}

${footer}`);
  }
}
function nodeNotFoundError(lView, tNode) {
  const header = "During serialization, Angular was unable to find an element in the DOM:\n\n";
  const expected = `${describeExpectedDom(lView, tNode, false)}

`;
  const footer = getHydrationErrorFooter();
  throw new import_root_effect_scheduler.RuntimeError(-502, header + expected + footer);
}
function nodeNotFoundAtPathError(host, path) {
  const header = `During hydration Angular was unable to locate a node using the "${path}" path, starting from the ${describeRNode(host)} node.

`;
  const footer = getHydrationErrorFooter();
  markRNodeAsHavingHydrationMismatch(host);
  throw new import_root_effect_scheduler.RuntimeError(-502, header + footer);
}
function unsupportedProjectionOfDomNodes(rNode) {
  const header = "During serialization, Angular detected DOM nodes that were created outside of Angular context and provided as projectable nodes (likely via `ViewContainerRef.createComponent` or `createComponent` APIs). Hydration is not supported for such cases, consider refactoring the code to avoid this pattern or using `ngSkipHydration` on the host element of the component.\n\n";
  const actual = `${describeDomFromNode(rNode)}

`;
  const message = header + actual + getHydrationAttributeNote();
  return new import_root_effect_scheduler.RuntimeError(-503, message);
}
function invalidSkipHydrationHost(rNode) {
  const header = "The `ngSkipHydration` flag is applied on a node that doesn't act as a component host. Hydration can be skipped only on per-component basis.\n\n";
  const actual = `${describeDomFromNode(rNode)}

`;
  const footer = "Please move the `ngSkipHydration` attribute to the component host element.\n\n";
  const message = header + actual + footer;
  return new import_root_effect_scheduler.RuntimeError(-504, message);
}
function stringifyTNodeAttrs(tNode) {
  const results = [];
  if (tNode.attrs) {
    for (let i = 0; i < tNode.attrs.length; ) {
      const attrName = tNode.attrs[i++];
      if (typeof attrName == "number") {
        break;
      }
      const attrValue = tNode.attrs[i++];
      results.push(`${attrName}="${shorten(attrValue)}"`);
    }
  }
  return results.join(" ");
}
const internalAttrs = /* @__PURE__ */ new Set(["ngh", "ng-version", "ng-server-context"]);
function stringifyRNodeAttrs(rNode) {
  const results = [];
  for (let i = 0; i < rNode.attributes.length; i++) {
    const attr = rNode.attributes[i];
    if (internalAttrs.has(attr.name))
      continue;
    results.push(`${attr.name}="${shorten(attr.value)}"`);
  }
  return results.join(" ");
}
function describeTNode(tNode, innerContent = "\u2026") {
  switch (tNode.type) {
    case 1:
      const content = tNode.value ? `(${tNode.value})` : "";
      return `#text${content}`;
    case 2:
      const attrs = stringifyTNodeAttrs(tNode);
      const tag = tNode.value.toLowerCase();
      return `<${tag}${attrs ? " " + attrs : ""}>${innerContent}</${tag}>`;
    case 8:
      return "<!-- ng-container -->";
    case 4:
      return "<!-- container -->";
    default:
      const typeAsString = getFriendlyStringFromTNodeType(tNode.type);
      return `#node(${typeAsString})`;
  }
}
function describeRNode(rNode, innerContent = "\u2026") {
  var _a2;
  const node = rNode;
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
      const tag = node.tagName.toLowerCase();
      const attrs = stringifyRNodeAttrs(node);
      return `<${tag}${attrs ? " " + attrs : ""}>${innerContent}</${tag}>`;
    case Node.TEXT_NODE:
      const content = node.textContent ? shorten(node.textContent) : "";
      return `#text${content ? `(${content})` : ""}`;
    case Node.COMMENT_NODE:
      return `<!-- ${shorten((_a2 = node.textContent) != null ? _a2 : "")} -->`;
    default:
      return `#node(${node.nodeType})`;
  }
}
function describeExpectedDom(lView, tNode, isViewContainerAnchor) {
  const spacer = "  ";
  let content = "";
  if (tNode.prev) {
    content += spacer + "\u2026\n";
    content += spacer + describeTNode(tNode.prev) + "\n";
  } else if (tNode.type && tNode.type & 12) {
    content += spacer + "\u2026\n";
  }
  if (isViewContainerAnchor) {
    content += spacer + describeTNode(tNode) + "\n";
    content += spacer + `<!-- container -->  ${AT_THIS_LOCATION}
`;
  } else {
    content += spacer + describeTNode(tNode) + `  ${AT_THIS_LOCATION}
`;
  }
  content += spacer + "\u2026\n";
  const parentRNode = tNode.type ? getParentRElement(lView[import_root_effect_scheduler.TVIEW], tNode, lView) : null;
  if (parentRNode) {
    content = describeRNode(parentRNode, "\n" + content);
  }
  return content;
}
function describeDomFromNode(node) {
  const spacer = "  ";
  let content = "";
  const currentNode = node;
  if (currentNode.previousSibling) {
    content += spacer + "\u2026\n";
    content += spacer + describeRNode(currentNode.previousSibling) + "\n";
  }
  content += spacer + describeRNode(currentNode) + `  ${AT_THIS_LOCATION}
`;
  if (node.nextSibling) {
    content += spacer + "\u2026\n";
  }
  if (node.parentNode) {
    content = describeRNode(currentNode.parentNode, "\n" + content);
  }
  return content;
}
function shortRNodeDescription(nodeType, tagName, textContent) {
  switch (nodeType) {
    case Node.ELEMENT_NODE:
      return `<${tagName.toLowerCase()}>`;
    case Node.TEXT_NODE:
      const content = textContent ? ` (with the "${shorten(textContent)}" content)` : "";
      return `a text node${content}`;
    case Node.COMMENT_NODE:
      return "a comment node";
    default:
      return `#node(nodeType=${nodeType})`;
  }
}
function getHydrationErrorFooter(componentClassName) {
  const componentInfo = componentClassName ? `the "${componentClassName}"` : "corresponding";
  return `To fix this problem:
  * check ${componentInfo} component for hydration-related issues
  * check to see if your template has valid HTML structure
  * or skip hydration by adding the \`ngSkipHydration\` attribute to its host node in a template

`;
}
function getHydrationAttributeNote() {
  return "Note: attributes are only displayed to better represent the DOM but have no effect on hydration mismatches.\n\n";
}
function stripNewlines(input) {
  return input.replace(/\s+/gm, "");
}
function shorten(input, maxLength = 50) {
  if (!input) {
    return "";
  }
  input = stripNewlines(input);
  return input.length > maxLength ? `${input.substring(0, maxLength - 1)}\u2026` : input;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
  if (insertBeforeIndex === null) {
    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
  } else {
    ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, insertBeforeIndex);
    return (0, import_root_effect_scheduler.unwrapRNode)(lView[insertBeforeIndex]);
  }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
  if (Array.isArray(tNodeInsertBeforeIndex)) {
    ngDevMode && (0, import_root_effect_scheduler.assertDomNode)(childRNode);
    let i18nParent = childRNode;
    let anchorRNode = null;
    if (!(childTNode.type & 3)) {
      anchorRNode = i18nParent;
      i18nParent = parentRElement;
    }
    if (i18nParent !== null && childTNode.componentOffset === -1) {
      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
        const i18nChild = lView[tNodeInsertBeforeIndex[i]];
        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
      }
    }
  }
}
function getOrCreateTNode(tView, index, type, name, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  (0, import_root_effect_scheduler.assertGreaterThanOrEqual)(index, import_root_effect_scheduler.HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertPureTNodeType(type);
  let tNode = tView.data[index];
  if (tNode === null) {
    tNode = createTNodeAtIndex(tView, index, type, name, attrs);
    if ((0, import_root_effect_scheduler.isInI18nBlock)()) {
      tNode.flags |= 32;
    }
  } else if (tNode.type & 64) {
    tNode.type = type;
    tNode.value = name;
    tNode.attrs = attrs;
    const parent = (0, import_root_effect_scheduler.getCurrentParentTNode)();
    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
    ngDevMode && (0, import_root_effect_scheduler.assertTNodeForTView)(tNode, tView);
    ngDevMode && (0, import_root_effect_scheduler.assertEqual)(index, tNode.index, "Expecting same index");
  }
  (0, import_root_effect_scheduler.setCurrentTNode)(tNode, true);
  return tNode;
}
function createTNodeAtIndex(tView, index, type, name, attrs) {
  const currentTNode = (0, import_root_effect_scheduler.getCurrentTNodePlaceholderOk)();
  const isParent = (0, import_root_effect_scheduler.isCurrentTNodeParent)();
  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
  linkTNodeInTView(tView, tNode, currentTNode, isParent);
  return tNode;
}
function linkTNodeInTView(tView, tNode, currentTNode, isParent) {
  if (tView.firstChild === null) {
    tView.firstChild = tNode;
  }
  if (currentTNode !== null) {
    if (isParent) {
      if (currentTNode.child == null && tNode.parent !== null) {
        currentTNode.child = tNode;
      }
    } else {
      if (currentTNode.next === null) {
        currentTNode.next = tNode;
        tNode.prev = currentTNode;
      }
    }
  }
}
function createTNode(tView, tParent, type, index, value, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  (0, import_root_effect_scheduler.assertGreaterThanOrEqual)(index, import_root_effect_scheduler.HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && (0, import_root_effect_scheduler.assertNotSame)(attrs, void 0, "'undefined' is not valid value for 'attrs'");
  ngDevMode && tParent && (0, import_root_effect_scheduler.assertTNodeForTView)(tParent, tView);
  let injectorIndex = tParent ? tParent.injectorIndex : -1;
  let flags = 0;
  if ((0, import_root_effect_scheduler.isInSkipHydrationBlock)()) {
    flags |= 128;
  }
  const tNode = {
    type,
    index,
    insertBeforeIndex: null,
    injectorIndex,
    directiveStart: -1,
    directiveEnd: -1,
    directiveStylingLast: -1,
    componentOffset: -1,
    propertyBindings: null,
    flags,
    providerIndexes: 0,
    value,
    attrs,
    mergedAttrs: null,
    localNames: null,
    initialInputs: null,
    inputs: null,
    hostDirectiveInputs: null,
    outputs: null,
    hostDirectiveOutputs: null,
    directiveToIndex: null,
    tView: null,
    next: null,
    prev: null,
    projectionNext: null,
    child: null,
    parent: tParent,
    projection: null,
    styles: null,
    stylesWithoutHost: null,
    residualStyles: void 0,
    classes: null,
    classesWithoutHost: null,
    residualClasses: void 0,
    classBindings: 0,
    styleBindings: 0
  };
  if (ngDevMode) {
    Object.seal(tNode);
  }
  return tNode;
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
  previousTNodes.push(newTNode);
  if (previousTNodes.length > 1) {
    for (let i = previousTNodes.length - 2; i >= 0; i--) {
      const existingTNode = previousTNodes[i];
      if (!isI18nText(existingTNode)) {
        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
          setInsertBeforeIndex(existingTNode, newTNode.index);
        }
      }
    }
  }
}
function isI18nText(tNode) {
  return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
  const index = tNode.insertBeforeIndex;
  return Array.isArray(index) ? index[0] : index;
}
function setInsertBeforeIndex(tNode, value) {
  const index = tNode.insertBeforeIndex;
  if (Array.isArray(index)) {
    index[0] = value;
  } else {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    tNode.insertBeforeIndex = value;
  }
}
function getTIcu(tView, index) {
  const value = tView.data[index];
  if (value === null || typeof value === "string")
    return null;
  if (ngDevMode && !(value.hasOwnProperty("tView") || value.hasOwnProperty("currentCaseLViewIndex"))) {
    (0, import_root_effect_scheduler.throwError)("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
  }
  const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
  ngDevMode && (0, import_root_effect_scheduler.assertTIcu)(tIcu);
  return tIcu;
}
function setTIcu(tView, index, tIcu) {
  const tNode = tView.data[index];
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(tNode === null || tNode.hasOwnProperty("tView"), true, "We expect to get 'null'|'TIcuContainer'");
  if (tNode === null) {
    tView.data[index] = tIcu;
  } else {
    ngDevMode && assertTNodeType(
      tNode,
      32
      /* TNodeType.Icu */
    );
    tNode.value = tIcu;
  }
}
function setTNodeInsertBeforeIndex(tNode, index) {
  ngDevMode && (0, import_root_effect_scheduler.assertTNode)(tNode);
  let insertBeforeIndex = tNode.insertBeforeIndex;
  if (insertBeforeIndex === null) {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    insertBeforeIndex = tNode.insertBeforeIndex = [
      null,
      index
    ];
  } else {
    (0, import_root_effect_scheduler.assertEqual)(Array.isArray(insertBeforeIndex), true, "Expecting array here");
    insertBeforeIndex.push(index);
  }
}
function createTNodePlaceholder(tView, previousTNodes, index) {
  const tNode = createTNodeAtIndex(tView, index, 64, null, null);
  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
  return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
  const currentCase = lView[tIcu.currentCaseLViewIndex];
  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
  return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
  return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
  return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
  ngDevMode && (0, import_root_effect_scheduler.assertGreaterThanOrEqual)(parentIdx, 0, "Missing parent index");
  ngDevMode && (0, import_root_effect_scheduler.assertGreaterThan)(refIdx, 0, "Missing ref index");
  return opCode | parentIdx << 17 | refIdx << 1;
}
function isRootTemplateMessage(subTemplateIndex) {
  return subTemplateIndex === -1;
}
function enterIcu(state, tIcu, lView) {
  state.index = 0;
  const currentCase = getCurrentICUCaseIndex(tIcu, lView);
  if (currentCase !== null) {
    ngDevMode && (0, import_root_effect_scheduler.assertNumberInRange)(currentCase, 0, tIcu.cases.length - 1);
    state.removes = tIcu.remove[currentCase];
  } else {
    state.removes = import_root_effect_scheduler.EMPTY_ARRAY;
  }
}
function icuContainerIteratorNext(state) {
  if (state.index < state.removes.length) {
    const removeOpCode = state.removes[state.index++];
    ngDevMode && (0, import_root_effect_scheduler.assertNumber)(removeOpCode, "Expecting OpCode number");
    if (removeOpCode > 0) {
      const rNode = state.lView[removeOpCode];
      ngDevMode && (0, import_root_effect_scheduler.assertDomNode)(rNode);
      return rNode;
    } else {
      state.stack.push(state.index, state.removes);
      const tIcuIndex = ~removeOpCode;
      const tIcu = state.lView[import_root_effect_scheduler.TVIEW].data[tIcuIndex];
      ngDevMode && (0, import_root_effect_scheduler.assertTIcu)(tIcu);
      enterIcu(state, tIcu, state.lView);
      return icuContainerIteratorNext(state);
    }
  } else {
    if (state.stack.length === 0) {
      state.lView = void 0;
      return null;
    } else {
      state.removes = state.stack.pop();
      state.index = state.stack.pop();
      return icuContainerIteratorNext(state);
    }
  }
}
function loadIcuContainerVisitor() {
  const _state = {
    stack: [],
    index: -1
  };
  function icuContainerIteratorStart(tIcuContainerNode, lView) {
    _state.lView = lView;
    while (_state.stack.length)
      _state.stack.pop();
    ngDevMode && (0, import_root_effect_scheduler.assertTNodeForLView)(tIcuContainerNode, lView);
    enterIcu(_state, tIcuContainerNode.value, lView);
    return icuContainerIteratorNext.bind(null, _state);
  }
  return icuContainerIteratorStart;
}
function createIcuIterator(tIcu, lView) {
  const state = {
    stack: [],
    index: -1,
    lView
  };
  ngDevMode && (0, import_root_effect_scheduler.assertTIcu)(tIcu);
  enterIcu(state, tIcu, lView);
  return icuContainerIteratorNext.bind(null, state);
}
const REF_EXTRACTOR_REGEXP = /* @__PURE__ */ new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
function compressNodeLocation(referenceNode, path) {
  const result = [referenceNode];
  for (const segment of path) {
    const lastIdx = result.length - 1;
    if (lastIdx > 0 && result[lastIdx - 1] === segment) {
      const value = result[lastIdx] || 1;
      result[lastIdx] = value + 1;
    } else {
      result.push(segment, "");
    }
  }
  return result.join("");
}
function decompressNodeLocation(path) {
  const matches = path.match(REF_EXTRACTOR_REGEXP);
  const [_, refNodeId, refNodeName, rest] = matches;
  const ref = refNodeId ? parseInt(refNodeId, 10) : refNodeName;
  const steps = [];
  for (const [_2, step, count] of rest.matchAll(/(f|n)(\d*)/g)) {
    const repeat = parseInt(count, 10) || 1;
    steps.push(step, repeat);
  }
  return [ref, ...steps];
}
function isFirstElementInNgContainer(tNode) {
  var _a2;
  return !tNode.prev && ((_a2 = tNode.parent) == null ? void 0 : _a2.type) === 8;
}
function getNoOffsetIndex(tNode) {
  return tNode.index - import_root_effect_scheduler.HEADER_OFFSET;
}
function isDisconnectedNode(tNode, lView) {
  return !(tNode.type & (16 | 128)) && !!lView[tNode.index] && isDisconnectedRNode((0, import_root_effect_scheduler.unwrapRNode)(lView[tNode.index]));
}
function isDisconnectedRNode(rNode) {
  return !!rNode && !rNode.isConnected;
}
function locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex) {
  const i18nNodes = hydrationInfo.i18nNodes;
  if (i18nNodes) {
    return i18nNodes.get(noOffsetIndex);
  }
  return void 0;
}
function tryLocateRNodeByPath(hydrationInfo, lView, noOffsetIndex) {
  const nodes = hydrationInfo.data[NODES];
  const path = nodes == null ? void 0 : nodes[noOffsetIndex];
  return path ? locateRNodeByPath(path, lView) : null;
}
function locateNextRNode(hydrationInfo, tView, lView, tNode) {
  var _a2;
  const noOffsetIndex = getNoOffsetIndex(tNode);
  let native = locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex);
  if (native === void 0) {
    const nodes = hydrationInfo.data[NODES];
    if (nodes == null ? void 0 : nodes[noOffsetIndex]) {
      native = locateRNodeByPath(nodes[noOffsetIndex], lView);
    } else if (tView.firstChild === tNode) {
      native = hydrationInfo.firstChild;
    } else {
      const previousTNodeParent = tNode.prev === null;
      const previousTNode = (_a2 = tNode.prev) != null ? _a2 : tNode.parent;
      ngDevMode && (0, import_root_effect_scheduler.assertDefined)(previousTNode, "Unexpected state: current TNode does not have a connection to the previous node or a parent node.");
      if (isFirstElementInNgContainer(tNode)) {
        const noOffsetParentIndex = getNoOffsetIndex(tNode.parent);
        native = getSegmentHead(hydrationInfo, noOffsetParentIndex);
      } else {
        let previousRElement = (0, import_root_effect_scheduler.getNativeByTNode)(previousTNode, lView);
        if (previousTNodeParent) {
          native = previousRElement.firstChild;
        } else {
          const noOffsetPrevSiblingIndex = getNoOffsetIndex(previousTNode);
          const segmentHead = getSegmentHead(hydrationInfo, noOffsetPrevSiblingIndex);
          if (previousTNode.type === 2 && segmentHead) {
            const numRootNodesToSkip = calcSerializedContainerSize(hydrationInfo, noOffsetPrevSiblingIndex);
            const nodesToSkip = numRootNodesToSkip + 1;
            native = siblingAfter(nodesToSkip, segmentHead);
          } else {
            native = previousRElement.nextSibling;
          }
        }
      }
    }
  }
  return native;
}
function siblingAfter(skip, from) {
  let currentNode = from;
  for (let i = 0; i < skip; i++) {
    ngDevMode && validateSiblingNodeExists(currentNode);
    currentNode = currentNode.nextSibling;
  }
  return currentNode;
}
function stringifyNavigationInstructions(instructions) {
  const container = [];
  for (let i = 0; i < instructions.length; i += 2) {
    const step = instructions[i];
    const repeat = instructions[i + 1];
    for (let r = 0; r < repeat; r++) {
      container.push(step === NODE_NAVIGATION_STEP_FIRST_CHILD ? "firstChild" : "nextSibling");
    }
  }
  return container.join(".");
}
function navigateToNode(from, instructions) {
  let node = from;
  for (let i = 0; i < instructions.length; i += 2) {
    const step = instructions[i];
    const repeat = instructions[i + 1];
    for (let r = 0; r < repeat; r++) {
      if (ngDevMode && !node) {
        throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));
      }
      switch (step) {
        case NODE_NAVIGATION_STEP_FIRST_CHILD:
          node = node.firstChild;
          break;
        case NODE_NAVIGATION_STEP_NEXT_SIBLING:
          node = node.nextSibling;
          break;
      }
    }
  }
  if (ngDevMode && !node) {
    throw nodeNotFoundAtPathError(from, stringifyNavigationInstructions(instructions));
  }
  return node;
}
function locateRNodeByPath(path, lView) {
  const [referenceNode, ...navigationInstructions] = decompressNodeLocation(path);
  let ref;
  if (referenceNode === REFERENCE_NODE_HOST) {
    ref = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW][import_root_effect_scheduler.HOST];
  } else if (referenceNode === REFERENCE_NODE_BODY) {
    ref = \u0275\u0275resolveBody(lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW][import_root_effect_scheduler.HOST]);
  } else {
    const parentElementId = Number(referenceNode);
    ref = (0, import_root_effect_scheduler.unwrapRNode)(lView[parentElementId + import_root_effect_scheduler.HEADER_OFFSET]);
  }
  return navigateToNode(ref, navigationInstructions);
}
function navigateBetween(start, finish) {
  if (start === finish) {
    return [];
  } else if (start.parentElement == null || finish.parentElement == null) {
    return null;
  } else if (start.parentElement === finish.parentElement) {
    return navigateBetweenSiblings(start, finish);
  } else {
    const parent = finish.parentElement;
    const parentPath = navigateBetween(start, parent);
    const childPath = navigateBetween(parent.firstChild, finish);
    if (!parentPath || !childPath)
      return null;
    return [
      // First navigate to `finish`'s parent
      ...parentPath,
      // Then to its first child.
      NODE_NAVIGATION_STEP_FIRST_CHILD,
      // And finally from that node to `finish` (maybe a no-op if we're already there).
      ...childPath
    ];
  }
}
function navigateBetweenSiblings(start, finish) {
  const nav = [];
  let node = null;
  for (node = start; node != null && node !== finish; node = node.nextSibling) {
    nav.push(NODE_NAVIGATION_STEP_NEXT_SIBLING);
  }
  return node == null ? null : nav;
}
function calcPathBetween(from, to, fromNodeName) {
  const path = navigateBetween(from, to);
  return path === null ? null : compressNodeLocation(fromNodeName, path);
}
function calcPathForNode(tNode, lView, excludedParentNodes) {
  let parentTNode = tNode.parent;
  let parentIndex;
  let parentRNode;
  let referenceNodeName;
  while (parentTNode !== null && (isDisconnectedNode(parentTNode, lView) || (excludedParentNodes == null ? void 0 : excludedParentNodes.has(parentTNode.index)))) {
    parentTNode = parentTNode.parent;
  }
  if (parentTNode === null || !(parentTNode.type & 3)) {
    parentIndex = referenceNodeName = REFERENCE_NODE_HOST;
    parentRNode = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW][import_root_effect_scheduler.HOST];
  } else {
    parentIndex = parentTNode.index;
    parentRNode = (0, import_root_effect_scheduler.unwrapRNode)(lView[parentIndex]);
    referenceNodeName = (0, import_root_effect_scheduler.renderStringify)(parentIndex - import_root_effect_scheduler.HEADER_OFFSET);
  }
  let rNode = (0, import_root_effect_scheduler.unwrapRNode)(lView[tNode.index]);
  if (tNode.type & (12 | 32)) {
    const firstRNode = getFirstNativeNode(lView, tNode);
    if (firstRNode) {
      rNode = firstRNode;
    }
  }
  let path = calcPathBetween(parentRNode, rNode, referenceNodeName);
  if (path === null && parentRNode !== rNode) {
    const body = parentRNode.ownerDocument.body;
    path = calcPathBetween(body, rNode, REFERENCE_NODE_BODY);
    if (path === null) {
      throw nodeNotFoundError(lView, tNode);
    }
  }
  return path;
}
function gatherDeferBlocksCommentNodes(doc, node) {
  var _a2;
  const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, { acceptNode });
  let currentNode;
  const nodesByBlockId = /* @__PURE__ */ new Map();
  while (currentNode = commentNodesIterator.nextNode()) {
    const nghPattern = "ngh=";
    const content = currentNode == null ? void 0 : currentNode.textContent;
    const nghIdx = (_a2 = content == null ? void 0 : content.indexOf(nghPattern)) != null ? _a2 : -1;
    if (nghIdx > -1) {
      const nghValue = content.substring(nghIdx + nghPattern.length).trim();
      ngDevMode && (0, import_root_effect_scheduler.assertEqual)(nghValue.startsWith("d"), true, "Invalid defer block id found in a comment node.");
      nodesByBlockId.set(nghValue, currentNode);
    }
  }
  return nodesByBlockId;
}
function acceptNode(node) {
  var _a2;
  return ((_a2 = node.textContent) == null ? void 0 : _a2.trimStart().startsWith("ngh=")) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
}
let _isI18nHydrationSupportEnabled = false;
let _prepareI18nBlockForHydrationImpl = () => {
};
function setIsI18nHydrationSupportEnabled(enabled) {
  _isI18nHydrationSupportEnabled = enabled;
}
function isI18nHydrationSupportEnabled() {
  return _isI18nHydrationSupportEnabled;
}
function prepareI18nBlockForHydration(lView, index, parentTNode, subTemplateIndex) {
  _prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex);
}
function enablePrepareI18nBlockForHydrationImpl() {
  _prepareI18nBlockForHydrationImpl = prepareI18nBlockForHydrationImpl;
}
function isI18nHydrationEnabled(injector) {
  injector = injector != null ? injector : (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.Injector);
  return injector.get(IS_I18N_HYDRATION_ENABLED, false);
}
function getOrComputeI18nChildren(tView, context) {
  let i18nChildren = context.i18nChildren.get(tView);
  if (i18nChildren === void 0) {
    i18nChildren = collectI18nChildren(tView);
    context.i18nChildren.set(tView, i18nChildren);
  }
  return i18nChildren;
}
function collectI18nChildren(tView) {
  const children = /* @__PURE__ */ new Set();
  function collectI18nViews(node) {
    children.add(node.index);
    switch (node.kind) {
      case 1:
      case 2: {
        for (const childNode of node.children) {
          collectI18nViews(childNode);
        }
        break;
      }
      case 3: {
        for (const caseNodes of node.cases) {
          for (const caseNode of caseNodes) {
            collectI18nViews(caseNode);
          }
        }
        break;
      }
    }
  }
  for (let i = import_root_effect_scheduler.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const tI18n = tView.data[i];
    if (!tI18n || !tI18n.ast) {
      continue;
    }
    for (const node of tI18n.ast) {
      collectI18nViews(node);
    }
  }
  return children.size === 0 ? null : children;
}
function trySerializeI18nBlock(lView, index, context) {
  if (!context.isI18nHydrationEnabled) {
    return null;
  }
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const tI18n = tView.data[index];
  if (!tI18n || !tI18n.ast) {
    return null;
  }
  const parentTNode = tView.data[tI18n.parentTNodeIndex];
  if (parentTNode && isI18nInSkipHydrationBlock(parentTNode)) {
    return null;
  }
  const serializedI18nBlock = {
    caseQueue: [],
    disconnectedNodes: /* @__PURE__ */ new Set(),
    disjointNodes: /* @__PURE__ */ new Set()
  };
  serializeI18nBlock(lView, serializedI18nBlock, context, tI18n.ast);
  return serializedI18nBlock.caseQueue.length === 0 && serializedI18nBlock.disconnectedNodes.size === 0 && serializedI18nBlock.disjointNodes.size === 0 ? null : serializedI18nBlock;
}
function serializeI18nBlock(lView, serializedI18nBlock, context, nodes) {
  let prevRNode = null;
  for (const node of nodes) {
    const nextRNode = serializeI18nNode(lView, serializedI18nBlock, context, node);
    if (nextRNode) {
      if (isDisjointNode(prevRNode, nextRNode)) {
        serializedI18nBlock.disjointNodes.add(node.index - import_root_effect_scheduler.HEADER_OFFSET);
      }
      prevRNode = nextRNode;
    }
  }
  return prevRNode;
}
function isDisjointNode(prevNode, nextNode) {
  return prevNode && prevNode.nextSibling !== nextNode;
}
function serializeI18nNode(lView, serializedI18nBlock, context, node) {
  const maybeRNode = (0, import_root_effect_scheduler.unwrapRNode)(lView[node.index]);
  if (!maybeRNode || isDisconnectedRNode(maybeRNode)) {
    serializedI18nBlock.disconnectedNodes.add(node.index - import_root_effect_scheduler.HEADER_OFFSET);
    return null;
  }
  const rNode = maybeRNode;
  switch (node.kind) {
    case 0: {
      processTextNodeBeforeSerialization(context, rNode);
      break;
    }
    case 1:
    case 2: {
      serializeI18nBlock(lView, serializedI18nBlock, context, node.children);
      break;
    }
    case 3: {
      const currentCase = lView[node.currentCaseLViewIndex];
      if (currentCase != null) {
        const caseIdx = currentCase < 0 ? ~currentCase : currentCase;
        serializedI18nBlock.caseQueue.push(caseIdx);
        serializeI18nBlock(lView, serializedI18nBlock, context, node.cases[caseIdx]);
      }
      break;
    }
  }
  return getFirstNativeNodeForI18nNode(lView, node);
}
function getFirstNativeNodeForI18nNode(lView, node) {
  var _a2;
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const maybeTNode = tView.data[node.index];
  if (isTNodeShape(maybeTNode)) {
    return getFirstNativeNode(lView, maybeTNode);
  } else if (node.kind === 3) {
    const icuIterator = createIcuIterator(maybeTNode, lView);
    let rNode = icuIterator();
    return rNode != null ? rNode : (0, import_root_effect_scheduler.unwrapRNode)(lView[node.index]);
  } else {
    return (_a2 = (0, import_root_effect_scheduler.unwrapRNode)(lView[node.index])) != null ? _a2 : null;
  }
}
function setCurrentNode(state, node) {
  state.currentNode = node;
}
function appendI18nNodeToCollection(context, state, astNode) {
  const noOffsetIndex = astNode.index - import_root_effect_scheduler.HEADER_OFFSET;
  const { disconnectedNodes } = context;
  const currentNode = state.currentNode;
  if (state.isConnected) {
    context.i18nNodes.set(noOffsetIndex, currentNode);
    disconnectedNodes.delete(noOffsetIndex);
  } else {
    disconnectedNodes.add(noOffsetIndex);
  }
  return currentNode;
}
function skipSiblingNodes(state, skip) {
  var _a2;
  let currentNode = state.currentNode;
  for (let i = 0; i < skip; i++) {
    if (!currentNode) {
      break;
    }
    currentNode = (_a2 = currentNode == null ? void 0 : currentNode.nextSibling) != null ? _a2 : null;
  }
  return currentNode;
}
function forkHydrationState(state, nextNode) {
  return { currentNode: nextNode, isConnected: state.isConnected };
}
function prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex) {
  var _a2, _b2, _c2, _d2, _e2;
  const hydrationInfo = lView[import_root_effect_scheduler.HYDRATION];
  if (!hydrationInfo) {
    return;
  }
  if (!isI18nHydrationSupportEnabled() || parentTNode && (isI18nInSkipHydrationBlock(parentTNode) || isDisconnectedNode$1(hydrationInfo, parentTNode.index - import_root_effect_scheduler.HEADER_OFFSET))) {
    return;
  }
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const tI18n = tView.data[index];
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(tI18n, "Expected i18n data to be present in a given TView slot during hydration");
  function findHydrationRoot() {
    if (isRootTemplateMessage(subTemplateIndex)) {
      ngDevMode && (0, import_root_effect_scheduler.assertDefined)(parentTNode, "Expected parent TNode while hydrating i18n root");
      const rootNode = locateNextRNode(hydrationInfo, tView, lView, parentTNode);
      return parentTNode.type & 8 ? rootNode : rootNode.firstChild;
    }
    return hydrationInfo == null ? void 0 : hydrationInfo.firstChild;
  }
  const currentNode = findHydrationRoot();
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(currentNode, "Expected root i18n node during hydration");
  const disconnectedNodes = (_a2 = initDisconnectedNodes(hydrationInfo)) != null ? _a2 : /* @__PURE__ */ new Set();
  const i18nNodes = (_b2 = hydrationInfo.i18nNodes) != null ? _b2 : hydrationInfo.i18nNodes = /* @__PURE__ */ new Map();
  const caseQueue = (_d2 = (_c2 = hydrationInfo.data[I18N_DATA]) == null ? void 0 : _c2[index - import_root_effect_scheduler.HEADER_OFFSET]) != null ? _d2 : [];
  const dehydratedIcuData = (_e2 = hydrationInfo.dehydratedIcuData) != null ? _e2 : hydrationInfo.dehydratedIcuData = /* @__PURE__ */ new Map();
  collectI18nNodesFromDom({ hydrationInfo, lView, i18nNodes, disconnectedNodes, caseQueue, dehydratedIcuData }, { currentNode, isConnected: true }, tI18n.ast);
  hydrationInfo.disconnectedNodes = disconnectedNodes.size === 0 ? null : disconnectedNodes;
}
function collectI18nNodesFromDom(context, state, nodeOrNodes) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h;
  if (Array.isArray(nodeOrNodes)) {
    let nextState = state;
    for (const node of nodeOrNodes) {
      const targetNode = tryLocateRNodeByPath(context.hydrationInfo, context.lView, node.index - import_root_effect_scheduler.HEADER_OFFSET);
      if (targetNode) {
        nextState = forkHydrationState(state, targetNode);
      }
      collectI18nNodesFromDom(context, nextState, node);
    }
  } else {
    if (context.disconnectedNodes.has(nodeOrNodes.index - import_root_effect_scheduler.HEADER_OFFSET)) {
      return;
    }
    switch (nodeOrNodes.kind) {
      case 0: {
        const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
        setCurrentNode(state, (_a2 = currentNode == null ? void 0 : currentNode.nextSibling) != null ? _a2 : null);
        break;
      }
      case 1: {
        collectI18nNodesFromDom(context, forkHydrationState(state, (_c2 = (_b2 = state.currentNode) == null ? void 0 : _b2.firstChild) != null ? _c2 : null), nodeOrNodes.children);
        const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
        setCurrentNode(state, (_d2 = currentNode == null ? void 0 : currentNode.nextSibling) != null ? _d2 : null);
        break;
      }
      case 2: {
        const noOffsetIndex = nodeOrNodes.index - import_root_effect_scheduler.HEADER_OFFSET;
        const { hydrationInfo } = context;
        const containerSize = getNgContainerSize(hydrationInfo, noOffsetIndex);
        switch (nodeOrNodes.type) {
          case 0: {
            const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
            if (isSerializedElementContainer(hydrationInfo, noOffsetIndex)) {
              collectI18nNodesFromDom(context, state, nodeOrNodes.children);
              const nextNode = skipSiblingNodes(state, 1);
              setCurrentNode(state, nextNode);
            } else {
              collectI18nNodesFromDom(context, forkHydrationState(state, (_f2 = (_e2 = state.currentNode) == null ? void 0 : _e2.firstChild) != null ? _f2 : null), nodeOrNodes.children);
              setCurrentNode(state, (_g2 = currentNode == null ? void 0 : currentNode.nextSibling) != null ? _g2 : null);
              if (containerSize !== null) {
                const nextNode = skipSiblingNodes(state, containerSize + 1);
                setCurrentNode(state, nextNode);
              }
            }
            break;
          }
          case 1: {
            ngDevMode && (0, import_root_effect_scheduler.assertNotEqual)(containerSize, null, "Expected a container size while hydrating i18n subtemplate");
            appendI18nNodeToCollection(context, state, nodeOrNodes);
            const nextNode = skipSiblingNodes(state, containerSize + 1);
            setCurrentNode(state, nextNode);
            break;
          }
        }
        break;
      }
      case 3: {
        const selectedCase = state.isConnected ? context.caseQueue.shift() : null;
        const childState = { currentNode: null, isConnected: false };
        for (let i = 0; i < nodeOrNodes.cases.length; i++) {
          collectI18nNodesFromDom(context, i === selectedCase ? state : childState, nodeOrNodes.cases[i]);
        }
        if (selectedCase !== null) {
          context.dehydratedIcuData.set(nodeOrNodes.index, { case: selectedCase, node: nodeOrNodes });
        }
        const currentNode = appendI18nNodeToCollection(context, state, nodeOrNodes);
        setCurrentNode(state, (_h = currentNode == null ? void 0 : currentNode.nextSibling) != null ? _h : null);
        break;
      }
    }
  }
}
let _claimDehydratedIcuCaseImpl = () => {
};
function claimDehydratedIcuCase(lView, icuIndex, caseIndex) {
  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);
}
function enableClaimDehydratedIcuCaseImpl() {
  _claimDehydratedIcuCaseImpl = claimDehydratedIcuCaseImpl;
}
function claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex) {
  var _a2;
  const dehydratedIcuDataMap = (_a2 = lView[import_root_effect_scheduler.HYDRATION]) == null ? void 0 : _a2.dehydratedIcuData;
  if (dehydratedIcuDataMap) {
    const dehydratedIcuData = dehydratedIcuDataMap.get(icuIndex);
    if ((dehydratedIcuData == null ? void 0 : dehydratedIcuData.case) === caseIndex) {
      dehydratedIcuDataMap.delete(icuIndex);
    }
  }
}
function cleanupI18nHydrationData(lView) {
  const hydrationInfo = lView[import_root_effect_scheduler.HYDRATION];
  if (hydrationInfo) {
    const { i18nNodes, dehydratedIcuData: dehydratedIcuDataMap } = hydrationInfo;
    if (i18nNodes && dehydratedIcuDataMap) {
      const renderer = lView[import_root_effect_scheduler.RENDERER];
      for (const dehydratedIcuData of dehydratedIcuDataMap.values()) {
        cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData);
      }
    }
    hydrationInfo.i18nNodes = void 0;
    hydrationInfo.dehydratedIcuData = void 0;
  }
}
function cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData) {
  for (const node of dehydratedIcuData.node.cases[dehydratedIcuData.case]) {
    const rNode = i18nNodes.get(node.index - import_root_effect_scheduler.HEADER_OFFSET);
    if (rNode) {
      nativeRemoveNode(renderer, rNode, false);
    }
  }
}
function removeDehydratedViews(lContainer) {
  var _a2;
  const views = (_a2 = lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS]) != null ? _a2 : [];
  const parentLView = lContainer[import_root_effect_scheduler.PARENT];
  const renderer = parentLView[import_root_effect_scheduler.RENDERER];
  const retainedViews = [];
  for (const view of views) {
    if (view.data[DEFER_BLOCK_ID] !== void 0) {
      retainedViews.push(view);
    } else {
      removeDehydratedView(view, renderer);
      ngDevMode && ngDevMode.dehydratedViewsRemoved++;
    }
  }
  lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS] = retainedViews;
}
function removeDehydratedViewList(deferBlock) {
  const { lContainer } = deferBlock;
  const dehydratedViews = lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS];
  if (dehydratedViews === null)
    return;
  const parentLView = lContainer[import_root_effect_scheduler.PARENT];
  const renderer = parentLView[import_root_effect_scheduler.RENDERER];
  for (const view of dehydratedViews) {
    removeDehydratedView(view, renderer);
    ngDevMode && ngDevMode.dehydratedViewsRemoved++;
  }
}
function removeDehydratedView(dehydratedView, renderer) {
  let nodesRemoved = 0;
  let currentRNode = dehydratedView.firstChild;
  if (currentRNode) {
    const numNodes = dehydratedView.data[NUM_ROOT_NODES];
    while (nodesRemoved < numNodes) {
      ngDevMode && validateSiblingNodeExists(currentRNode);
      const nextSibling = currentRNode.nextSibling;
      nativeRemoveNode(renderer, currentRNode, false);
      currentRNode = nextSibling;
      nodesRemoved++;
    }
  }
}
function cleanupLContainer(lContainer) {
  removeDehydratedViews(lContainer);
  const hostLView = lContainer[import_root_effect_scheduler.HOST];
  if ((0, import_root_effect_scheduler.isLView)(hostLView)) {
    cleanupLView(hostLView);
  }
  for (let i = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    cleanupLView(lContainer[i]);
  }
}
function cleanupLView(lView) {
  cleanupI18nHydrationData(lView);
  const tView = lView[import_root_effect_scheduler.TVIEW];
  for (let i = import_root_effect_scheduler.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if ((0, import_root_effect_scheduler.isLContainer)(lView[i])) {
      const lContainer = lView[i];
      cleanupLContainer(lContainer);
    } else if ((0, import_root_effect_scheduler.isLView)(lView[i])) {
      cleanupLView(lView[i]);
    }
  }
}
function cleanupDehydratedViews(appRef) {
  const viewRefs = appRef._views;
  for (const viewRef of viewRefs) {
    const lNode = getLNodeForHydration(viewRef);
    if (lNode !== null && lNode[import_root_effect_scheduler.HOST] !== null) {
      if ((0, import_root_effect_scheduler.isLView)(lNode)) {
        cleanupLView(lNode);
      } else {
        cleanupLContainer(lNode);
      }
      ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;
    }
  }
}
function cleanupHydratedDeferBlocks(deferBlock, hydratedBlocks, registry, appRef) {
  if (deferBlock !== null) {
    registry.cleanup(hydratedBlocks);
    cleanupLContainer(deferBlock.lContainer);
    cleanupDehydratedViews(appRef);
  }
}
function locateDehydratedViewsInContainer(currentRNode, serializedViews) {
  var _a2;
  const dehydratedViews = [];
  for (const serializedView of serializedViews) {
    for (let i = 0; i < ((_a2 = serializedView[MULTIPLIER]) != null ? _a2 : 1); i++) {
      const view = {
        data: serializedView,
        firstChild: null
      };
      if (serializedView[NUM_ROOT_NODES] > 0) {
        view.firstChild = currentRNode;
        currentRNode = siblingAfter(serializedView[NUM_ROOT_NODES], currentRNode);
      }
      dehydratedViews.push(view);
    }
  }
  return [currentRNode, dehydratedViews];
}
let _findMatchingDehydratedViewImpl = () => null;
let _findAndReconcileMatchingDehydratedViewsImpl = () => null;
function enableFindMatchingDehydratedViewImpl() {
  _findMatchingDehydratedViewImpl = findMatchingDehydratedViewImpl;
  _findAndReconcileMatchingDehydratedViewsImpl = findAndReconcileMatchingDehydratedViewsImpl;
}
function findMatchingDehydratedViewImpl(lContainer, template) {
  if (hasMatchingDehydratedView(lContainer, template)) {
    return lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS].shift();
  } else {
    removeDehydratedViews(lContainer);
    return null;
  }
}
function findMatchingDehydratedView(lContainer, template) {
  return _findMatchingDehydratedViewImpl(lContainer, template);
}
function findAndReconcileMatchingDehydratedViewsImpl(lContainer, templateTNode, hostLView) {
  if (templateTNode.tView.ssrId === null)
    return null;
  const dehydratedView = findMatchingDehydratedView(lContainer, templateTNode.tView.ssrId);
  if (hostLView[import_root_effect_scheduler.TVIEW].firstUpdatePass && dehydratedView === null) {
    removeStaleDehydratedBranch(hostLView, templateTNode);
  }
  return dehydratedView;
}
function findAndReconcileMatchingDehydratedViews(lContainer, templateTNode, hostLView) {
  return _findAndReconcileMatchingDehydratedViewsImpl(lContainer, templateTNode, hostLView);
}
function removeStaleDehydratedBranch(hostLView, tNode) {
  let currentTNode = tNode;
  while (currentTNode) {
    if (cleanupMatchingDehydratedViews(hostLView, currentTNode))
      return;
    if ((currentTNode.flags & 256) === 256) {
      break;
    }
    currentTNode = currentTNode.prev;
  }
  currentTNode = tNode.next;
  while (currentTNode) {
    if ((currentTNode.flags & 512) !== 512) {
      break;
    }
    if (cleanupMatchingDehydratedViews(hostLView, currentTNode))
      return;
    currentTNode = currentTNode.next;
  }
}
function hasMatchingDehydratedView(lContainer, template) {
  const views = lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS];
  if (!template || views === null || views.length === 0) {
    return false;
  }
  return views[0].data[TEMPLATE_ID] === template;
}
function cleanupMatchingDehydratedViews(hostLView, currentTNode) {
  var _a2;
  const ssrId = (_a2 = currentTNode.tView) == null ? void 0 : _a2.ssrId;
  if (ssrId == null)
    return false;
  const container = hostLView[currentTNode.index];
  if ((0, import_root_effect_scheduler.isLContainer)(container) && hasMatchingDehydratedView(container, ssrId)) {
    removeDehydratedViews(container);
    return true;
  }
  return false;
}
let ComponentRef$1 = class ComponentRef {
};
let ComponentFactory$1 = class ComponentFactory {
};
class _NullComponentFactoryResolver {
  resolveComponentFactory(component) {
    throw new import_root_effect_scheduler.RuntimeError(917, typeof ngDevMode !== "undefined" && ngDevMode && `No component factory found for ${(0, import_root_effect_scheduler.stringify)(component)}.`);
  }
}
let ComponentFactoryResolver$1 = (_b = class {
}, __publicField(_b, "NULL", new _NullComponentFactoryResolver()), _b);
class RendererFactory2 {
}
class Renderer2 {
  constructor() {
    /**
     * If null or undefined, the view engine won't call it.
     * This is used as a performance optimization for production mode.
     */
    __publicField(this, "destroyNode", null);
  }
}
/**
 * @internal
 * @nocollapse
 */
__publicField(Renderer2, "__NG_ELEMENT_ID__", () => injectRenderer2());
function injectRenderer2() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  const nodeAtIndex = (0, import_root_effect_scheduler.getComponentLViewByIndex)(tNode.index, lView);
  return ((0, import_root_effect_scheduler.isLView)(nodeAtIndex) ? nodeAtIndex : lView)[import_root_effect_scheduler.RENDERER];
}
const _Sanitizer = class _Sanitizer {
};
/** @nocollapse */
__publicField(
  _Sanitizer,
  "\u0275prov",
  /** @pureOrBreakMyCode */
  /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({
    token: _Sanitizer,
    providedIn: "root",
    factory: () => null
  })
);
let Sanitizer = _Sanitizer;
function isModuleWithProviders(value) {
  return value.ngModule !== void 0;
}
function isNgModule(value) {
  return !!(0, import_root_effect_scheduler.getNgModuleDef)(value);
}
function isPipe(value) {
  return !!(0, import_root_effect_scheduler.getPipeDef)(value);
}
function isDirective(value) {
  return !!(0, import_root_effect_scheduler.getDirectiveDef)(value);
}
function isComponent(value) {
  return !!(0, import_root_effect_scheduler.getComponentDef)(value);
}
function getDependencyTypeForError(type) {
  if ((0, import_root_effect_scheduler.getComponentDef)(type))
    return "component";
  if ((0, import_root_effect_scheduler.getDirectiveDef)(type))
    return "directive";
  if ((0, import_root_effect_scheduler.getPipeDef)(type))
    return "pipe";
  return "type";
}
function verifyStandaloneImport(depType, importingType) {
  if ((0, import_root_effect_scheduler.isForwardRef)(depType)) {
    depType = (0, import_root_effect_scheduler.resolveForwardRef)(depType);
    if (!depType) {
      throw new Error(`Expected forwardRef function, imported from "${(0, import_root_effect_scheduler.stringifyForError)(importingType)}", to return a standalone entity or NgModule but got "${(0, import_root_effect_scheduler.stringifyForError)(depType) || depType}".`);
    }
  }
  if ((0, import_root_effect_scheduler.getNgModuleDef)(depType) == null) {
    const def = (0, import_root_effect_scheduler.getComponentDef)(depType) || (0, import_root_effect_scheduler.getDirectiveDef)(depType) || (0, import_root_effect_scheduler.getPipeDef)(depType);
    if (def != null) {
      if (!def.standalone) {
        throw new Error(`The "${(0, import_root_effect_scheduler.stringifyForError)(depType)}" ${getDependencyTypeForError(depType)}, imported from "${(0, import_root_effect_scheduler.stringifyForError)(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
      }
    } else {
      if (isModuleWithProviders(depType)) {
        throw new Error(`A module with providers was imported from "${(0, import_root_effect_scheduler.stringifyForError)(importingType)}". Modules with providers are not supported in standalone components imports.`);
      } else {
        throw new Error(`The "${(0, import_root_effect_scheduler.stringifyForError)(depType)}" type, imported from "${(0, import_root_effect_scheduler.stringifyForError)(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
      }
    }
  }
}
class DepsTracker {
  constructor() {
    __publicField(this, "ownerNgModule", /* @__PURE__ */ new Map());
    __publicField(this, "ngModulesWithSomeUnresolvedDecls", /* @__PURE__ */ new Set());
    __publicField(this, "ngModulesScopeCache", /* @__PURE__ */ new Map());
    __publicField(this, "standaloneComponentsScopeCache", /* @__PURE__ */ new Map());
  }
  /**
   * Attempts to resolve ng module's forward ref declarations as much as possible and add them to
   * the `ownerNgModule` map. This method normally should be called after the initial parsing when
   * all the forward refs are resolved (e.g., when trying to render a component)
   */
  resolveNgModulesDecls() {
    if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {
      return;
    }
    for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {
      const def = (0, import_root_effect_scheduler.getNgModuleDef)(moduleType);
      if (def == null ? void 0 : def.declarations) {
        for (const decl of maybeUnwrapFn(def.declarations)) {
          if (isComponent(decl)) {
            this.ownerNgModule.set(decl, moduleType);
          }
        }
      }
    }
    this.ngModulesWithSomeUnresolvedDecls.clear();
  }
  /** @override */
  getComponentDependencies(type, rawImports) {
    this.resolveNgModulesDecls();
    const def = (0, import_root_effect_scheduler.getComponentDef)(type);
    if (def === null) {
      throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);
    }
    if (def.standalone) {
      const scope = this.getStandaloneComponentScope(type, rawImports);
      if (scope.compilation.isPoisoned) {
        return { dependencies: [] };
      }
      return {
        dependencies: [
          ...scope.compilation.directives,
          ...scope.compilation.pipes,
          ...scope.compilation.ngModules
        ]
      };
    } else {
      if (!this.ownerNgModule.has(type)) {
        return { dependencies: [] };
      }
      const scope = this.getNgModuleScope(this.ownerNgModule.get(type));
      if (scope.compilation.isPoisoned) {
        return { dependencies: [] };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes]
      };
    }
  }
  /**
   * @override
   * This implementation does not make use of param scopeInfo since it assumes the scope info is
   * already added to the type itself through methods like {@link setNgModuleScope}
   */
  registerNgModule(type, scopeInfo) {
    if (!isNgModule(type)) {
      throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);
    }
    this.ngModulesWithSomeUnresolvedDecls.add(type);
  }
  /** @override */
  clearScopeCacheFor(type) {
    this.ngModulesScopeCache.delete(type);
    this.standaloneComponentsScopeCache.delete(type);
  }
  /** @override */
  getNgModuleScope(type) {
    if (this.ngModulesScopeCache.has(type)) {
      return this.ngModulesScopeCache.get(type);
    }
    const scope = this.computeNgModuleScope(type);
    this.ngModulesScopeCache.set(type, scope);
    return scope;
  }
  /** Compute NgModule scope afresh. */
  computeNgModuleScope(type) {
    const def = (0, import_root_effect_scheduler.getNgModuleDefOrThrow)(type);
    const scope = {
      exported: { directives: /* @__PURE__ */ new Set(), pipes: /* @__PURE__ */ new Set() },
      compilation: { directives: /* @__PURE__ */ new Set(), pipes: /* @__PURE__ */ new Set() }
    };
    for (const imported of maybeUnwrapFn(def.imports)) {
      if (isNgModule(imported)) {
        const importedScope = this.getNgModuleScope(imported);
        addSet(importedScope.exported.directives, scope.compilation.directives);
        addSet(importedScope.exported.pipes, scope.compilation.pipes);
      } else if ((0, import_root_effect_scheduler.isStandalone)(imported)) {
        if (isDirective(imported) || isComponent(imported)) {
          scope.compilation.directives.add(imported);
        } else if (isPipe(imported)) {
          scope.compilation.pipes.add(imported);
        } else {
          throw new import_root_effect_scheduler.RuntimeError(980, "The standalone imported type is neither a component nor a directive nor a pipe");
        }
      } else {
        scope.compilation.isPoisoned = true;
        break;
      }
    }
    if (!scope.compilation.isPoisoned) {
      for (const decl of maybeUnwrapFn(def.declarations)) {
        if (isNgModule(decl) || (0, import_root_effect_scheduler.isStandalone)(decl)) {
          scope.compilation.isPoisoned = true;
          break;
        }
        if (isPipe(decl)) {
          scope.compilation.pipes.add(decl);
        } else {
          scope.compilation.directives.add(decl);
        }
      }
    }
    for (const exported of maybeUnwrapFn(def.exports)) {
      if (isNgModule(exported)) {
        const exportedScope = this.getNgModuleScope(exported);
        addSet(exportedScope.exported.directives, scope.exported.directives);
        addSet(exportedScope.exported.pipes, scope.exported.pipes);
        addSet(exportedScope.exported.directives, scope.compilation.directives);
        addSet(exportedScope.exported.pipes, scope.compilation.pipes);
      } else if (isPipe(exported)) {
        scope.exported.pipes.add(exported);
      } else {
        scope.exported.directives.add(exported);
      }
    }
    return scope;
  }
  /** @override */
  getStandaloneComponentScope(type, rawImports) {
    if (this.standaloneComponentsScopeCache.has(type)) {
      return this.standaloneComponentsScopeCache.get(type);
    }
    const ans = this.computeStandaloneComponentScope(type, rawImports);
    this.standaloneComponentsScopeCache.set(type, ans);
    return ans;
  }
  computeStandaloneComponentScope(type, rawImports) {
    const ans = {
      compilation: {
        // Standalone components are always able to self-reference.
        directives: /* @__PURE__ */ new Set([type]),
        pipes: /* @__PURE__ */ new Set(),
        ngModules: /* @__PURE__ */ new Set()
      }
    };
    for (const rawImport of (0, import_root_effect_scheduler.flatten)(rawImports != null ? rawImports : [])) {
      const imported = (0, import_root_effect_scheduler.resolveForwardRef)(rawImport);
      try {
        verifyStandaloneImport(imported, type);
      } catch (e) {
        ans.compilation.isPoisoned = true;
        return ans;
      }
      if (isNgModule(imported)) {
        ans.compilation.ngModules.add(imported);
        const importedScope = this.getNgModuleScope(imported);
        if (importedScope.exported.isPoisoned) {
          ans.compilation.isPoisoned = true;
          return ans;
        }
        addSet(importedScope.exported.directives, ans.compilation.directives);
        addSet(importedScope.exported.pipes, ans.compilation.pipes);
      } else if (isPipe(imported)) {
        ans.compilation.pipes.add(imported);
      } else if (isDirective(imported) || isComponent(imported)) {
        ans.compilation.directives.add(imported);
      } else {
        ans.compilation.isPoisoned = true;
        return ans;
      }
    }
    return ans;
  }
  /** @override */
  isOrphanComponent(cmp) {
    const def = (0, import_root_effect_scheduler.getComponentDef)(cmp);
    if (!def || def.standalone) {
      return false;
    }
    this.resolveNgModulesDecls();
    return !this.ownerNgModule.has(cmp);
  }
}
function addSet(sourceSet, targetSet) {
  for (const m of sourceSet) {
    targetSet.add(m);
  }
}
const depsTracker = new DepsTracker();
const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
class ChainedInjector {
  constructor(injector, parentInjector) {
    __publicField(this, "injector");
    __publicField(this, "parentInjector");
    this.injector = injector;
    this.parentInjector = parentInjector;
  }
  get(token, notFoundValue, options) {
    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, options);
    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
      return value;
    }
    return this.parentInjector.get(token, notFoundValue, options);
  }
}
function computeStaticStyling(tNode, attrs, writeToHost) {
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)((0, import_root_effect_scheduler.getTView)(), "Expecting to be called in first template pass only");
  let styles = writeToHost ? tNode.styles : null;
  let classes = writeToHost ? tNode.classes : null;
  let mode = 0;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const value = attrs[i];
      if (typeof value === "number") {
        mode = value;
      } else if (mode == 1) {
        classes = (0, import_root_effect_scheduler.concatStringsWithSpace)(classes, value);
      } else if (mode == 2) {
        const style = value;
        const styleValue = attrs[++i];
        styles = (0, import_root_effect_scheduler.concatStringsWithSpace)(styles, style + ": " + styleValue + ";");
      }
    }
  }
  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
function \u0275\u0275directiveInject(token, flags = 0) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  if (lView === null) {
    ngDevMode && (0, import_root_effect_scheduler.assertInjectImplementationNotEqual)(\u0275\u0275directiveInject);
    return (0, import_root_effect_scheduler.\u0275\u0275inject)(token, flags);
  }
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  const value = getOrCreateInjectable(tNode, lView, (0, import_root_effect_scheduler.resolveForwardRef)(token), flags);
  ngDevMode && (0, import_root_effect_scheduler.emitInjectEvent)(token, value, flags);
  return value;
}
function \u0275\u0275invalidFactory() {
  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : "invalid";
  throw new Error(msg);
}
function resolveDirectives(tView, lView, tNode, localRefs, directiveMatcher) {
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  const exportsMap = localRefs === null ? null : { "": -1 };
  const matchedDirectiveDefs = directiveMatcher(tView, tNode);
  if (matchedDirectiveDefs !== null) {
    let directiveDefs = matchedDirectiveDefs;
    let hostDirectiveDefs = null;
    let hostDirectiveRanges = null;
    for (const def of matchedDirectiveDefs) {
      if (def.resolveHostDirectives !== null) {
        [directiveDefs, hostDirectiveDefs, hostDirectiveRanges] = def.resolveHostDirectives(matchedDirectiveDefs);
        break;
      }
    }
    ngDevMode && assertNoDuplicateDirectives(directiveDefs);
    initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs, hostDirectiveRanges);
  }
  if (exportsMap !== null && localRefs !== null) {
    cacheMatchingLocalNames(tNode, localRefs, exportsMap);
  }
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
  const localNames = tNode.localNames = [];
  for (let i = 0; i < localRefs.length; i += 2) {
    const index = exportsMap[localRefs[i + 1]];
    if (index == null)
      throw new import_root_effect_scheduler.RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);
    localNames.push(localRefs[i], index);
  }
}
function markAsComponentHost(tView, hostTNode, componentOffset) {
  var _a2;
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  ngDevMode && (0, import_root_effect_scheduler.assertGreaterThan)(componentOffset, -1, "componentOffset must be great than -1");
  hostTNode.componentOffset = componentOffset;
  ((_a2 = tView.components) != null ? _a2 : tView.components = []).push(hostTNode.index);
}
function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs, hostDirectiveRanges) {
  var _a2, _b2;
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  const directivesLength = directives.length;
  let hasSeenComponent = false;
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    if (!hasSeenComponent && (0, import_root_effect_scheduler.isComponentDef)(def)) {
      hasSeenComponent = true;
      markAsComponentHost(tView, tNode, i);
    }
    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, def.type);
  }
  initTNodeFlags(tNode, tView.data.length, directivesLength);
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    if (def.providersResolver)
      def.providersResolver(def);
  }
  let preOrderHooksFound = false;
  let preOrderCheckHooksFound = false;
  let directiveIdx = allocExpando(tView, lView, directivesLength, null);
  ngDevMode && (0, import_root_effect_scheduler.assertSame)(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
  if (directivesLength > 0) {
    tNode.directiveToIndex = /* @__PURE__ */ new Map();
  }
  for (let i = 0; i < directivesLength; i++) {
    const def = directives[i];
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
    saveNameToExportMap(directiveIdx, def, exportsMap);
    if (hostDirectiveRanges !== null && hostDirectiveRanges.has(def)) {
      const [start, end] = hostDirectiveRanges.get(def);
      tNode.directiveToIndex.set(def.type, [
        directiveIdx,
        start + tNode.directiveStart,
        end + tNode.directiveStart
      ]);
    } else if (hostDirectiveDefs === null || !hostDirectiveDefs.has(def)) {
      tNode.directiveToIndex.set(def.type, directiveIdx);
    }
    if (def.contentQueries !== null)
      tNode.flags |= 4;
    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)
      tNode.flags |= 64;
    const lifeCycleHooks = def.type.prototype;
    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
      ((_a2 = tView.preOrderHooks) != null ? _a2 : tView.preOrderHooks = []).push(tNode.index);
      preOrderHooksFound = true;
    }
    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
      ((_b2 = tView.preOrderCheckHooks) != null ? _b2 : tView.preOrderCheckHooks = []).push(tNode.index);
      preOrderCheckHooksFound = true;
    }
    directiveIdx++;
  }
  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
}
function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs) {
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  for (let index = tNode.directiveStart; index < tNode.directiveEnd; index++) {
    const directiveDef = tView.data[index];
    if (hostDirectiveDefs === null || !hostDirectiveDefs.has(directiveDef)) {
      setupSelectorMatchedInputsOrOutputs(0, tNode, directiveDef, index);
      setupSelectorMatchedInputsOrOutputs(1, tNode, directiveDef, index);
      setupInitialInputs(tNode, index, false);
    } else {
      const hostDirectiveDef = hostDirectiveDefs.get(directiveDef);
      setupHostDirectiveInputsOrOutputs(0, tNode, hostDirectiveDef, index);
      setupHostDirectiveInputsOrOutputs(1, tNode, hostDirectiveDef, index);
      setupInitialInputs(tNode, index, true);
    }
  }
}
function setupSelectorMatchedInputsOrOutputs(mode, tNode, def, directiveIndex) {
  var _a2, _b2, _c2;
  const aliasMap = mode === 0 ? def.inputs : def.outputs;
  for (const publicName in aliasMap) {
    if (aliasMap.hasOwnProperty(publicName)) {
      let bindings;
      if (mode === 0) {
        bindings = (_a2 = tNode.inputs) != null ? _a2 : tNode.inputs = {};
      } else {
        bindings = (_b2 = tNode.outputs) != null ? _b2 : tNode.outputs = {};
      }
      (_c2 = bindings[publicName]) != null ? _c2 : bindings[publicName] = [];
      bindings[publicName].push(directiveIndex);
      setShadowStylingInputFlags(tNode, publicName);
    }
  }
}
function setupHostDirectiveInputsOrOutputs(mode, tNode, config, directiveIndex) {
  var _a2, _b2, _c2;
  const aliasMap = mode === 0 ? config.inputs : config.outputs;
  for (const initialName in aliasMap) {
    if (aliasMap.hasOwnProperty(initialName)) {
      const publicName = aliasMap[initialName];
      let bindings;
      if (mode === 0) {
        bindings = (_a2 = tNode.hostDirectiveInputs) != null ? _a2 : tNode.hostDirectiveInputs = {};
      } else {
        bindings = (_b2 = tNode.hostDirectiveOutputs) != null ? _b2 : tNode.hostDirectiveOutputs = {};
      }
      (_c2 = bindings[publicName]) != null ? _c2 : bindings[publicName] = [];
      bindings[publicName].push(directiveIndex, initialName);
      setShadowStylingInputFlags(tNode, publicName);
    }
  }
}
function setShadowStylingInputFlags(tNode, publicName) {
  if (publicName === "class") {
    tNode.flags |= 8;
  } else if (publicName === "style") {
    tNode.flags |= 16;
  }
}
function setupInitialInputs(tNode, directiveIndex, isHostDirective) {
  var _a2, _b2;
  const { attrs, inputs, hostDirectiveInputs } = tNode;
  if (attrs === null || !isHostDirective && inputs === null || isHostDirective && hostDirectiveInputs === null || // Do not use unbound attributes as inputs to structural directives, since structural
  // directive inputs can only be set using microsyntax (e.g. `<div *dir="exp">`).
  isInlineTemplate(tNode)) {
    (_a2 = tNode.initialInputs) != null ? _a2 : tNode.initialInputs = [];
    tNode.initialInputs.push(null);
    return;
  }
  let inputsToStore = null;
  let i = 0;
  while (i < attrs.length) {
    const attrName = attrs[i];
    if (attrName === 0) {
      i += 4;
      continue;
    } else if (attrName === 5) {
      i += 2;
      continue;
    } else if (typeof attrName === "number") {
      break;
    }
    if (!isHostDirective && inputs.hasOwnProperty(attrName)) {
      const inputConfig = inputs[attrName];
      for (const index of inputConfig) {
        if (index === directiveIndex) {
          inputsToStore != null ? inputsToStore : inputsToStore = [];
          inputsToStore.push(attrName, attrs[i + 1]);
          break;
        }
      }
    } else if (isHostDirective && hostDirectiveInputs.hasOwnProperty(attrName)) {
      const config = hostDirectiveInputs[attrName];
      for (let j = 0; j < config.length; j += 2) {
        if (config[j] === directiveIndex) {
          inputsToStore != null ? inputsToStore : inputsToStore = [];
          inputsToStore.push(config[j + 1], attrs[i + 1]);
          break;
        }
      }
    }
    i += 2;
  }
  (_b2 = tNode.initialInputs) != null ? _b2 : tNode.initialInputs = [];
  tNode.initialInputs.push(inputsToStore);
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
  ngDevMode && (0, import_root_effect_scheduler.assertGreaterThanOrEqual)(directiveIndex, import_root_effect_scheduler.HEADER_OFFSET, "Must be in Expando section");
  tView.data[directiveIndex] = def;
  const directiveFactory = def.factory || (def.factory = (0, import_root_effect_scheduler.getFactoryDef)(def.type, true));
  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, (0, import_root_effect_scheduler.isComponentDef)(def), \u0275\u0275directiveInject, ngDevMode ? def.type.name : null);
  tView.blueprint[directiveIndex] = nodeInjectorFactory;
  lView[directiveIndex] = nodeInjectorFactory;
  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  const hostBindings = def.hostBindings;
  if (hostBindings) {
    let hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) {
      hostBindingOpCodes = tView.hostBindingOpCodes = [];
    }
    const elementIndx = ~tNode.index;
    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
      hostBindingOpCodes.push(elementIndx);
    }
    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
  }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
  let i = hostBindingOpCodes.length;
  while (i > 0) {
    const value = hostBindingOpCodes[--i];
    if (typeof value === "number" && value < 0) {
      return value;
    }
  }
  return 0;
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
  if (exportsMap) {
    if (def.exportAs) {
      for (let i = 0; i < def.exportAs.length; i++) {
        exportsMap[def.exportAs[i]] = directiveIdx;
      }
    }
    if ((0, import_root_effect_scheduler.isComponentDef)(def))
      exportsMap[""] = directiveIdx;
  }
}
function initTNodeFlags(tNode, index, numberOfDirectives) {
  ngDevMode && (0, import_root_effect_scheduler.assertNotEqual)(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
  tNode.flags |= 1;
  tNode.directiveStart = index;
  tNode.directiveEnd = index + numberOfDirectives;
  tNode.providerIndexes = index;
}
function assertNoDuplicateDirectives(directives) {
  if (directives.length < 2) {
    return;
  }
  const seenDirectives = /* @__PURE__ */ new Set();
  for (const current of directives) {
    if (seenDirectives.has(current)) {
      throw new import_root_effect_scheduler.RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);
    }
    seenDirectives.add(current);
  }
}
function directiveHostFirstCreatePass(index, lView, type, name, directiveMatcher, bindingsEnabled, attrsIndex, localRefsIndex) {
  const tView = lView[import_root_effect_scheduler.TVIEW];
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  const tViewConsts = tView.consts;
  const attrs = (0, import_root_effect_scheduler.getConstant)(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, type, name, attrs);
  if (bindingsEnabled) {
    resolveDirectives(tView, lView, tNode, (0, import_root_effect_scheduler.getConstant)(tViewConsts, localRefsIndex), directiveMatcher);
  }
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function directiveHostEndFirstCreatePass(tView, tNode) {
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  registerPostOrderHooks(tView, tNode);
  if ((0, import_root_effect_scheduler.isContentQueryHost)(tNode)) {
    tView.queries.elementEnd(tNode);
  }
}
function domOnlyFirstCreatePass(index, tView, type, name, attrsIndex, localRefsIndex) {
  ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView);
  const tViewConsts = tView.consts;
  const attrs = (0, import_root_effect_scheduler.getConstant)(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, type, name, attrs);
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  if (localRefsIndex != null) {
    const refs = (0, import_root_effect_scheduler.getConstant)(tViewConsts, localRefsIndex);
    tNode.localNames = [];
    for (let i = 0; i < refs.length; i += 2) {
      tNode.localNames.push(refs[i], -1);
    }
  }
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function isListLikeIterable(obj) {
  if (!isJsObject(obj))
    return false;
  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
  Symbol.iterator in obj;
}
function areIterablesEqual(a, b, comparator) {
  const iterator1 = a[Symbol.iterator]();
  const iterator2 = b[Symbol.iterator]();
  while (true) {
    const item1 = iterator1.next();
    const item2 = iterator2.next();
    if (item1.done && item2.done)
      return true;
    if (item1.done || item2.done)
      return false;
    if (!comparator(item1.value, item2.value))
      return false;
  }
}
function iterateListLike(obj, fn) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn(obj[i]);
    }
  } else {
    const iterator = obj[Symbol.iterator]();
    let item;
    while (!(item = iterator.next()).done) {
      fn(item.value);
    }
  }
}
function isJsObject(o) {
  return o !== null && (typeof o === "function" || typeof o === "object");
}
function devModeEqual(a, b) {
  const isListLikeIterableA = isListLikeIterable(a);
  const isListLikeIterableB = isListLikeIterable(b);
  if (isListLikeIterableA && isListLikeIterableB) {
    return areIterablesEqual(a, b, devModeEqual);
  } else {
    const isAObject = a && (typeof a === "object" || typeof a === "function");
    const isBObject = b && (typeof b === "object" || typeof b === "function");
    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
      return true;
    } else {
      return Object.is(a, b);
    }
  }
}
function updateBinding(lView, bindingIndex, value) {
  return lView[bindingIndex] = value;
}
function getBinding(lView, bindingIndex) {
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, bindingIndex);
  ngDevMode && (0, import_root_effect_scheduler.assertNotSame)(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
  return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value) {
  ngDevMode && (0, import_root_effect_scheduler.assertLessThan)(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
  if (value === NO_CHANGE) {
    return false;
  }
  const oldValue = lView[bindingIndex];
  if (Object.is(oldValue, value)) {
    return false;
  } else {
    if (ngDevMode && (0, import_root_effect_scheduler.isInCheckNoChangesMode)()) {
      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
      if (!devModeEqual(oldValueToCompare, value)) {
        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);
      }
      return false;
    }
    lView[bindingIndex] = value;
    return true;
  }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
  const different = bindingUpdated(lView, bindingIndex, exp1);
  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
function wrapListener(tNode, lView, listenerFn) {
  return function wrapListenerIn_markDirtyAndPreventDefault(event) {
    const startView = (0, import_root_effect_scheduler.isComponentHost)(tNode) ? (0, import_root_effect_scheduler.getComponentLViewByIndex)(tNode.index, lView) : lView;
    markViewDirty(
      startView,
      5
      /* NotificationSource.Listener */
    );
    const context = lView[import_root_effect_scheduler.CONTEXT];
    let result = executeListenerWithErrorHandling(lView, context, listenerFn, event);
    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
    while (nextListenerFn) {
      result = executeListenerWithErrorHandling(lView, context, nextListenerFn, event) && result;
      nextListenerFn = nextListenerFn.__ngNextListenerFn__;
    }
    return result;
  };
}
function executeListenerWithErrorHandling(lView, context, listenerFn, e) {
  const prevConsumer = (0, import_signals.setActiveConsumer)(null);
  try {
    profiler(6, context, listenerFn);
    return listenerFn(e) !== false;
  } catch (error) {
    handleUncaughtError(lView, error);
    return false;
  } finally {
    profiler(7, context, listenerFn);
    (0, import_signals.setActiveConsumer)(prevConsumer);
  }
}
function listenToDomEvent(tNode, tView, lView, eventTargetResolver, renderer, eventName, originalListener, wrappedListener) {
  ngDevMode && (0, import_root_effect_scheduler.assertNotSame)(wrappedListener, originalListener, "Expected wrapped and original listeners to be different.");
  const isTNodeDirectiveHost = (0, import_root_effect_scheduler.isDirectiveHost)(tNode);
  let hasCoalesced = false;
  let existingListener = null;
  if (!eventTargetResolver && isTNodeDirectiveHost) {
    existingListener = findExistingListener(tView, lView, eventName, tNode.index);
  }
  if (existingListener !== null) {
    const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
    lastListenerFn.__ngNextListenerFn__ = originalListener;
    existingListener.__ngLastListenerFn__ = originalListener;
    hasCoalesced = true;
  } else {
    const native = (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
    const target = eventTargetResolver ? eventTargetResolver(native) : native;
    stashEventListenerImpl(lView, target, eventName, wrappedListener);
    const cleanupFn = renderer.listen(target, eventName, wrappedListener);
    if (!isAnimationEventType(eventName)) {
      const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver((0, import_root_effect_scheduler.unwrapRNode)(_lView[tNode.index])) : tNode.index;
      storeListenerCleanup(idxOrTargetGetter, tView, lView, eventName, wrappedListener, cleanupFn, false);
    }
  }
  return hasCoalesced;
}
function isAnimationEventType(eventName) {
  return eventName.startsWith("animation") || eventName.startsWith("transition");
}
function findExistingListener(tView, lView, eventName, tNodeIndex) {
  const tCleanup = tView.cleanup;
  if (tCleanup != null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      const cleanupEventName = tCleanup[i];
      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIndex) {
        const lCleanup = lView[import_root_effect_scheduler.CLEANUP];
        const listenerIdxInLCleanup = tCleanup[i + 2];
        return lCleanup && lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
      }
      if (typeof cleanupEventName === "string") {
        i += 2;
      }
    }
  }
  return null;
}
function storeListenerCleanup(indexOrTargetGetter, tView, lView, eventName, listenerFn, cleanup, isOutput) {
  const tCleanup = tView.firstCreatePass ? (0, import_root_effect_scheduler.getOrCreateTViewCleanup)(tView) : null;
  const lCleanup = (0, import_root_effect_scheduler.getOrCreateLViewCleanup)(lView);
  const index = lCleanup.length;
  lCleanup.push(listenerFn, cleanup);
  tCleanup && tCleanup.push(eventName, indexOrTargetGetter, index, (index + 1) * (isOutput ? -1 : 1));
}
function createOutputListener(tNode, lView, listenerFn, targetDef, eventName) {
  const wrappedListener = wrapListener(tNode, lView, listenerFn);
  const hasBound = listenToDirectiveOutput(tNode, lView, targetDef, eventName, wrappedListener);
  if (!hasBound && ngDevMode) {
    throw new import_root_effect_scheduler.RuntimeError(316, `${(0, import_root_effect_scheduler.stringifyForError)(targetDef.type)} does not have an output with a public name of "${eventName}".`);
  }
}
function listenToDirectiveOutput(tNode, lView, target, eventName, listenerFn) {
  var _a2, _b2;
  let hostIndex = null;
  let hostDirectivesStart = null;
  let hostDirectivesEnd = null;
  let hasOutput = false;
  if (ngDevMode && !((_a2 = tNode.directiveToIndex) == null ? void 0 : _a2.has(target.type))) {
    throw new Error(`Node does not have a directive with type ${target.type.name}`);
  }
  const data = tNode.directiveToIndex.get(target.type);
  if (typeof data === "number") {
    hostIndex = data;
  } else {
    [hostIndex, hostDirectivesStart, hostDirectivesEnd] = data;
  }
  if (hostDirectivesStart !== null && hostDirectivesEnd !== null && ((_b2 = tNode.hostDirectiveOutputs) == null ? void 0 : _b2.hasOwnProperty(eventName))) {
    const hostDirectiveOutputs = tNode.hostDirectiveOutputs[eventName];
    for (let i = 0; i < hostDirectiveOutputs.length; i += 2) {
      const index = hostDirectiveOutputs[i];
      if (index >= hostDirectivesStart && index <= hostDirectivesEnd) {
        ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, index);
        hasOutput = true;
        listenToOutput(tNode, lView, index, hostDirectiveOutputs[i + 1], eventName, listenerFn);
      } else if (index > hostDirectivesEnd) {
        break;
      }
    }
  }
  if (target.outputs.hasOwnProperty(eventName)) {
    ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, hostIndex);
    hasOutput = true;
    listenToOutput(tNode, lView, hostIndex, eventName, eventName, listenerFn);
  }
  return hasOutput;
}
function listenToOutput(tNode, lView, directiveIndex, lookupName, eventName, listenerFn) {
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, directiveIndex);
  const instance = lView[directiveIndex];
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const def = tView.data[directiveIndex];
  const propertyName = def.outputs[lookupName];
  const output = instance[propertyName];
  if (ngDevMode && !isOutputSubscribable(output)) {
    throw new Error(`@Output ${propertyName} not initialized in '${instance.constructor.name}'.`);
  }
  const subscription = output.subscribe(listenerFn);
  storeListenerCleanup(tNode.index, tView, lView, eventName, listenerFn, subscription, true);
}
function isOutputSubscribable(value) {
  return value != null && typeof value.subscribe === "function";
}
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
const BINDING = /* @__PURE__ */ Symbol("BINDING");
const INPUT_BINDING_METADATA = { kind: "input", requiredVars: 1 };
const OUTPUT_BINDING_METADATA = { kind: "output", requiredVars: 0 };
function inputBindingUpdate(targetDirectiveIdx, publicName, value) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = lView[import_root_effect_scheduler.TVIEW];
    const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
    const componentLView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(tNode.index, lView);
    markViewDirty(
      componentLView,
      1
      /* NotificationSource.SetInput */
    );
    const targetDef = tView.directiveRegistry[targetDirectiveIdx];
    if (ngDevMode && !targetDef) {
      throw new import_root_effect_scheduler.RuntimeError(315, `Input binding to property "${publicName}" does not have a target.`);
    }
    const hasSet = setDirectiveInput(tNode, tView, lView, targetDef, publicName, value);
    if (ngDevMode) {
      if (!hasSet) {
        throw new import_root_effect_scheduler.RuntimeError(315, `${(0, import_root_effect_scheduler.stringifyForError)(targetDef.type)} does not have an input with a public name of "${publicName}".`);
      }
      storePropertyBindingMetadata(tView.data, tNode, publicName, bindingIndex);
    }
  }
}
function inputBinding(publicName, value) {
  const binding = {
    [BINDING]: INPUT_BINDING_METADATA,
    update: () => inputBindingUpdate(binding.targetIdx, publicName, value())
  };
  return binding;
}
function outputBinding(eventName, listener) {
  const binding = {
    [BINDING]: OUTPUT_BINDING_METADATA,
    create: () => {
      const lView = (0, import_root_effect_scheduler.getLView)();
      const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
      const tView = lView[import_root_effect_scheduler.TVIEW];
      const targetDef = tView.directiveRegistry[binding.targetIdx];
      createOutputListener(tNode, lView, listener, targetDef, eventName);
    }
  };
  return binding;
}
function twoWayBinding(publicName, value) {
  const input = inputBinding(publicName, value);
  const output = outputBinding(publicName + "Change", (eventValue) => value.set(eventValue));
  ngDevMode && (0, import_root_effect_scheduler.assertNotDefined)(input.create, "Unexpected `create` callback in inputBinding");
  ngDevMode && (0, import_root_effect_scheduler.assertNotDefined)(output.update, "Unexpected `update` callback in outputBinding");
  const binding = {
    [BINDING]: {
      kind: "twoWay",
      requiredVars: input[BINDING].requiredVars + output[BINDING].requiredVars
    },
    set targetIdx(idx) {
      input.targetIdx = idx;
      output.targetIdx = idx;
    },
    create: output.create,
    update: input.update
  };
  return binding;
}
class ComponentFactoryResolver extends ComponentFactoryResolver$1 {
  /**
   * @param ngModule The NgModuleRef to which all resolved factories are bound.
   */
  constructor(ngModule) {
    super();
    __publicField(this, "ngModule");
    this.ngModule = ngModule;
  }
  resolveComponentFactory(component) {
    ngDevMode && (0, import_root_effect_scheduler.assertComponentType)(component);
    const componentDef = (0, import_root_effect_scheduler.getComponentDef)(component);
    return new ComponentFactory2(componentDef, this.ngModule);
  }
}
function toInputRefArray(map2) {
  return Object.keys(map2).map((name) => {
    const [propName, flags, transform] = map2[name];
    const inputData = {
      propName,
      templateName: name,
      isSignal: (flags & InputFlags.SignalBased) !== 0
    };
    if (transform) {
      inputData.transform = transform;
    }
    return inputData;
  });
}
function toOutputRefArray(map2) {
  return Object.keys(map2).map((name) => ({ propName: map2[name], templateName: name }));
}
function verifyNotAnOrphanComponent(componentDef) {
  var _a2;
  if ((typeof ngJitMode === "undefined" || ngJitMode) && ((_a2 = componentDef.debugInfo) == null ? void 0 : _a2.forbidOrphanRendering)) {
    if (depsTracker.isOrphanComponent(componentDef.type)) {
      throw new import_root_effect_scheduler.RuntimeError(981, `Orphan component found! Trying to render the component ${(0, import_root_effect_scheduler.debugStringifyTypeForError)(componentDef.type)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);
    }
  }
}
function createRootViewInjector(componentDef, environmentInjector, injector) {
  let realEnvironmentInjector = environmentInjector instanceof import_root_effect_scheduler.EnvironmentInjector ? environmentInjector : environmentInjector == null ? void 0 : environmentInjector.injector;
  if (realEnvironmentInjector && componentDef.getStandaloneInjector !== null) {
    realEnvironmentInjector = componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
  }
  const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
  return rootViewInjector;
}
function createRootLViewEnvironment(rootLViewInjector) {
  const rendererFactory = rootLViewInjector.get(RendererFactory2, null);
  if (rendererFactory === null) {
    throw new import_root_effect_scheduler.RuntimeError(407, ngDevMode && "Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");
  }
  const sanitizer = rootLViewInjector.get(Sanitizer, null);
  const changeDetectionScheduler = rootLViewInjector.get(import_root_effect_scheduler.ChangeDetectionScheduler, null);
  let ngReflect = false;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    ngReflect = rootLViewInjector.get(NG_REFLECT_ATTRS_FLAG, NG_REFLECT_ATTRS_FLAG_DEFAULT);
  }
  return {
    rendererFactory,
    sanitizer,
    changeDetectionScheduler,
    ngReflect
  };
}
function createHostElement(componentDef, renderer) {
  const tagName = inferTagNameFromDefinition(componentDef);
  const namespace = tagName === "svg" ? import_root_effect_scheduler.SVG_NAMESPACE : tagName === "math" ? import_root_effect_scheduler.MATH_ML_NAMESPACE : null;
  return createElementNode(renderer, tagName, namespace);
}
function inferTagNameFromDefinition(componentDef) {
  return (componentDef.selectors[0][0] || "div").toLowerCase();
}
class ComponentFactory2 extends ComponentFactory$1 {
  /**
   * @param componentDef The component definition.
   * @param ngModule The NgModuleRef to which the factory is bound.
   */
  constructor(componentDef, ngModule) {
    var _a2;
    super();
    __publicField(this, "componentDef");
    __publicField(this, "ngModule");
    __publicField(this, "selector");
    __publicField(this, "componentType");
    __publicField(this, "ngContentSelectors");
    __publicField(this, "isBoundToModule");
    __publicField(this, "cachedInputs", null);
    __publicField(this, "cachedOutputs", null);
    this.componentDef = componentDef;
    this.ngModule = ngModule;
    this.componentType = componentDef.type;
    this.selector = stringifyCSSSelectorList(componentDef.selectors);
    this.ngContentSelectors = (_a2 = componentDef.ngContentSelectors) != null ? _a2 : [];
    this.isBoundToModule = !!ngModule;
  }
  get inputs() {
    var _a2;
    (_a2 = this.cachedInputs) != null ? _a2 : this.cachedInputs = toInputRefArray(this.componentDef.inputs);
    return this.cachedInputs;
  }
  get outputs() {
    var _a2;
    (_a2 = this.cachedOutputs) != null ? _a2 : this.cachedOutputs = toOutputRefArray(this.componentDef.outputs);
    return this.cachedOutputs;
  }
  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector, directives, componentBindings) {
    profiler(
      22
      /* ProfilerEvent.DynamicComponentStart */
    );
    const prevConsumer = (0, import_signal.setActiveConsumer)(null);
    try {
      const cmpDef = this.componentDef;
      ngDevMode && verifyNotAnOrphanComponent(cmpDef);
      const rootTView = createRootTView(rootSelectorOrNode, cmpDef, componentBindings, directives);
      const rootViewInjector = createRootViewInjector(cmpDef, environmentInjector || this.ngModule, injector);
      const environment = createRootLViewEnvironment(rootViewInjector);
      const hostRenderer = environment.rendererFactory.createRenderer(null, cmpDef);
      const hostElement = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, cmpDef.encapsulation, rootViewInjector) : createHostElement(cmpDef, hostRenderer);
      const hasInputBindings = (componentBindings == null ? void 0 : componentBindings.some(isInputBinding)) || (directives == null ? void 0 : directives.some((d) => typeof d !== "function" && d.bindings.some(isInputBinding)));
      const rootLView = createLView(null, rootTView, null, 512 | getInitialLViewFlagsFromDef(cmpDef), null, null, environment, hostRenderer, rootViewInjector, null, retrieveHydrationInfo(
        hostElement,
        rootViewInjector,
        true
        /* isRootView */
      ));
      rootLView[import_root_effect_scheduler.HEADER_OFFSET] = hostElement;
      (0, import_root_effect_scheduler.enterView)(rootLView);
      let componentView = null;
      try {
        const hostTNode = directiveHostFirstCreatePass(import_root_effect_scheduler.HEADER_OFFSET, rootLView, 2, "#host", () => rootTView.directiveRegistry, true, 0);
        setupStaticAttributes(hostRenderer, hostElement, hostTNode);
        attachPatchData(hostElement, rootLView);
        createDirectivesInstances(rootTView, rootLView, hostTNode);
        executeContentQueries(rootTView, hostTNode, rootLView);
        directiveHostEndFirstCreatePass(rootTView, hostTNode);
        if (projectableNodes !== void 0) {
          projectNodes(hostTNode, this.ngContentSelectors, projectableNodes);
        }
        componentView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(hostTNode.index, rootLView);
        rootLView[import_root_effect_scheduler.CONTEXT] = componentView[import_root_effect_scheduler.CONTEXT];
        renderView(rootTView, rootLView, null);
      } catch (e) {
        if (componentView !== null) {
          unregisterLView(componentView);
        }
        unregisterLView(rootLView);
        throw e;
      } finally {
        profiler(
          23
          /* ProfilerEvent.DynamicComponentEnd */
        );
        (0, import_root_effect_scheduler.leaveView)();
      }
      return new ComponentRef2(this.componentType, rootLView, !!hasInputBindings);
    } finally {
      (0, import_signal.setActiveConsumer)(prevConsumer);
    }
  }
}
function createRootTView(rootSelectorOrNode, componentDef, componentBindings, directives) {
  const tAttributes = rootSelectorOrNode ? ["ng-version", "20.3.16"] : (
    // Extract attributes and classes from the first selector only to match VE behavior.
    extractAttrsAndClassesFromSelector(componentDef.selectors[0])
  );
  let creationBindings = null;
  let updateBindings = null;
  let varsToAllocate = 0;
  if (componentBindings) {
    for (const binding of componentBindings) {
      varsToAllocate += binding[BINDING].requiredVars;
      if (binding.create) {
        binding.targetIdx = 0;
        (creationBindings != null ? creationBindings : creationBindings = []).push(binding);
      }
      if (binding.update) {
        binding.targetIdx = 0;
        (updateBindings != null ? updateBindings : updateBindings = []).push(binding);
      }
    }
  }
  if (directives) {
    for (let i = 0; i < directives.length; i++) {
      const directive = directives[i];
      if (typeof directive !== "function") {
        for (const binding of directive.bindings) {
          varsToAllocate += binding[BINDING].requiredVars;
          const targetDirectiveIdx = i + 1;
          if (binding.create) {
            binding.targetIdx = targetDirectiveIdx;
            (creationBindings != null ? creationBindings : creationBindings = []).push(binding);
          }
          if (binding.update) {
            binding.targetIdx = targetDirectiveIdx;
            (updateBindings != null ? updateBindings : updateBindings = []).push(binding);
          }
        }
      }
    }
  }
  const directivesToApply = [componentDef];
  if (directives) {
    for (const directive of directives) {
      const directiveType = typeof directive === "function" ? directive : directive.type;
      const directiveDef = ngDevMode ? (0, import_root_effect_scheduler.getDirectiveDefOrThrow)(directiveType) : (0, import_root_effect_scheduler.getDirectiveDef)(directiveType);
      if (ngDevMode && !directiveDef.standalone) {
        throw new import_root_effect_scheduler.RuntimeError(907, `The ${(0, import_root_effect_scheduler.stringifyForError)(directiveType)} directive must be standalone in order to be applied to a dynamically-created component.`);
      }
      directivesToApply.push(directiveDef);
    }
  }
  const rootTView = createTView(0, null, getRootTViewTemplate(creationBindings, updateBindings), 1, varsToAllocate, directivesToApply, null, null, null, [tAttributes], null);
  return rootTView;
}
function getRootTViewTemplate(creationBindings, updateBindings) {
  if (!creationBindings && !updateBindings) {
    return null;
  }
  return (flags) => {
    if (flags & 1 && creationBindings) {
      for (const binding of creationBindings) {
        binding.create();
      }
    }
    if (flags & 2 && updateBindings) {
      for (const binding of updateBindings) {
        binding.update();
      }
    }
  };
}
function isInputBinding(binding) {
  const kind = binding[BINDING].kind;
  return kind === "input" || kind === "twoWay";
}
class ComponentRef2 extends ComponentRef$1 {
  constructor(componentType, _rootLView, _hasInputBindings) {
    super();
    __publicField(this, "_rootLView");
    __publicField(this, "_hasInputBindings");
    __publicField(this, "instance");
    __publicField(this, "hostView");
    __publicField(this, "changeDetectorRef");
    __publicField(this, "componentType");
    __publicField(this, "location");
    __publicField(this, "previousInputValues", null);
    __publicField(this, "_tNode");
    this._rootLView = _rootLView;
    this._hasInputBindings = _hasInputBindings;
    this._tNode = (0, import_root_effect_scheduler.getTNode)(_rootLView[import_root_effect_scheduler.TVIEW], import_root_effect_scheduler.HEADER_OFFSET);
    this.location = createElementRef(this._tNode, _rootLView);
    this.instance = (0, import_root_effect_scheduler.getComponentLViewByIndex)(this._tNode.index, _rootLView)[import_root_effect_scheduler.CONTEXT];
    this.hostView = this.changeDetectorRef = new ViewRef(
      _rootLView,
      void 0
      /* _cdRefInjectingView */
    );
    this.componentType = componentType;
  }
  setInput(name, value) {
    var _a2;
    if (this._hasInputBindings && ngDevMode) {
      throw new import_root_effect_scheduler.RuntimeError(317, "Cannot call `setInput` on a component that is using the `inputBinding` or `twoWayBinding` functions.");
    }
    const tNode = this._tNode;
    (_a2 = this.previousInputValues) != null ? _a2 : this.previousInputValues = /* @__PURE__ */ new Map();
    if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {
      return;
    }
    const lView = this._rootLView;
    const hasSetInput = setAllInputsForProperty(tNode, lView[import_root_effect_scheduler.TVIEW], lView, name, value);
    this.previousInputValues.set(name, value);
    const childComponentLView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(tNode.index, lView);
    markViewDirty(
      childComponentLView,
      1
      /* NotificationSource.SetInput */
    );
    if (ngDevMode && !hasSetInput) {
      const cmpNameForError = (0, import_root_effect_scheduler.stringifyForError)(this.componentType);
      let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
      message += `Make sure that the '${name}' property is declared as an input using the input() or model() function or the @Input() decorator.`;
      reportUnknownPropertyError(message);
    }
  }
  get injector() {
    return new NodeInjector(this._tNode, this._rootLView);
  }
  destroy() {
    this.hostView.destroy();
  }
  onDestroy(callback) {
    this.hostView.onDestroy(callback);
  }
}
function projectNodes(tNode, ngContentSelectors, projectableNodes) {
  const projection = tNode.projection = [];
  for (let i = 0; i < ngContentSelectors.length; i++) {
    const nodesforSlot = projectableNodes[i];
    projection.push(nodesforSlot != null && nodesforSlot.length ? Array.from(nodesforSlot) : null);
  }
}
class ViewContainerRef {
}
/**
 * @internal
 * @nocollapse
 */
__publicField(ViewContainerRef, "__NG_ELEMENT_ID__", injectViewContainerRef);
function injectViewContainerRef() {
  const previousTNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  return createContainerRef(previousTNode, (0, import_root_effect_scheduler.getLView)());
}
const VE_ViewContainerRef = ViewContainerRef;
const R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
  constructor(_lContainer, _hostTNode, _hostLView) {
    super();
    __publicField(this, "_lContainer");
    __publicField(this, "_hostTNode");
    __publicField(this, "_hostLView");
    this._lContainer = _lContainer;
    this._hostTNode = _hostTNode;
    this._hostLView = _hostLView;
  }
  get element() {
    return createElementRef(this._hostTNode, this._hostLView);
  }
  get injector() {
    return new NodeInjector(this._hostTNode, this._hostLView);
  }
  /** @deprecated No replacement */
  get parentInjector() {
    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
    if (hasParentInjector(parentLocation)) {
      const parentView = getParentInjectorView(parentLocation, this._hostLView);
      const injectorIndex = getParentInjectorIndex(parentLocation);
      ngDevMode && (0, import_root_effect_scheduler.assertNodeInjector)(parentView, injectorIndex);
      const parentTNode = parentView[import_root_effect_scheduler.TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ];
      return new NodeInjector(parentTNode, parentView);
    } else {
      return new NodeInjector(null, this._hostLView);
    }
  }
  clear() {
    while (this.length > 0) {
      this.remove(this.length - 1);
    }
  }
  get(index) {
    const viewRefs = getViewRefs(this._lContainer);
    return viewRefs !== null && viewRefs[index] || null;
  }
  get length() {
    return this._lContainer.length - import_root_effect_scheduler.CONTAINER_HEADER_OFFSET;
  }
  createEmbeddedView(templateRef, context, indexOrOptions) {
    let index;
    let injector;
    if (typeof indexOrOptions === "number") {
      index = indexOrOptions;
    } else if (indexOrOptions != null) {
      index = indexOrOptions.index;
      injector = indexOrOptions.injector;
    }
    const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
    const viewRef = templateRef.createEmbeddedViewImpl(context || {}, injector, dehydratedView);
    this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return viewRef;
  }
  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector, directives, bindings) {
    var _a2, _b2, _c2;
    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
    let index;
    if (isComponentFactory) {
      if (ngDevMode) {
        (0, import_root_effect_scheduler.assertEqual)(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
      }
      index = indexOrOptions;
    } else {
      if (ngDevMode) {
        (0, import_root_effect_scheduler.assertDefined)((0, import_root_effect_scheduler.getComponentDef)(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
        (0, import_root_effect_scheduler.assertEqual)(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
      }
      const options = indexOrOptions || {};
      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {
        (0, import_root_effect_scheduler.throwError)(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
      }
      index = options.index;
      injector = options.injector;
      projectableNodes = options.projectableNodes;
      environmentInjector = options.environmentInjector || options.ngModuleRef;
      directives = options.directives;
      bindings = options.bindings;
    }
    const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory2((0, import_root_effect_scheduler.getComponentDef)(componentFactoryOrType));
    const contextInjector = injector || this.parentInjector;
    if (!environmentInjector && componentFactory.ngModule == null) {
      const _injector = isComponentFactory ? contextInjector : this.parentInjector;
      const result = _injector.get(import_root_effect_scheduler.EnvironmentInjector, null);
      if (result) {
        environmentInjector = result;
      }
    }
    const componentDef = (0, import_root_effect_scheduler.getComponentDef)((_a2 = componentFactory.componentType) != null ? _a2 : {});
    const dehydratedView = findMatchingDehydratedView(this._lContainer, (_b2 = componentDef == null ? void 0 : componentDef.id) != null ? _b2 : null);
    const rNode = (_c2 = dehydratedView == null ? void 0 : dehydratedView.firstChild) != null ? _c2 : null;
    const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector, directives, bindings);
    this.insertImpl(componentRef.hostView, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return componentRef;
  }
  insert(viewRef, index) {
    return this.insertImpl(viewRef, index, true);
  }
  insertImpl(viewRef, index, addToDOM) {
    const lView = viewRef._lView;
    if (ngDevMode && viewRef.destroyed) {
      throw new Error("Cannot insert a destroyed View in a ViewContainer!");
    }
    if ((0, import_root_effect_scheduler.viewAttachedToContainer)(lView)) {
      const prevIdx = this.indexOf(viewRef);
      if (prevIdx !== -1) {
        this.detach(prevIdx);
      } else {
        const prevLContainer = lView[import_root_effect_scheduler.PARENT];
        ngDevMode && (0, import_root_effect_scheduler.assertEqual)((0, import_root_effect_scheduler.isLContainer)(prevLContainer), true, "An attached view should have its PARENT point to a container.");
        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[import_root_effect_scheduler.T_HOST], prevLContainer[import_root_effect_scheduler.PARENT]);
        prevVCRef.detach(prevVCRef.indexOf(viewRef));
      }
    }
    const adjustedIdx = this._adjustIndex(index);
    const lContainer = this._lContainer;
    addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);
    viewRef.attachToViewContainerRef();
    (0, import_root_effect_scheduler.addToArray)(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
    return viewRef;
  }
  move(viewRef, newIndex) {
    if (ngDevMode && viewRef.destroyed) {
      throw new Error("Cannot move a destroyed View in a ViewContainer!");
    }
    return this.insert(viewRef, newIndex);
  }
  indexOf(viewRef) {
    const viewRefsArr = getViewRefs(this._lContainer);
    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
  }
  remove(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const detachedView = detachView(this._lContainer, adjustedIdx);
    if (detachedView) {
      (0, import_root_effect_scheduler.removeFromArray)(getOrCreateViewRefs(this._lContainer), adjustedIdx);
      destroyLView(detachedView[import_root_effect_scheduler.TVIEW], detachedView);
    }
  }
  detach(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const view = detachView(this._lContainer, adjustedIdx);
    const wasDetached = view && (0, import_root_effect_scheduler.removeFromArray)(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
    return wasDetached ? new ViewRef(view) : null;
  }
  _adjustIndex(index, shift = 0) {
    if (index == null) {
      return this.length + shift;
    }
    if (ngDevMode) {
      (0, import_root_effect_scheduler.assertGreaterThan)(index, -1, `ViewRef index must be positive, got ${index}`);
      (0, import_root_effect_scheduler.assertLessThan)(index, this.length + 1 + shift, "index");
    }
    return index;
  }
};
function getViewRefs(lContainer) {
  return lContainer[import_root_effect_scheduler.VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
  return lContainer[import_root_effect_scheduler.VIEW_REFS] || (lContainer[import_root_effect_scheduler.VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
  ngDevMode && assertTNodeType(
    hostTNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  let lContainer;
  const slotValue = hostLView[hostTNode.index];
  if ((0, import_root_effect_scheduler.isLContainer)(slotValue)) {
    lContainer = slotValue;
  } else {
    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
    hostLView[hostTNode.index] = lContainer;
    addToEndOfViewTree(hostLView, lContainer);
  }
  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function insertAnchorNode(hostLView, hostTNode) {
  const renderer = hostLView[import_root_effect_scheduler.RENDERER];
  const commentNode = renderer.createComment(ngDevMode ? "container" : "");
  const hostNative = (0, import_root_effect_scheduler.getNativeByTNode)(hostTNode, hostLView);
  const parentOfHostNative = renderer.parentNode(hostNative);
  nativeInsertBefore(renderer, parentOfHostNative, commentNode, renderer.nextSibling(hostNative), false);
  return commentNode;
}
let _locateOrCreateAnchorNode = createAnchorNode;
let _populateDehydratedViewsInLContainer = () => false;
function populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {
  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);
}
function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (lContainer[import_root_effect_scheduler.NATIVE])
    return;
  let commentNode;
  if (hostTNode.type & 8) {
    commentNode = (0, import_root_effect_scheduler.unwrapRNode)(slotValue);
  } else {
    commentNode = insertAnchorNode(hostLView, hostTNode);
  }
  lContainer[import_root_effect_scheduler.NATIVE] = commentNode;
}
function populateDehydratedViewsInLContainerImpl(lContainer, tNode, hostLView) {
  var _a2;
  if (lContainer[import_root_effect_scheduler.NATIVE] && lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS]) {
    return true;
  }
  const hydrationInfo = hostLView[import_root_effect_scheduler.HYDRATION];
  const noOffsetIndex = tNode.index - import_root_effect_scheduler.HEADER_OFFSET;
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock(tNode) || isDisconnectedNode$1(hydrationInfo, noOffsetIndex);
  if (isNodeCreationMode) {
    return false;
  }
  const currentRNode = getSegmentHead(hydrationInfo, noOffsetIndex);
  const serializedViews = (_a2 = hydrationInfo.data[CONTAINERS]) == null ? void 0 : _a2[noOffsetIndex];
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(serializedViews, "Unexpected state: no hydration info available for a given TNode, which represents a view container.");
  const [commentNode, dehydratedViews] = locateDehydratedViewsInContainer(currentRNode, serializedViews);
  if (ngDevMode) {
    validateMatchingNode(commentNode, Node.COMMENT_NODE, null, hostLView, tNode, true);
    markRNodeAsClaimedByHydration(commentNode, false);
  }
  lContainer[import_root_effect_scheduler.NATIVE] = commentNode;
  lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS] = dehydratedViews;
  return true;
}
function locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (!_populateDehydratedViewsInLContainer(lContainer, hostTNode, hostLView)) {
    createAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  }
}
function enableLocateOrCreateContainerRefImpl() {
  _locateOrCreateAnchorNode = locateOrCreateAnchorNode;
  _populateDehydratedViewsInLContainer = populateDehydratedViewsInLContainerImpl;
}
class LQuery_ {
  constructor(queryList) {
    __publicField(this, "queryList");
    __publicField(this, "matches", null);
    this.queryList = queryList;
  }
  clone() {
    return new LQuery_(this.queryList);
  }
  setDirty() {
    this.queryList.setDirty();
  }
}
class LQueries_ {
  constructor(queries = []) {
    __publicField(this, "queries");
    this.queries = queries;
  }
  createEmbeddedView(tView) {
    const tQueries = tView.queries;
    if (tQueries !== null) {
      const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
      const viewLQueries = [];
      for (let i = 0; i < noOfInheritedQueries; i++) {
        const tQuery = tQueries.getByIndex(i);
        const parentLQuery = this.queries[tQuery.indexInDeclarationView];
        viewLQueries.push(parentLQuery.clone());
      }
      return new LQueries_(viewLQueries);
    }
    return null;
  }
  insertView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  detachView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  finishViewCreation(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  dirtyQueriesWithMatches(tView) {
    for (let i = 0; i < this.queries.length; i++) {
      if (getTQuery(tView, i).matches !== null) {
        this.queries[i].setDirty();
      }
    }
  }
}
class TQueryMetadata_ {
  constructor(predicate, flags, read = null) {
    __publicField(this, "flags");
    __publicField(this, "read");
    __publicField(this, "predicate");
    this.flags = flags;
    this.read = read;
    if (typeof predicate === "string") {
      this.predicate = splitQueryMultiSelectors(predicate);
    } else {
      this.predicate = predicate;
    }
  }
}
class TQueries_ {
  constructor(queries = []) {
    __publicField(this, "queries");
    this.queries = queries;
  }
  elementStart(tView, tNode) {
    ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView, "Queries should collect results on the first template pass only");
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementStart(tView, tNode);
    }
  }
  elementEnd(tNode) {
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementEnd(tNode);
    }
  }
  embeddedTView(tNode) {
    let queriesForTemplateRef = null;
    for (let i = 0; i < this.length; i++) {
      const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
      const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
      if (tqueryClone) {
        tqueryClone.indexInDeclarationView = i;
        if (queriesForTemplateRef !== null) {
          queriesForTemplateRef.push(tqueryClone);
        } else {
          queriesForTemplateRef = [tqueryClone];
        }
      }
    }
    return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;
  }
  template(tView, tNode) {
    ngDevMode && (0, import_root_effect_scheduler.assertFirstCreatePass)(tView, "Queries should collect results on the first template pass only");
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].template(tView, tNode);
    }
  }
  getByIndex(index) {
    ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(this.queries, index);
    return this.queries[index];
  }
  get length() {
    return this.queries.length;
  }
  track(tquery) {
    this.queries.push(tquery);
  }
}
class TQuery_ {
  constructor(metadata, nodeIndex = -1) {
    __publicField(this, "metadata");
    __publicField(this, "matches", null);
    __publicField(this, "indexInDeclarationView", -1);
    __publicField(this, "crossesNgTemplate", false);
    /**
     * A node index on which a query was declared (-1 for view queries and ones inherited from the
     * declaration template). We use this index (alongside with _appliesToNextNode flag) to know
     * when to apply content queries to elements in a template.
     */
    __publicField(this, "_declarationNodeIndex");
    /**
     * A flag indicating if a given query still applies to nodes it is crossing. We use this flag
     * (alongside with _declarationNodeIndex) to know when to stop applying content queries to
     * elements in a template.
     */
    __publicField(this, "_appliesToNextNode", true);
    this.metadata = metadata;
    this._declarationNodeIndex = nodeIndex;
  }
  elementStart(tView, tNode) {
    if (this.isApplyingToNode(tNode)) {
      this.matchTNode(tView, tNode);
    }
  }
  elementEnd(tNode) {
    if (this._declarationNodeIndex === tNode.index) {
      this._appliesToNextNode = false;
    }
  }
  template(tView, tNode) {
    this.elementStart(tView, tNode);
  }
  embeddedTView(tNode, childQueryIndex) {
    if (this.isApplyingToNode(tNode)) {
      this.crossesNgTemplate = true;
      this.addMatch(-tNode.index, childQueryIndex);
      return new TQuery_(this.metadata);
    }
    return null;
  }
  isApplyingToNode(tNode) {
    if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
      const declarationNodeIdx = this._declarationNodeIndex;
      let parent = tNode.parent;
      while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
        parent = parent.parent;
      }
      return declarationNodeIdx === (parent !== null ? parent.index : -1);
    }
    return this._appliesToNextNode;
  }
  matchTNode(tView, tNode) {
    const predicate = this.metadata.predicate;
    if (Array.isArray(predicate)) {
      for (let i = 0; i < predicate.length; i++) {
        const name = predicate[i];
        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
      }
    } else {
      if (predicate === TemplateRef) {
        if (tNode.type & 4) {
          this.matchTNodeWithReadOption(tView, tNode, -1);
        }
      } else {
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
      }
    }
  }
  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
    if (nodeMatchIdx !== null) {
      const read = this.metadata.read;
      if (read !== null) {
        if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
          this.addMatch(tNode.index, -2);
        } else {
          const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
          if (directiveOrProviderIdx !== null) {
            this.addMatch(tNode.index, directiveOrProviderIdx);
          }
        }
      } else {
        this.addMatch(tNode.index, nodeMatchIdx);
      }
    }
  }
  addMatch(tNodeIdx, matchIdx) {
    if (this.matches === null) {
      this.matches = [tNodeIdx, matchIdx];
    } else {
      this.matches.push(tNodeIdx, matchIdx);
    }
  }
}
function getIdxOfMatchingSelector(tNode, selector) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    for (let i = 0; i < localNames.length; i += 2) {
      if (localNames[i] === selector) {
        return localNames[i + 1];
      }
    }
  }
  return null;
}
function createResultByTNodeType(tNode, currentView) {
  if (tNode.type & (3 | 8)) {
    return createElementRef(tNode, currentView);
  } else if (tNode.type & 4) {
    return createTemplateRef(tNode, currentView);
  }
  return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
  if (matchingIdx === -1) {
    return createResultByTNodeType(tNode, lView);
  } else if (matchingIdx === -2) {
    return createSpecialToken(lView, tNode, read);
  } else {
    return getNodeInjectable(lView, lView[import_root_effect_scheduler.TVIEW], matchingIdx, tNode);
  }
}
function createSpecialToken(lView, tNode, read) {
  if (read === ElementRef) {
    return createElementRef(tNode, lView);
  } else if (read === TemplateRef) {
    return createTemplateRef(tNode, lView);
  } else if (read === ViewContainerRef) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12
      /* TNodeType.AnyContainer */
    );
    return createContainerRef(tNode, lView);
  } else {
    ngDevMode && (0, import_root_effect_scheduler.throwError)(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${(0, import_root_effect_scheduler.stringify)(read)}.`);
  }
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
  const lQuery = lView[import_root_effect_scheduler.QUERIES].queries[queryIndex];
  if (lQuery.matches === null) {
    const tViewData = tView.data;
    const tQueryMatches = tQuery.matches;
    const result = [];
    for (let i = 0; tQueryMatches !== null && i < tQueryMatches.length; i += 2) {
      const matchedNodeIdx = tQueryMatches[i];
      if (matchedNodeIdx < 0) {
        result.push(null);
      } else {
        ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(tViewData, matchedNodeIdx);
        const tNode = tViewData[matchedNodeIdx];
        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
      }
    }
    lQuery.matches = result;
  }
  return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
  const tQuery = tView.queries.getByIndex(queryIndex);
  const tQueryMatches = tQuery.matches;
  if (tQueryMatches !== null) {
    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
    for (let i = 0; i < tQueryMatches.length; i += 2) {
      const tNodeIdx = tQueryMatches[i];
      if (tNodeIdx > 0) {
        result.push(lViewResults[i / 2]);
      } else {
        const childQueryIndex = tQueryMatches[i + 1];
        const declarationLContainer = lView[-tNodeIdx];
        ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(declarationLContainer);
        for (let i2 = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {
          const embeddedLView = declarationLContainer[i2];
          if (embeddedLView[import_root_effect_scheduler.DECLARATION_LCONTAINER] === embeddedLView[import_root_effect_scheduler.PARENT]) {
            collectQueryResults(embeddedLView[import_root_effect_scheduler.TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
        if (declarationLContainer[import_root_effect_scheduler.MOVED_VIEWS] !== null) {
          const embeddedLViews = declarationLContainer[import_root_effect_scheduler.MOVED_VIEWS];
          for (let i2 = 0; i2 < embeddedLViews.length; i2++) {
            const embeddedLView = embeddedLViews[i2];
            collectQueryResults(embeddedLView[import_root_effect_scheduler.TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
      }
    }
  }
  return result;
}
function loadQueryInternal(lView, queryIndex) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(lView[import_root_effect_scheduler.QUERIES], "LQueries should be defined when trying to load a query");
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView[import_root_effect_scheduler.QUERIES].queries, queryIndex);
  return lView[import_root_effect_scheduler.QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
  var _a2, _b2;
  const queryList = new QueryList(
    (flags & 4) === 4
    /* QueryFlags.emitDistinctChangesOnly */
  );
  (0, import_root_effect_scheduler.storeCleanupWithContext)(tView, lView, queryList, queryList.destroy);
  const lQueries = ((_b2 = lView[_a2 = import_root_effect_scheduler.QUERIES]) != null ? _b2 : lView[_a2] = new LQueries_()).queries;
  return lQueries.push(new LQuery_(queryList)) - 1;
}
function createViewQuery(predicate, flags, read) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(flags, "Expecting flags");
  const tView = (0, import_root_effect_scheduler.getTView)();
  if (tView.firstCreatePass) {
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
    if ((flags & 2) === 2) {
      tView.staticViewQueries = true;
    }
  }
  return createLQuery(tView, (0, import_root_effect_scheduler.getLView)(), flags);
}
function createContentQuery(directiveIndex, predicate, flags, read) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(flags, "Expecting flags");
  const tView = (0, import_root_effect_scheduler.getTView)();
  if (tView.firstCreatePass) {
    const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
    saveContentQueryAndDirectiveIndex(tView, directiveIndex);
    if ((flags & 2) === 2) {
      tView.staticContentQueries = true;
    }
  }
  return createLQuery(tView, (0, import_root_effect_scheduler.getLView)(), flags);
}
function splitQueryMultiSelectors(locator) {
  return locator.split(",").map((s) => s.trim());
}
function createTQuery(tView, metadata, nodeIndex) {
  if (tView.queries === null)
    tView.queries = new TQueries_();
  tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
  if (directiveIndex !== lastSavedDirectiveIndex) {
    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
  }
}
function getTQuery(tView, index) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(tView.queries, "TQueries must be defined to retrieve a TQuery");
  return tView.queries.getByIndex(index);
}
function getQueryResults(lView, queryIndex) {
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const tQuery = getTQuery(tView, queryIndex);
  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
}
function createQuerySignalFn(firstOnly, required, opts) {
  let node;
  const signalFn = (0, import_signal.createComputed)(() => {
    node._dirtyCounter();
    const value = refreshSignalQuery(node, firstOnly);
    if (required && value === void 0) {
      throw new import_root_effect_scheduler.RuntimeError(-951, ngDevMode && "Child query result is required but no value is available.");
    }
    return value;
  });
  node = signalFn[import_signal.SIGNAL];
  node._dirtyCounter = (0, import_root_effect_scheduler.signal)(0);
  node._flatValue = void 0;
  if (ngDevMode) {
    signalFn.toString = () => `[Query Signal]`;
    node.debugName = opts == null ? void 0 : opts.debugName;
  }
  return signalFn;
}
function createSingleResultOptionalQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    false,
    opts
  );
}
function createSingleResultRequiredQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    true,
    opts
  );
}
function createMultiResultQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    false,
    /* required */
    false,
    opts
  );
}
function bindQueryToSignal(target, queryIndex) {
  const node = target[import_signal.SIGNAL];
  node._lView = (0, import_root_effect_scheduler.getLView)();
  node._queryIndex = queryIndex;
  node._queryList = loadQueryInternal(node._lView, queryIndex);
  node._queryList.onDirty(() => node._dirtyCounter.update((v) => v + 1));
}
function refreshSignalQuery(node, firstOnly) {
  const lView = node._lView;
  const queryIndex = node._queryIndex;
  if (lView === void 0 || queryIndex === void 0 || lView[import_root_effect_scheduler.FLAGS] & 4) {
    return firstOnly ? void 0 : import_root_effect_scheduler.EMPTY_ARRAY;
  }
  const queryList = loadQueryInternal(lView, queryIndex);
  const results = getQueryResults(lView, queryIndex);
  queryList.reset(results, unwrapElementRef);
  if (firstOnly) {
    return queryList.first;
  } else {
    const resultChanged = queryList._changesDetected;
    if (resultChanged || node._flatValue === void 0) {
      return node._flatValue = queryList.toArray();
    }
    return node._flatValue;
  }
}
function resolveComponentResources(resourceResolver) {
  const componentResolved = [];
  const urlMap = /* @__PURE__ */ new Map();
  function cachedResourceResolve(url) {
    let promise = urlMap.get(url);
    if (!promise) {
      const resp = resourceResolver(url);
      urlMap.set(url, promise = resp.then((res) => unwrapResponse(url, res)));
    }
    return promise;
  }
  componentResourceResolutionQueue.forEach((component, type) => {
    var _a2, _b2;
    const promises = [];
    if (component.templateUrl) {
      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
        component.template = template;
      }));
    }
    const styles = typeof component.styles === "string" ? [component.styles] : component.styles || [];
    component.styles = styles;
    if (component.styleUrl && ((_a2 = component.styleUrls) == null ? void 0 : _a2.length)) {
      throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");
    } else if ((_b2 = component.styleUrls) == null ? void 0 : _b2.length) {
      const styleOffset = component.styles.length;
      const styleUrls = component.styleUrls;
      component.styleUrls.forEach((styleUrl, index) => {
        styles.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
    } else if (component.styleUrl) {
      promises.push(cachedResourceResolve(component.styleUrl).then((style) => {
        styles.push(style);
        component.styleUrl = void 0;
      }));
    }
    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
    componentResolved.push(fullyResolved);
  });
  clearResolutionOfComponentResourcesQueue();
  return Promise.all(componentResolved).then(() => void 0);
}
let componentResourceResolutionQueue = /* @__PURE__ */ new Map();
const componentDefPendingResolution = /* @__PURE__ */ new Set();
function maybeQueueResolutionOfComponentResources(type, metadata) {
  if (componentNeedsResolution(metadata)) {
    componentResourceResolutionQueue.set(type, metadata);
    componentDefPendingResolution.add(type);
  }
}
function isComponentDefPendingResolution(type) {
  return componentDefPendingResolution.has(type);
}
function componentNeedsResolution(component) {
  return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length || component.styleUrl);
}
function clearResolutionOfComponentResourcesQueue() {
  const old = componentResourceResolutionQueue;
  componentResourceResolutionQueue = /* @__PURE__ */ new Map();
  return old;
}
function restoreComponentResolutionQueue(queue) {
  componentDefPendingResolution.clear();
  queue.forEach((_, type) => componentDefPendingResolution.add(type));
  componentResourceResolutionQueue = queue;
}
function isComponentResourceResolutionQueueEmpty() {
  return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(url, response) {
  if (typeof response === "string") {
    return response;
  }
  if (response.status !== void 0 && response.status !== 200) {
    return Promise.reject(new import_root_effect_scheduler.RuntimeError(918, ngDevMode && `Could not load resource: ${url}. Response status: ${response.status}`));
  }
  return response.text();
}
function componentDefResolved(type) {
  componentDefPendingResolution.delete(type);
}
const modules = /* @__PURE__ */ new Map();
let checkForDuplicateNgModules = true;
function assertSameOrNotExisting(id, type, incoming) {
  if (type && type !== incoming && checkForDuplicateNgModules) {
    throw new Error(`Duplicate module registered for ${id} - ${(0, import_root_effect_scheduler.stringify)(type)} vs ${(0, import_root_effect_scheduler.stringify)(type.name)}`);
  }
}
function registerNgModuleType(ngModuleType, id) {
  const existing = modules.get(id) || null;
  assertSameOrNotExisting(id, existing, ngModuleType);
  modules.set(id, ngModuleType);
}
function getRegisteredNgModuleType(id) {
  return modules.get(id);
}
function setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {
  checkForDuplicateNgModules = !allowDuplicates;
}
let NgModuleRef$1 = class NgModuleRef {
};
let NgModuleFactory$1 = class NgModuleFactory {
};
function createNgModule(ngModule, parentInjector) {
  return new NgModuleRef2(ngModule, parentInjector != null ? parentInjector : null, []);
}
const createNgModuleRef = createNgModule;
class NgModuleRef2 extends NgModuleRef$1 {
  constructor(ngModuleType, _parent, additionalProviders, runInjectorInitializers = true) {
    super();
    __publicField(this, "ngModuleType");
    __publicField(this, "_parent");
    // tslint:disable-next-line:require-internal-with-underscore
    __publicField(this, "_bootstrapComponents", []);
    __publicField(this, "_r3Injector");
    __publicField(this, "instance");
    __publicField(this, "destroyCbs", []);
    // When bootstrapping a module we have a dependency graph that looks like this:
    // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the
    // module being resolved tries to inject the ComponentFactoryResolver, it'll create a
    // circular dependency which will result in a runtime error, because the injector doesn't
    // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves
    // and providing it, rather than letting the injector resolve it.
    __publicField(this, "componentFactoryResolver", new ComponentFactoryResolver(this));
    this.ngModuleType = ngModuleType;
    this._parent = _parent;
    const ngModuleDef = (0, import_root_effect_scheduler.getNgModuleDef)(ngModuleType);
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(ngModuleDef, `NgModule '${(0, import_root_effect_scheduler.stringify)(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
    this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
    this._r3Injector = (0, import_root_effect_scheduler.createInjectorWithoutInjectorInstances)(ngModuleType, _parent, [
      { provide: NgModuleRef$1, useValue: this },
      {
        provide: ComponentFactoryResolver$1,
        useValue: this.componentFactoryResolver
      },
      ...additionalProviders
    ], (0, import_root_effect_scheduler.stringify)(ngModuleType), /* @__PURE__ */ new Set(["environment"]));
    if (runInjectorInitializers) {
      this.resolveInjectorInitializers();
    }
  }
  resolveInjectorInitializers() {
    this._r3Injector.resolveInjectorInitializers();
    this.instance = this._r3Injector.get(this.ngModuleType);
  }
  get injector() {
    return this._r3Injector;
  }
  destroy() {
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(this.destroyCbs, "NgModule already destroyed");
    const injector = this._r3Injector;
    !injector.destroyed && injector.destroy();
    this.destroyCbs.forEach((fn) => fn());
    this.destroyCbs = null;
  }
  onDestroy(callback) {
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(this.destroyCbs, "NgModule already destroyed");
    this.destroyCbs.push(callback);
  }
}
class NgModuleFactory2 extends NgModuleFactory$1 {
  constructor(moduleType) {
    super();
    __publicField(this, "moduleType");
    this.moduleType = moduleType;
  }
  create(parentInjector) {
    return new NgModuleRef2(this.moduleType, parentInjector, []);
  }
}
function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
  return new NgModuleRef2(moduleType, parentInjector, additionalProviders, false);
}
class EnvironmentNgModuleRefAdapter extends NgModuleRef$1 {
  constructor(config) {
    super();
    __publicField(this, "injector");
    __publicField(this, "componentFactoryResolver", new ComponentFactoryResolver(this));
    __publicField(this, "instance", null);
    const injector = new import_root_effect_scheduler.R3Injector([
      ...config.providers,
      { provide: NgModuleRef$1, useValue: this },
      { provide: ComponentFactoryResolver$1, useValue: this.componentFactoryResolver }
    ], config.parent || (0, import_root_effect_scheduler.getNullInjector)(), config.debugName, /* @__PURE__ */ new Set(["environment"]));
    this.injector = injector;
    if (config.runEnvironmentInitializers) {
      injector.resolveInjectorInitializers();
    }
  }
  destroy() {
    this.injector.destroy();
  }
  onDestroy(callback) {
    this.injector.onDestroy(callback);
  }
}
function createEnvironmentInjector(providers, parent, debugName = null) {
  const adapter = new EnvironmentNgModuleRefAdapter({
    providers,
    parent,
    debugName,
    runEnvironmentInitializers: true
  });
  return adapter.injector;
}
const _StandaloneService = class _StandaloneService {
  constructor(_injector) {
    __publicField(this, "_injector");
    __publicField(this, "cachedInjectors", /* @__PURE__ */ new Map());
    this._injector = _injector;
  }
  getOrCreateStandaloneInjector(componentDef) {
    if (!componentDef.standalone) {
      return null;
    }
    if (!this.cachedInjectors.has(componentDef)) {
      const providers = (0, import_root_effect_scheduler.internalImportProvidersFrom)(false, componentDef.type);
      const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;
      this.cachedInjectors.set(componentDef, standaloneInjector);
    }
    return this.cachedInjectors.get(componentDef);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
};
/** @nocollapse */
__publicField(
  _StandaloneService,
  "\u0275prov",
  /** @pureOrBreakMyCode */
  /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({
    token: _StandaloneService,
    providedIn: "environment",
    factory: () => new _StandaloneService((0, import_root_effect_scheduler.\u0275\u0275inject)(import_root_effect_scheduler.EnvironmentInjector))
  })
);
let StandaloneService = _StandaloneService;
function \u0275\u0275defineComponent(componentDefinition) {
  return noSideEffects(() => {
    var _a2;
    (typeof ngDevMode === "undefined" || ngDevMode) && (0, import_root_effect_scheduler.initNgDevMode)();
    const baseDef = getNgDirectiveDef(componentDefinition);
    const def = __spreadProps(__spreadValues({}, baseDef), {
      decls: componentDefinition.decls,
      vars: componentDefinition.vars,
      template: componentDefinition.template,
      consts: componentDefinition.consts || null,
      ngContentSelectors: componentDefinition.ngContentSelectors,
      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
      directiveDefs: null,
      // assigned in noSideEffects
      pipeDefs: null,
      // assigned in noSideEffects
      dependencies: baseDef.standalone && componentDefinition.dependencies || null,
      getStandaloneInjector: baseDef.standalone ? (parentInjector) => {
        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(def);
      } : null,
      getExternalStyles: null,
      signals: (_a2 = componentDefinition.signals) != null ? _a2 : false,
      data: componentDefinition.data || {},
      encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,
      styles: componentDefinition.styles || import_root_effect_scheduler.EMPTY_ARRAY,
      _: null,
      schemas: componentDefinition.schemas || null,
      tView: null,
      id: ""
    });
    if (baseDef.standalone) {
      performanceMarkFeature("NgStandalone");
    }
    initFeatures(def);
    const dependencies = componentDefinition.dependencies;
    def.directiveDefs = extractDefListOrFactory(dependencies, extractDirectiveDef);
    def.pipeDefs = extractDefListOrFactory(dependencies, import_root_effect_scheduler.getPipeDef);
    def.id = getComponentId(def);
    return def;
  });
}
function extractDirectiveDef(type) {
  return (0, import_root_effect_scheduler.getComponentDef)(type) || (0, import_root_effect_scheduler.getDirectiveDef)(type);
}
function \u0275\u0275defineNgModule(def) {
  return noSideEffects(() => {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || import_root_effect_scheduler.EMPTY_ARRAY,
      declarations: def.declarations || import_root_effect_scheduler.EMPTY_ARRAY,
      imports: def.imports || import_root_effect_scheduler.EMPTY_ARRAY,
      exports: def.exports || import_root_effect_scheduler.EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    return res;
  });
}
function parseAndConvertInputsForDefinition(obj, declaredInputs) {
  var _a2;
  if (obj == null)
    return import_root_effect_scheduler.EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      const value = obj[minifiedKey];
      let publicName;
      let declaredName;
      let inputFlags;
      let transform;
      if (Array.isArray(value)) {
        inputFlags = value[0];
        publicName = value[1];
        declaredName = (_a2 = value[2]) != null ? _a2 : publicName;
        transform = value[3] || null;
      } else {
        publicName = value;
        declaredName = value;
        inputFlags = InputFlags.None;
        transform = null;
      }
      newLookup[publicName] = [minifiedKey, inputFlags, transform];
      declaredInputs[publicName] = declaredName;
    }
  }
  return newLookup;
}
function parseAndConvertOutputsForDefinition(obj) {
  if (obj == null)
    return import_root_effect_scheduler.EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      newLookup[obj[minifiedKey]] = minifiedKey;
    }
  }
  return newLookup;
}
function \u0275\u0275defineDirective(directiveDefinition) {
  return noSideEffects(() => {
    const def = getNgDirectiveDef(directiveDefinition);
    initFeatures(def);
    return def;
  });
}
function \u0275\u0275definePipe(pipeDef) {
  var _a2;
  return {
    type: pipeDef.type,
    name: pipeDef.name,
    factory: null,
    pure: pipeDef.pure !== false,
    standalone: (_a2 = pipeDef.standalone) != null ? _a2 : true,
    onDestroy: pipeDef.type.prototype.ngOnDestroy || null
  };
}
function getNgDirectiveDef(directiveDefinition) {
  var _a2;
  const declaredInputs = {};
  return {
    type: directiveDefinition.type,
    providersResolver: null,
    factory: null,
    hostBindings: directiveDefinition.hostBindings || null,
    hostVars: directiveDefinition.hostVars || 0,
    hostAttrs: directiveDefinition.hostAttrs || null,
    contentQueries: directiveDefinition.contentQueries || null,
    declaredInputs,
    inputConfig: directiveDefinition.inputs || import_root_effect_scheduler.EMPTY_OBJ,
    exportAs: directiveDefinition.exportAs || null,
    standalone: (_a2 = directiveDefinition.standalone) != null ? _a2 : true,
    signals: directiveDefinition.signals === true,
    selectors: directiveDefinition.selectors || import_root_effect_scheduler.EMPTY_ARRAY,
    viewQuery: directiveDefinition.viewQuery || null,
    features: directiveDefinition.features || null,
    setInput: null,
    resolveHostDirectives: null,
    hostDirectives: null,
    inputs: parseAndConvertInputsForDefinition(directiveDefinition.inputs, declaredInputs),
    outputs: parseAndConvertOutputsForDefinition(directiveDefinition.outputs),
    debugInfo: null
  };
}
function initFeatures(definition) {
  var _a2;
  (_a2 = definition.features) == null ? void 0 : _a2.forEach((fn) => fn(definition));
}
function extractDefListOrFactory(dependencies, defExtractor) {
  if (!dependencies) {
    return null;
  }
  return () => {
    const resolvedDependencies = typeof dependencies === "function" ? dependencies() : dependencies;
    const result = [];
    for (const dep of resolvedDependencies) {
      const definition = defExtractor(dep);
      if (definition !== null) {
        result.push(definition);
      }
    }
    return result;
  };
}
const GENERATED_COMP_IDS = /* @__PURE__ */ new Map();
function getComponentId(componentDef) {
  let hash = 0;
  const componentDefConsts = typeof componentDef.consts === "function" ? "" : componentDef.consts;
  const hashSelectors = [
    componentDef.selectors,
    componentDef.ngContentSelectors,
    componentDef.hostVars,
    componentDef.hostAttrs,
    componentDefConsts,
    componentDef.vars,
    componentDef.decls,
    componentDef.encapsulation,
    componentDef.standalone,
    componentDef.signals,
    componentDef.exportAs,
    JSON.stringify(componentDef.inputs),
    JSON.stringify(componentDef.outputs),
    // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not
    // match in the server and browser bundles.
    Object.getOwnPropertyNames(componentDef.type.prototype),
    !!componentDef.contentQueries,
    !!componentDef.viewQuery
  ];
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    for (const item of hashSelectors) {
      (0, import_root_effect_scheduler.assertNotEqual)(typeof item, "function", "Internal error: attempting to use a function in component id computation logic.");
    }
  }
  for (const char of hashSelectors.join("|")) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  const compId = "c" + hash;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && // Skip the check on the server since we can't guarantee the same component instance between
  // requests. Note that we can't use DI to check if we're on the server, because the component
  // hasn't been instantiated yet.
  (typeof ngServerMode === "undefined" || !ngServerMode)) {
    if (GENERATED_COMP_IDS.has(compId)) {
      const previousCompDefType = GENERATED_COMP_IDS.get(compId);
      if (previousCompDefType !== componentDef.type) {
        console.warn((0, import_root_effect_scheduler.formatRuntimeError)(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
      }
    } else {
      GENERATED_COMP_IDS.set(compId, componentDef.type);
    }
  }
  return compId;
}
function getSuperType(type) {
  return Object.getPrototypeOf(type.prototype).constructor;
}
function \u0275\u0275InheritDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let shouldInheritFields = true;
  const inheritanceChain = [definition];
  while (superType) {
    let superDef = void 0;
    if ((0, import_root_effect_scheduler.isComponentDef)(definition)) {
      superDef = superType.\u0275cmp || superType.\u0275dir;
    } else {
      if (superType.\u0275cmp) {
        throw new import_root_effect_scheduler.RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${(0, import_root_effect_scheduler.stringifyForError)(definition.type)} is attempting to extend component ${(0, import_root_effect_scheduler.stringifyForError)(superType)}`);
      }
      superDef = superType.\u0275dir;
    }
    if (superDef) {
      if (shouldInheritFields) {
        inheritanceChain.push(superDef);
        const writeableDef = definition;
        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        const superHostBindings = superDef.hostBindings;
        superHostBindings && inheritHostBindings(definition, superHostBindings);
        const superViewQuery = superDef.viewQuery;
        const superContentQueries = superDef.contentQueries;
        superViewQuery && inheritViewQuery(definition, superViewQuery);
        superContentQueries && inheritContentQueries(definition, superContentQueries);
        mergeInputsWithTransforms(definition, superDef);
        (0, import_root_effect_scheduler.fillProperties)(definition.outputs, superDef.outputs);
        if ((0, import_root_effect_scheduler.isComponentDef)(superDef) && superDef.data.animation) {
          const defData = definition.data;
          defData.animation = (defData.animation || []).concat(superDef.data.animation);
        }
      }
      const features = superDef.features;
      if (features) {
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          if (feature && feature.ngInherit) {
            feature(definition);
          }
          if (feature === \u0275\u0275InheritDefinitionFeature) {
            shouldInheritFields = false;
          }
        }
      }
    }
    superType = Object.getPrototypeOf(superType);
  }
  mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeInputsWithTransforms(target, source) {
  for (const key in source.inputs) {
    if (!source.inputs.hasOwnProperty(key)) {
      continue;
    }
    if (target.inputs.hasOwnProperty(key)) {
      continue;
    }
    const value = source.inputs[key];
    if (value !== void 0) {
      target.inputs[key] = value;
      target.declaredInputs[key] = source.declaredInputs[key];
    }
  }
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
  let hostVars = 0;
  let hostAttrs = null;
  for (let i = inheritanceChain.length - 1; i >= 0; i--) {
    const def = inheritanceChain[i];
    def.hostVars = hostVars += def.hostVars;
    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
  }
}
function maybeUnwrapEmpty(value) {
  if (value === import_root_effect_scheduler.EMPTY_OBJ) {
    return {};
  } else if (value === import_root_effect_scheduler.EMPTY_ARRAY) {
    return [];
  } else {
    return value;
  }
}
function inheritViewQuery(definition, superViewQuery) {
  const prevViewQuery = definition.viewQuery;
  if (prevViewQuery) {
    definition.viewQuery = (rf, ctx) => {
      superViewQuery(rf, ctx);
      prevViewQuery(rf, ctx);
    };
  } else {
    definition.viewQuery = superViewQuery;
  }
}
function inheritContentQueries(definition, superContentQueries) {
  const prevContentQueries = definition.contentQueries;
  if (prevContentQueries) {
    definition.contentQueries = (rf, ctx, directiveIndex) => {
      superContentQueries(rf, ctx, directiveIndex);
      prevContentQueries(rf, ctx, directiveIndex);
    };
  } else {
    definition.contentQueries = superContentQueries;
  }
}
function inheritHostBindings(definition, superHostBindings) {
  const prevHostBindings = definition.hostBindings;
  if (prevHostBindings) {
    definition.hostBindings = (rf, ctx) => {
      superHostBindings(rf, ctx);
      prevHostBindings(rf, ctx);
    };
  } else {
    definition.hostBindings = superHostBindings;
  }
}
const COPY_DIRECTIVE_FIELDS = [
  // The child class should use the providers of its parent.
  "providersResolver"
  // Not listed here are any fields which are handled by the `InheritDefinitionFeature`, such
  // as inputs, outputs, and host binding functions.
];
const COPY_COMPONENT_FIELDS = [
  // The child class should use the template function of its parent, including all template
  // semantics.
  "template",
  "decls",
  "consts",
  "vars",
  "onPush",
  "ngContentSelectors",
  // The child class should use the CSS styles of its parent, including all styling semantics.
  "styles",
  "encapsulation",
  // The child class should be checked by the runtime in the same way as its parent.
  "schemas"
];
function \u0275\u0275CopyDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let superDef = void 0;
  if ((0, import_root_effect_scheduler.isComponentDef)(definition)) {
    superDef = superType.\u0275cmp;
  } else {
    superDef = superType.\u0275dir;
  }
  const defAny = definition;
  for (const field of COPY_DIRECTIVE_FIELDS) {
    defAny[field] = superDef[field];
  }
  if ((0, import_root_effect_scheduler.isComponentDef)(superDef)) {
    for (const field of COPY_COMPONENT_FIELDS) {
      defAny[field] = superDef[field];
    }
  }
}
function \u0275\u0275HostDirectivesFeature(rawHostDirectives) {
  const feature = (definition) => {
    const isEager = Array.isArray(rawHostDirectives);
    if (definition.hostDirectives === null) {
      definition.resolveHostDirectives = resolveHostDirectives;
      definition.hostDirectives = isEager ? rawHostDirectives.map(createHostDirectiveDef) : [rawHostDirectives];
    } else if (isEager) {
      definition.hostDirectives.unshift(...rawHostDirectives.map(createHostDirectiveDef));
    } else {
      definition.hostDirectives.unshift(rawHostDirectives);
    }
  };
  feature.ngInherit = true;
  return feature;
}
function resolveHostDirectives(matches) {
  const allDirectiveDefs = [];
  let hasComponent = false;
  let hostDirectiveDefs = null;
  let hostDirectiveRanges = null;
  for (let i = 0; i < matches.length; i++) {
    const def = matches[i];
    if (def.hostDirectives !== null) {
      const start = allDirectiveDefs.length;
      hostDirectiveDefs != null ? hostDirectiveDefs : hostDirectiveDefs = /* @__PURE__ */ new Map();
      hostDirectiveRanges != null ? hostDirectiveRanges : hostDirectiveRanges = /* @__PURE__ */ new Map();
      findHostDirectiveDefs(def, allDirectiveDefs, hostDirectiveDefs);
      hostDirectiveRanges.set(def, [start, allDirectiveDefs.length - 1]);
    }
    if (i === 0 && (0, import_root_effect_scheduler.isComponentDef)(def)) {
      hasComponent = true;
      allDirectiveDefs.push(def);
    }
  }
  for (let i = hasComponent ? 1 : 0; i < matches.length; i++) {
    allDirectiveDefs.push(matches[i]);
  }
  return [allDirectiveDefs, hostDirectiveDefs, hostDirectiveRanges];
}
function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
  if (currentDef.hostDirectives !== null) {
    for (const configOrFn of currentDef.hostDirectives) {
      if (typeof configOrFn === "function") {
        const resolved = configOrFn();
        for (const config of resolved) {
          trackHostDirectiveDef(createHostDirectiveDef(config), matchedDefs, hostDirectiveDefs);
        }
      } else {
        trackHostDirectiveDef(configOrFn, matchedDefs, hostDirectiveDefs);
      }
    }
  }
}
function trackHostDirectiveDef(def, matchedDefs, hostDirectiveDefs) {
  const hostDirectiveDef = (0, import_root_effect_scheduler.getDirectiveDef)(def.directive);
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    validateHostDirective(def, hostDirectiveDef);
  }
  patchDeclaredInputs(hostDirectiveDef.declaredInputs, def.inputs);
  findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
  hostDirectiveDefs.set(hostDirectiveDef, def);
  matchedDefs.push(hostDirectiveDef);
}
function createHostDirectiveDef(config) {
  return typeof config === "function" ? { directive: (0, import_root_effect_scheduler.resolveForwardRef)(config), inputs: import_root_effect_scheduler.EMPTY_OBJ, outputs: import_root_effect_scheduler.EMPTY_OBJ } : {
    directive: (0, import_root_effect_scheduler.resolveForwardRef)(config.directive),
    inputs: bindingArrayToMap(config.inputs),
    outputs: bindingArrayToMap(config.outputs)
  };
}
function bindingArrayToMap(bindings) {
  if (bindings === void 0 || bindings.length === 0) {
    return import_root_effect_scheduler.EMPTY_OBJ;
  }
  const result = {};
  for (let i = 0; i < bindings.length; i += 2) {
    result[bindings[i]] = bindings[i + 1];
  }
  return result;
}
function patchDeclaredInputs(declaredInputs, exposedInputs) {
  for (const publicName in exposedInputs) {
    if (exposedInputs.hasOwnProperty(publicName)) {
      const remappedPublicName = exposedInputs[publicName];
      const privateName = declaredInputs[publicName];
      if ((typeof ngDevMode === "undefined" || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {
        (0, import_root_effect_scheduler.assertEqual)(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
      }
      declaredInputs[remappedPublicName] = privateName;
    }
  }
}
function validateHostDirective(hostDirectiveConfig, directiveDef) {
  const type = hostDirectiveConfig.directive;
  if (directiveDef === null) {
    if ((0, import_root_effect_scheduler.getComponentDef)(type) !== null) {
      throw new import_root_effect_scheduler.RuntimeError(310, `Host directive ${type.name} cannot be a component.`);
    }
    throw new import_root_effect_scheduler.RuntimeError(307, `Could not resolve metadata for host directive ${type.name}. Make sure that the ${type.name} class is annotated with an @Directive decorator.`);
  }
  if (!directiveDef.standalone) {
    throw new import_root_effect_scheduler.RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
  }
  validateMappings("input", directiveDef, hostDirectiveConfig.inputs);
  validateMappings("output", directiveDef, hostDirectiveConfig.outputs);
}
function validateMappings(bindingType, def, hostDirectiveBindings) {
  const className = def.type.name;
  const bindings = bindingType === "input" ? def.inputs : def.outputs;
  for (const publicName in hostDirectiveBindings) {
    if (hostDirectiveBindings.hasOwnProperty(publicName)) {
      if (!bindings.hasOwnProperty(publicName)) {
        throw new import_root_effect_scheduler.RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
      }
      const remappedPublicName = hostDirectiveBindings[publicName];
      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {
        throw new import_root_effect_scheduler.RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
      }
    }
  }
}
function templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags) {
  if (declarationTView.firstCreatePass) {
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
    const embeddedTView = tNode.tView = createTView(
      2,
      tNode,
      templateFn,
      decls,
      vars,
      declarationTView.directiveRegistry,
      declarationTView.pipeRegistry,
      null,
      declarationTView.schemas,
      declarationTView.consts,
      null
      /* ssrId */
    );
    if (declarationTView.queries !== null) {
      declarationTView.queries.template(declarationTView, tNode);
      embeddedTView.queries = declarationTView.queries.embeddedTView(tNode);
    }
  }
  if (flags) {
    tNode.flags |= flags;
  }
  (0, import_root_effect_scheduler.setCurrentTNode)(tNode, false);
  const comment = _locateOrCreateContainerAnchor(declarationTView, declarationLView, tNode, index);
  if ((0, import_root_effect_scheduler.wasLastNodeCreated)()) {
    appendChild(declarationTView, declarationLView, comment, tNode);
  }
  attachPatchData(comment, declarationLView);
  const lContainer = createLContainer(comment, declarationLView, comment, tNode);
  declarationLView[index + import_root_effect_scheduler.HEADER_OFFSET] = lContainer;
  addToEndOfViewTree(declarationLView, lContainer);
  populateDehydratedViewsInLContainer(lContainer, tNode, declarationLView);
}
function declareDirectiveHostTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, flags, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  let tNode;
  if (declarationTView.firstCreatePass) {
    tNode = getOrCreateTNode(declarationTView, adjustedIndex, 4, tagName || null, attrs || null);
    if ((0, import_root_effect_scheduler.getBindingsEnabled)()) {
      resolveDirectives(declarationTView, declarationLView, tNode, (0, import_root_effect_scheduler.getConstant)(declarationTView.consts, localRefsIndex), findDirectiveDefMatches);
    }
    registerPostOrderHooks(declarationTView, tNode);
  } else {
    tNode = declarationTView.data[adjustedIndex];
  }
  templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags);
  if ((0, import_root_effect_scheduler.isDirectiveHost)(tNode)) {
    createDirectivesInstances(declarationTView, declarationLView, tNode);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function declareNoDirectiveHostTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, flags, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  let tNode;
  if (declarationTView.firstCreatePass) {
    tNode = getOrCreateTNode(declarationTView, adjustedIndex, 4, tagName || null, attrs || null);
    if (localRefsIndex != null) {
      const refs = (0, import_root_effect_scheduler.getConstant)(declarationTView.consts, localRefsIndex);
      tNode.localNames = [];
      for (let i = 0; i < refs.length; i += 2) {
        tNode.localNames.push(refs[i], -1);
      }
    }
  } else {
    tNode = declarationTView.data[adjustedIndex];
  }
  templateCreate(tNode, declarationLView, declarationTView, index, templateFn, decls, vars, flags);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function \u0275\u0275template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const attrs = (0, import_root_effect_scheduler.getConstant)(tView.consts, attrsIndex);
  declareDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, void 0, localRefsIndex, localRefExtractor);
  return \u0275\u0275template;
}
function \u0275\u0275domTemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const attrs = (0, import_root_effect_scheduler.getConstant)(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, void 0, localRefsIndex, localRefExtractor);
  return \u0275\u0275domTemplate;
}
let _locateOrCreateContainerAnchor = createContainerAnchorImpl;
function createContainerAnchorImpl(tView, lView, tNode, index) {
  (0, import_root_effect_scheduler.lastNodeWasCreated)(true);
  return lView[import_root_effect_scheduler.RENDERER].createComment(ngDevMode ? "container" : "");
}
function locateOrCreateContainerAnchorImpl(tView, lView, tNode, index) {
  var _a2, _b2, _c2;
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0, import_root_effect_scheduler.lastNodeWasCreated)(isNodeCreationMode);
  const ssrId = (_c2 = (_b2 = (_a2 = lView[import_root_effect_scheduler.HYDRATION]) == null ? void 0 : _a2.data[TEMPLATES]) == null ? void 0 : _b2[index]) != null ? _c2 : null;
  if (ssrId !== null && tNode.tView !== null) {
    if (tNode.tView.ssrId === null) {
      tNode.tView.ssrId = ssrId;
    } else {
      ngDevMode && (0, import_root_effect_scheduler.assertEqual)(tNode.tView.ssrId, ssrId, "Unexpected value of the `ssrId` for this TView");
    }
  }
  if (isNodeCreationMode) {
    return createContainerAnchorImpl(tView, lView);
  }
  const hydrationInfo = lView[import_root_effect_scheduler.HYDRATION];
  const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateNodeExists(currentRNode, lView, tNode);
  setSegmentHead(hydrationInfo, index, currentRNode);
  const viewContainerSize = calcSerializedContainerSize(hydrationInfo, index);
  const comment = siblingAfter(viewContainerSize, currentRNode);
  if (ngDevMode) {
    validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);
    markRNodeAsClaimedByHydration(comment);
  }
  return comment;
}
function enableLocateOrCreateContainerAnchorImpl() {
  _locateOrCreateContainerAnchor = locateOrCreateContainerAnchorImpl;
}
var DeferDependenciesLoadingState;
(function(DeferDependenciesLoadingState2) {
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["NOT_STARTED"] = 0] = "NOT_STARTED";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["IN_PROGRESS"] = 1] = "IN_PROGRESS";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["COMPLETE"] = 2] = "COMPLETE";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["FAILED"] = 3] = "FAILED";
})(DeferDependenciesLoadingState || (DeferDependenciesLoadingState = {}));
const MINIMUM_SLOT = 0;
const LOADING_AFTER_SLOT = 1;
var DeferBlockState;
(function(DeferBlockState2) {
  DeferBlockState2[DeferBlockState2["Placeholder"] = 0] = "Placeholder";
  DeferBlockState2[DeferBlockState2["Loading"] = 1] = "Loading";
  DeferBlockState2[DeferBlockState2["Complete"] = 2] = "Complete";
  DeferBlockState2[DeferBlockState2["Error"] = 3] = "Error";
})(DeferBlockState || (DeferBlockState = {}));
var DeferBlockInternalState;
(function(DeferBlockInternalState2) {
  DeferBlockInternalState2[DeferBlockInternalState2["Initial"] = -1] = "Initial";
})(DeferBlockInternalState || (DeferBlockInternalState = {}));
const NEXT_DEFER_BLOCK_STATE = 0;
const DEFER_BLOCK_STATE = 1;
const STATE_IS_FROZEN_UNTIL = 2;
const LOADING_AFTER_CLEANUP_FN = 3;
const TRIGGER_CLEANUP_FNS = 4;
const PREFETCH_TRIGGER_CLEANUP_FNS = 5;
const SSR_UNIQUE_ID = 6;
const SSR_BLOCK_STATE = 7;
const ON_COMPLETE_FNS = 8;
const HYDRATE_TRIGGER_CLEANUP_FNS = 9;
var DeferBlockBehavior;
(function(DeferBlockBehavior2) {
  DeferBlockBehavior2[DeferBlockBehavior2["Manual"] = 0] = "Manual";
  DeferBlockBehavior2[DeferBlockBehavior2["Playthrough"] = 1] = "Playthrough";
})(DeferBlockBehavior || (DeferBlockBehavior = {}));
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
function storeTriggerCleanupFn(type, lDetails, cleanupFn) {
  const key = getCleanupFnKeyByType(type);
  if (lDetails[key] === null) {
    lDetails[key] = [];
  }
  lDetails[key].push(cleanupFn);
}
function invokeTriggerCleanupFns(type, lDetails) {
  const key = getCleanupFnKeyByType(type);
  const cleanupFns = lDetails[key];
  if (cleanupFns !== null) {
    for (const cleanupFn of cleanupFns) {
      cleanupFn();
    }
    lDetails[key] = null;
  }
}
function invokeAllTriggerCleanupFns(lDetails) {
  invokeTriggerCleanupFns(1, lDetails);
  invokeTriggerCleanupFns(0, lDetails);
  invokeTriggerCleanupFns(2, lDetails);
}
function getCleanupFnKeyByType(type) {
  let key = TRIGGER_CLEANUP_FNS;
  if (type === 1) {
    key = PREFETCH_TRIGGER_CLEANUP_FNS;
  } else if (type === 2) {
    key = HYDRATE_TRIGGER_CLEANUP_FNS;
  }
  return key;
}
function getDeferBlockDataIndex(deferBlockIndex) {
  return deferBlockIndex + 1;
}
function getLDeferBlockDetails(lView, tNode) {
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInDeclRange)(tView, slotIndex);
  return lView[slotIndex];
}
function setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInDeclRange)(tView, slotIndex);
  lView[slotIndex] = lDetails;
}
function getTDeferBlockDetails(tView, tNode) {
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInDeclRange)(tView, slotIndex);
  return tView.data[slotIndex];
}
function setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInDeclRange)(tView, slotIndex);
  tView.data[slotIndex] = deferBlockConfig;
}
function getTemplateIndexForState(newState, hostLView, tNode) {
  const tView = hostLView[import_root_effect_scheduler.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  switch (newState) {
    case DeferBlockState.Complete:
      return tDetails.primaryTmplIndex;
    case DeferBlockState.Loading:
      return tDetails.loadingTmplIndex;
    case DeferBlockState.Error:
      return tDetails.errorTmplIndex;
    case DeferBlockState.Placeholder:
      return tDetails.placeholderTmplIndex;
    default:
      ngDevMode && (0, import_root_effect_scheduler.throwError)(`Unexpected defer block state: ${newState}`);
      return null;
  }
}
function getMinimumDurationForState(tDetails, currentState) {
  var _a2, _b2, _c2, _d2;
  if (currentState === DeferBlockState.Placeholder) {
    return (_b2 = (_a2 = tDetails.placeholderBlockConfig) == null ? void 0 : _a2[MINIMUM_SLOT]) != null ? _b2 : null;
  } else if (currentState === DeferBlockState.Loading) {
    return (_d2 = (_c2 = tDetails.loadingBlockConfig) == null ? void 0 : _c2[MINIMUM_SLOT]) != null ? _d2 : null;
  }
  return null;
}
function getLoadingBlockAfter(tDetails) {
  var _a2, _b2;
  return (_b2 = (_a2 = tDetails.loadingBlockConfig) == null ? void 0 : _a2[LOADING_AFTER_SLOT]) != null ? _b2 : null;
}
function addDepsToRegistry(currentDeps, newDeps) {
  if (!currentDeps || currentDeps.length === 0) {
    return newDeps;
  }
  const currentDepSet = new Set(currentDeps);
  for (const dep of newDeps) {
    currentDepSet.add(dep);
  }
  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);
}
function getPrimaryBlockTNode(tView, tDetails) {
  const adjustedIndex = tDetails.primaryTmplIndex + import_root_effect_scheduler.HEADER_OFFSET;
  return (0, import_root_effect_scheduler.getTNode)(tView, adjustedIndex);
}
function assertDeferredDependenciesLoaded(tDetails) {
  (0, import_root_effect_scheduler.assertEqual)(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, "Expecting all deferred dependencies to be loaded.");
}
function isTDeferBlockDetails(value) {
  return value !== null && typeof value === "object" && typeof value.primaryTmplIndex === "number";
}
function isDeferBlock(tView, tNode) {
  let tDetails = null;
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  if (import_root_effect_scheduler.HEADER_OFFSET < slotIndex && slotIndex < tView.bindingStartIndex) {
    tDetails = getTDeferBlockDetails(tView, tNode);
  }
  return !!tDetails && isTDeferBlockDetails(tDetails);
}
function trackTriggerForDebugging(tView, tNode, textRepresentation) {
  var _a2, _b2, _c2;
  const tDetails = getTDeferBlockDetails(tView, tNode);
  (_a2 = tDetails.debug) != null ? _a2 : tDetails.debug = {};
  (_c2 = (_b2 = tDetails.debug).triggers) != null ? _c2 : _b2.triggers = /* @__PURE__ */ new Set();
  tDetails.debug.triggers.add(textRepresentation);
}
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
function onViewportWrapper(trigger, callback, injector) {
  const ngZone = injector.get(NgZone);
  return onViewport(trigger, () => ngZone.run(callback), () => ngZone.runOutsideAngular(() => createIntersectionObserver()));
}
function getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {
  var _a2;
  if (walkUpTimes == null) {
    return deferredHostLView;
  }
  if (walkUpTimes >= 0) {
    return (0, import_root_effect_scheduler.walkUpViews)(walkUpTimes, deferredHostLView);
  }
  const deferredContainer = deferredHostLView[deferredTNode.index];
  ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(deferredContainer);
  const triggerLView = (_a2 = deferredContainer[import_root_effect_scheduler.CONTAINER_HEADER_OFFSET]) != null ? _a2 : null;
  if (ngDevMode && triggerLView !== null) {
    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    (0, import_root_effect_scheduler.assertEqual)(renderedState, DeferBlockState.Placeholder, "Expected a placeholder to be rendered in this defer block.");
    (0, import_root_effect_scheduler.assertLView)(triggerLView);
  }
  return triggerLView;
}
function getTriggerElement(triggerLView, triggerIndex) {
  const element = (0, import_root_effect_scheduler.getNativeByIndex)(import_root_effect_scheduler.HEADER_OFFSET + triggerIndex, triggerLView);
  ngDevMode && (0, import_root_effect_scheduler.assertElement)(element);
  return element;
}
function registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type) {
  const injector = initialLView[import_root_effect_scheduler.INJECTOR$1];
  const zone = injector.get(NgZone);
  let poll;
  function pollDomTrigger() {
    if ((0, import_root_effect_scheduler.isDestroyed)(initialLView)) {
      poll.destroy();
      return;
    }
    const lDetails = getLDeferBlockDetails(initialLView, tNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {
      poll.destroy();
      return;
    }
    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);
    if (!triggerLView) {
      return;
    }
    poll.destroy();
    if ((0, import_root_effect_scheduler.isDestroyed)(triggerLView)) {
      return;
    }
    const element = getTriggerElement(triggerLView, triggerIndex);
    const cleanup = registerFn(element, () => {
      zone.run(() => {
        if (initialLView !== triggerLView) {
          (0, import_root_effect_scheduler.removeLViewOnDestroy)(triggerLView, cleanup);
        }
        callback();
      });
    }, injector);
    if (initialLView !== triggerLView) {
      (0, import_root_effect_scheduler.storeLViewOnDestroy)(triggerLView, cleanup);
    }
    storeTriggerCleanupFn(type, lDetails, cleanup);
  }
  poll = afterEveryRender({ read: pollDomTrigger }, { injector });
}
function onIdle(callback, injector) {
  const scheduler = injector.get(IdleScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(callback);
  return cleanupFn;
}
const _requestIdleCallback = () => typeof requestIdleCallback !== "undefined" ? requestIdleCallback : setTimeout;
const _cancelIdleCallback = () => typeof requestIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
const _IdleScheduler = class _IdleScheduler {
  constructor() {
    // Indicates whether current callbacks are being invoked.
    __publicField(this, "executingCallbacks", false);
    // Currently scheduled idle callback id.
    __publicField(this, "idleId", null);
    // Set of callbacks to be invoked next.
    __publicField(this, "current", /* @__PURE__ */ new Set());
    // Set of callbacks collected while invoking current set of callbacks.
    // Those callbacks are scheduled for the next idle period.
    __publicField(this, "deferred", /* @__PURE__ */ new Set());
    __publicField(this, "ngZone", (0, import_root_effect_scheduler.inject)(NgZone));
    __publicField(this, "requestIdleCallbackFn", _requestIdleCallback().bind(globalThis));
    __publicField(this, "cancelIdleCallbackFn", _cancelIdleCallback().bind(globalThis));
  }
  add(callback) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    target.add(callback);
    if (this.idleId === null) {
      this.scheduleIdleCallback();
    }
  }
  remove(callback) {
    const { current, deferred } = this;
    current.delete(callback);
    deferred.delete(callback);
    if (current.size === 0 && deferred.size === 0) {
      this.cancelIdleCallback();
    }
  }
  scheduleIdleCallback() {
    const callback = () => {
      this.cancelIdleCallback();
      this.executingCallbacks = true;
      for (const callback2 of this.current) {
        callback2();
      }
      this.current.clear();
      this.executingCallbacks = false;
      if (this.deferred.size > 0) {
        for (const callback2 of this.deferred) {
          this.current.add(callback2);
        }
        this.deferred.clear();
        this.scheduleIdleCallback();
      }
    };
    this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));
  }
  cancelIdleCallback() {
    if (this.idleId !== null) {
      this.cancelIdleCallbackFn(this.idleId);
      this.idleId = null;
    }
  }
  ngOnDestroy() {
    this.cancelIdleCallback();
    this.current.clear();
    this.deferred.clear();
  }
};
/** @nocollapse */
__publicField(
  _IdleScheduler,
  "\u0275prov",
  /** @pureOrBreakMyCode */
  /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({
    token: _IdleScheduler,
    providedIn: "root",
    factory: () => new _IdleScheduler()
  })
);
let IdleScheduler = _IdleScheduler;
function onTimer(delay) {
  return (callback, injector) => scheduleTimerTrigger(delay, callback, injector);
}
function scheduleTimerTrigger(delay, callback, injector) {
  const scheduler = injector.get(TimerScheduler);
  const ngZone = injector.get(NgZone);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(delay, callback, ngZone);
  return cleanupFn;
}
const _TimerScheduler = class _TimerScheduler {
  constructor() {
    // Indicates whether current callbacks are being invoked.
    __publicField(this, "executingCallbacks", false);
    // Currently scheduled `setTimeout` id.
    __publicField(this, "timeoutId", null);
    // When currently scheduled timer would fire.
    __publicField(this, "invokeTimerAt", null);
    // List of callbacks to be invoked.
    // For each callback we also store a timestamp on when the callback
    // should be invoked. We store timestamps and callback functions
    // in a flat array to avoid creating new objects for each entry.
    // [timestamp1, callback1, timestamp2, callback2, ...]
    __publicField(this, "current", []);
    // List of callbacks collected while invoking current set of callbacks.
    // Those callbacks are added to the "current" queue at the end of
    // the current callback invocation. The shape of this list is the same
    // as the shape of the `current` list.
    __publicField(this, "deferred", []);
  }
  add(delay, callback, ngZone) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    this.addToQueue(target, Date.now() + delay, callback);
    this.scheduleTimer(ngZone);
  }
  remove(callback) {
    const { current, deferred } = this;
    const callbackIndex = this.removeFromQueue(current, callback);
    if (callbackIndex === -1) {
      this.removeFromQueue(deferred, callback);
    }
    if (current.length === 0 && deferred.length === 0) {
      this.clearTimeout();
    }
  }
  addToQueue(target, invokeAt, callback) {
    let insertAtIndex = target.length;
    for (let i = 0; i < target.length; i += 2) {
      const invokeQueuedCallbackAt = target[i];
      if (invokeQueuedCallbackAt > invokeAt) {
        insertAtIndex = i;
        break;
      }
    }
    (0, import_root_effect_scheduler.arrayInsert2)(target, insertAtIndex, invokeAt, callback);
  }
  removeFromQueue(target, callback) {
    let index = -1;
    for (let i = 0; i < target.length; i += 2) {
      const queuedCallback = target[i + 1];
      if (queuedCallback === callback) {
        index = i;
        break;
      }
    }
    if (index > -1) {
      (0, import_root_effect_scheduler.arraySplice)(target, index, 2);
    }
    return index;
  }
  scheduleTimer(ngZone) {
    const callback = () => {
      this.clearTimeout();
      this.executingCallbacks = true;
      const current = [...this.current];
      const now = Date.now();
      for (let i = 0; i < current.length; i += 2) {
        const invokeAt = current[i];
        const callback2 = current[i + 1];
        if (invokeAt <= now) {
          callback2();
        } else {
          break;
        }
      }
      let lastCallbackIndex = -1;
      for (let i = 0; i < this.current.length; i += 2) {
        const invokeAt = this.current[i];
        if (invokeAt <= now) {
          lastCallbackIndex = i + 1;
        } else {
          break;
        }
      }
      if (lastCallbackIndex >= 0) {
        (0, import_root_effect_scheduler.arraySplice)(this.current, 0, lastCallbackIndex + 1);
      }
      this.executingCallbacks = false;
      if (this.deferred.length > 0) {
        for (let i = 0; i < this.deferred.length; i += 2) {
          const invokeAt = this.deferred[i];
          const callback2 = this.deferred[i + 1];
          this.addToQueue(this.current, invokeAt, callback2);
        }
        this.deferred.length = 0;
      }
      this.scheduleTimer(ngZone);
    };
    const FRAME_DURATION_MS = 16;
    if (this.current.length > 0) {
      const now = Date.now();
      const invokeAt = this.current[0];
      if (this.timeoutId === null || // Reschedule a timer in case a queue contains an item with
      // an earlier timestamp and the delta is more than an average
      // frame duration.
      this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {
        this.clearTimeout();
        const timeout = Math.max(invokeAt - now, FRAME_DURATION_MS);
        this.invokeTimerAt = invokeAt;
        this.timeoutId = ngZone.runOutsideAngular(() => {
          return setTimeout(() => ngZone.run(callback), timeout);
        });
      }
    }
  }
  clearTimeout() {
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  ngOnDestroy() {
    this.clearTimeout();
    this.current.length = 0;
    this.deferred.length = 0;
  }
};
/** @nocollapse */
__publicField(
  _TimerScheduler,
  "\u0275prov",
  /** @pureOrBreakMyCode */
  /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({
    token: _TimerScheduler,
    providedIn: "root",
    factory: () => new _TimerScheduler()
  })
);
let TimerScheduler = _TimerScheduler;
const _CachedInjectorService = class _CachedInjectorService {
  constructor() {
    __publicField(this, "cachedInjectors", /* @__PURE__ */ new Map());
  }
  getOrCreateInjector(key, parentInjector, providers, debugName) {
    if (!this.cachedInjectors.has(key)) {
      const injector = providers.length > 0 ? createEnvironmentInjector(providers, parentInjector, debugName) : null;
      this.cachedInjectors.set(key, injector);
    }
    return this.cachedInjectors.get(key);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
};
/** @nocollapse */
__publicField(
  _CachedInjectorService,
  "\u0275prov",
  /** @pureOrBreakMyCode */
  /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({
    token: _CachedInjectorService,
    providedIn: "environment",
    factory: () => new _CachedInjectorService()
  })
);
let CachedInjectorService = _CachedInjectorService;
const DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = /* @__PURE__ */ new import_root_effect_scheduler.InjectionToken("DEFER_BLOCK_DEPENDENCY_INTERCEPTOR");
const DEFER_BLOCK_CONFIG = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "DEFER_BLOCK_CONFIG" : "");
function getOrCreateEnvironmentInjector(parentInjector, tDetails, providers) {
  return parentInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentInjector, providers, ngDevMode ? "DeferBlock Injector" : "");
}
function createDeferBlockInjector(parentInjector, tDetails, providers) {
  if (parentInjector instanceof ChainedInjector) {
    const origInjector = parentInjector.injector;
    const parentEnvInjector2 = parentInjector.parentInjector;
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector2, tDetails, providers);
    return new ChainedInjector(origInjector, envInjector);
  }
  const parentEnvInjector = parentInjector.get(import_root_effect_scheduler.EnvironmentInjector);
  if (parentEnvInjector !== parentInjector) {
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers);
    return new ChainedInjector(parentInjector, envInjector);
  }
  return getOrCreateEnvironmentInjector(parentInjector, tDetails, providers);
}
function renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {
  var _a2;
  const hostLView = lContainer[import_root_effect_scheduler.PARENT];
  const hostTView = hostLView[import_root_effect_scheduler.TVIEW];
  if ((0, import_root_effect_scheduler.isDestroyed)(hostLView))
    return;
  ngDevMode && (0, import_root_effect_scheduler.assertTNodeForLView)(tNode, hostLView);
  const lDetails = getLDeferBlockDetails(hostLView, tNode);
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(lDetails, "Expected a defer block state defined");
  const currentState = lDetails[DEFER_BLOCK_STATE];
  const ssrState = lDetails[SSR_BLOCK_STATE];
  if (ssrState !== null && newState < ssrState) {
    return;
  }
  if (isValidStateChange(currentState, newState) && isValidStateChange((_a2 = lDetails[NEXT_DEFER_BLOCK_STATE]) != null ? _a2 : -1, newState)) {
    const tDetails = getTDeferBlockDetails(hostTView, tNode);
    const needsScheduling = !skipTimerScheduling && (typeof ngServerMode === "undefined" || !ngServerMode) && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));
    if (ngDevMode && needsScheduling) {
      (0, import_root_effect_scheduler.assertDefined)(applyDeferBlockStateWithSchedulingImpl, "Expected scheduling function to be defined");
    }
    const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;
    try {
      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);
    } catch (error) {
      handleUncaughtError(hostLView, error);
    }
  }
}
function findMatchingDehydratedViewForDeferBlock(lContainer, lDetails) {
  var _a2, _b2;
  const dehydratedViewIx = (_b2 = (_a2 = lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS]) == null ? void 0 : _a2.findIndex((view) => view.data[DEFER_BLOCK_STATE$1] === lDetails[DEFER_BLOCK_STATE])) != null ? _b2 : -1;
  const dehydratedView = dehydratedViewIx > -1 ? lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS][dehydratedViewIx] : null;
  return { dehydratedView, dehydratedViewIx };
}
function applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {
  var _a2;
  profiler(
    20
    /* ProfilerEvent.DeferBlockStateStart */
  );
  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);
  if (stateTmplIndex !== null) {
    lDetails[DEFER_BLOCK_STATE] = newState;
    const hostTView = hostLView[import_root_effect_scheduler.TVIEW];
    const adjustedIndex = stateTmplIndex + import_root_effect_scheduler.HEADER_OFFSET;
    const activeBlockTNode = (0, import_root_effect_scheduler.getTNode)(hostTView, adjustedIndex);
    const viewIndex = 0;
    removeLViewFromLContainer(lContainer, viewIndex);
    let injector;
    if (newState === DeferBlockState.Complete) {
      const tDetails = getTDeferBlockDetails(hostTView, tNode);
      const providers = tDetails.providers;
      if (providers && providers.length > 0) {
        injector = createDeferBlockInjector(hostLView[import_root_effect_scheduler.INJECTOR$1], tDetails, providers);
      }
    }
    const { dehydratedView, dehydratedViewIx } = findMatchingDehydratedViewForDeferBlock(lContainer, lDetails);
    const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, {
      injector,
      dehydratedView
    });
    addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));
    markViewDirty(
      embeddedLView,
      2
      /* NotificationSource.DeferBlockStateUpdate */
    );
    if (dehydratedViewIx > -1) {
      (_a2 = lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS]) == null ? void 0 : _a2.splice(dehydratedViewIx, 1);
    }
    if ((newState === DeferBlockState.Complete || newState === DeferBlockState.Error) && Array.isArray(lDetails[ON_COMPLETE_FNS])) {
      for (const callback of lDetails[ON_COMPLETE_FNS]) {
        callback();
      }
      lDetails[ON_COMPLETE_FNS] = null;
    }
  }
  profiler(
    21
    /* ProfilerEvent.DeferBlockStateEnd */
  );
}
function applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {
  const now = Date.now();
  const hostTView = hostLView[import_root_effect_scheduler.TVIEW];
  const tDetails = getTDeferBlockDetails(hostTView, tNode);
  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now) {
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    const loadingAfter = getLoadingBlockAfter(tDetails);
    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;
    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {
      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
      const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);
      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;
    } else {
      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {
        lDetails[LOADING_AFTER_CLEANUP_FN]();
        lDetails[LOADING_AFTER_CLEANUP_FN] = null;
        lDetails[NEXT_DEFER_BLOCK_STATE] = null;
      }
      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);
      const duration = getMinimumDurationForState(tDetails, newState);
      if (duration !== null) {
        lDetails[STATE_IS_FROZEN_UNTIL] = now + duration;
        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);
      }
    }
  } else {
    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
  }
}
function scheduleDeferBlockUpdate(timeout, lDetails, tNode, lContainer, hostLView) {
  const callback = () => {
    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    lDetails[NEXT_DEFER_BLOCK_STATE] = null;
    if (nextState !== null) {
      renderDeferBlockState(nextState, tNode, lContainer);
    }
  };
  return scheduleTimerTrigger(timeout, callback, hostLView[import_root_effect_scheduler.INJECTOR$1]);
}
function isValidStateChange(currentState, newState) {
  return currentState < newState;
}
function renderPlaceholder(lView, tNode) {
  const lContainer = lView[tNode.index];
  ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(lContainer);
  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);
}
function renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(tDetails.loadingPromise, "Expected loading Promise to exist on this defer block");
  tDetails.loadingPromise.then(() => {
    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
    }
  });
}
let applyDeferBlockStateWithSchedulingImpl = null;
function \u0275\u0275deferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {
  const tViewConsts = tView.consts;
  if (placeholderConfigIndex != null) {
    tDetails.placeholderBlockConfig = (0, import_root_effect_scheduler.getConstant)(tViewConsts, placeholderConfigIndex);
  }
  if (loadingConfigIndex != null) {
    tDetails.loadingBlockConfig = (0, import_root_effect_scheduler.getConstant)(tViewConsts, loadingConfigIndex);
  }
  if (applyDeferBlockStateWithSchedulingImpl === null) {
    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;
  }
}
const ASYNC_COMPONENT_METADATA_FN = "__ngAsyncComponentMetadataFn__";
function getAsyncClassMetadataFn(type) {
  var _a2;
  const componentClass = type;
  return (_a2 = componentClass[ASYNC_COMPONENT_METADATA_FN]) != null ? _a2 : null;
}
function setClassMetadataAsync(type, dependencyLoaderFn, metadataSetterFn) {
  const componentClass = type;
  componentClass[ASYNC_COMPONENT_METADATA_FN] = () => Promise.all(dependencyLoaderFn()).then((dependencies) => {
    metadataSetterFn(...dependencies);
    componentClass[ASYNC_COMPONENT_METADATA_FN] = null;
    return dependencies;
  });
  return componentClass[ASYNC_COMPONENT_METADATA_FN];
}
function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
  return noSideEffects(() => {
    const clazz = type;
    if (decorators !== null) {
      if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
        clazz.decorators.push(...decorators);
      } else {
        clazz.decorators = decorators;
      }
    }
    if (ctorParameters !== null) {
      clazz.ctorParameters = ctorParameters;
    }
    if (propDecorators !== null) {
      if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
        clazz.propDecorators = __spreadValues(__spreadValues({}, clazz.propDecorators), propDecorators);
      } else {
        clazz.propDecorators = propDecorators;
      }
    }
  });
}
const _Console = class _Console {
  log(message) {
    console.log(message);
  }
  // Note: for reporting errors use `DOM.logError()` as it is platform specific
  warn(message) {
    console.warn(message);
  }
};
__publicField(_Console, "\u0275fac", function Console_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _Console)();
});
__publicField(_Console, "\u0275prov", /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({ token: _Console, factory: _Console.\u0275fac, providedIn: "platform" }));
let Console = _Console;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
    type: Injectable,
    args: [{ providedIn: "platform" }]
  }], null, null);
})();
class DIDebugData {
  constructor() {
    __publicField(this, "resolverToTokenToDependencies", /* @__PURE__ */ new WeakMap());
    __publicField(this, "resolverToProviders", /* @__PURE__ */ new WeakMap());
    __publicField(this, "resolverToEffects", /* @__PURE__ */ new WeakMap());
    __publicField(this, "standaloneInjectorToComponent", /* @__PURE__ */ new WeakMap());
  }
  reset() {
    this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
    this.resolverToProviders = /* @__PURE__ */ new WeakMap();
    this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
  }
}
let frameworkDIDebugData = new DIDebugData();
function getFrameworkDIDebugData() {
  return frameworkDIDebugData;
}
function setupFrameworkInjectorProfiler() {
  frameworkDIDebugData.reset();
  (0, import_root_effect_scheduler.setInjectorProfiler)(injectorProfilerEventHandler);
}
function injectorProfilerEventHandler(injectorProfilerEvent) {
  const { context, type } = injectorProfilerEvent;
  if (type === 0) {
    handleInjectEvent(context, injectorProfilerEvent.service);
  } else if (type === 1) {
    handleInstanceCreatedByInjectorEvent(context, injectorProfilerEvent.instance);
  } else if (type === 2) {
    handleProviderConfiguredEvent(context, injectorProfilerEvent.providerRecord);
  } else if (type === 3) {
    handleEffectCreatedEvent(context, injectorProfilerEvent.effect);
  }
}
function handleEffectCreatedEvent(context, effect) {
  const diResolver = getDIResolver(context.injector);
  if (diResolver === null) {
    (0, import_root_effect_scheduler.throwError)("An EffectCreated event must be run within an injection context.");
  }
  const { resolverToEffects } = frameworkDIDebugData;
  if (!resolverToEffects.has(diResolver)) {
    resolverToEffects.set(diResolver, []);
  }
  resolverToEffects.get(diResolver).push(effect);
}
function handleInjectEvent(context, data) {
  const diResolver = getDIResolver(context.injector);
  if (diResolver === null) {
    (0, import_root_effect_scheduler.throwError)("An Inject event must be run within an injection context.");
  }
  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
  if (!diResolverToInstantiatedToken.has(diResolver)) {
    diResolverToInstantiatedToken.set(diResolver, /* @__PURE__ */ new WeakMap());
  }
  if (!canBeHeldWeakly(context.token)) {
    return;
  }
  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
  if (!instantiatedTokenToDependencies.has(context.token)) {
    instantiatedTokenToDependencies.set(context.token, []);
  }
  const { token, value, flags } = data;
  (0, import_root_effect_scheduler.assertDefined)(context.token, "Injector profiler context token is undefined.");
  const dependencies = instantiatedTokenToDependencies.get(context.token);
  (0, import_root_effect_scheduler.assertDefined)(dependencies, "Could not resolve dependencies for token.");
  if (context.injector instanceof NodeInjector) {
    dependencies.push({ token, value, flags, injectedIn: getNodeInjectorContext(context.injector) });
  } else {
    dependencies.push({ token, value, flags });
  }
}
function getNodeInjectorContext(injector) {
  if (!(injector instanceof NodeInjector)) {
    (0, import_root_effect_scheduler.throwError)("getNodeInjectorContext must be called with a NodeInjector");
  }
  const lView = getNodeInjectorLView(injector);
  const tNode = getNodeInjectorTNode(injector);
  if (tNode === null) {
    return;
  }
  (0, import_root_effect_scheduler.assertTNodeForLView)(tNode, lView);
  return { lView, tNode };
}
function handleInstanceCreatedByInjectorEvent(context, data) {
  const { value } = data;
  if (data.value == null) {
    return;
  }
  if (getDIResolver(context.injector) === null) {
    (0, import_root_effect_scheduler.throwError)("An InjectorCreatedInstance event must be run within an injection context.");
  }
  let standaloneComponent = void 0;
  if (typeof value === "object") {
    standaloneComponent = value == null ? void 0 : value.constructor;
  }
  if (standaloneComponent == void 0 || !isStandaloneComponent(standaloneComponent)) {
    return;
  }
  const environmentInjector = context.injector.get(import_root_effect_scheduler.EnvironmentInjector, null, { optional: true });
  if (environmentInjector === null) {
    return;
  }
  const { standaloneInjectorToComponent } = frameworkDIDebugData;
  if (standaloneInjectorToComponent.has(environmentInjector)) {
    return;
  }
  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
}
function isStandaloneComponent(value) {
  const def = (0, import_root_effect_scheduler.getComponentDef)(value);
  return !!(def == null ? void 0 : def.standalone);
}
function handleProviderConfiguredEvent(context, data) {
  const { resolverToProviders } = frameworkDIDebugData;
  let diResolver;
  if ((context == null ? void 0 : context.injector) instanceof NodeInjector) {
    diResolver = getNodeInjectorTNode(context.injector);
  } else {
    diResolver = context.injector;
  }
  if (diResolver === null) {
    (0, import_root_effect_scheduler.throwError)("A ProviderConfigured event must be run within an injection context.");
  }
  if (!resolverToProviders.has(diResolver)) {
    resolverToProviders.set(diResolver, []);
  }
  resolverToProviders.get(diResolver).push(data);
}
function getDIResolver(injector) {
  let diResolver = null;
  if (injector === void 0) {
    return diResolver;
  }
  if (injector instanceof NodeInjector) {
    diResolver = getNodeInjectorLView(injector);
  } else {
    diResolver = injector;
  }
  return diResolver;
}
function canBeHeldWeakly(value) {
  return value !== null && (typeof value === "object" || typeof value === "function" || typeof value === "symbol");
}
function applyChanges(component) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(component, "component");
  markViewDirty(
    getComponentViewByInstance(component),
    3
    /* NotificationSource.DebugApplyChanges */
  );
  getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
}
function detectChanges(component) {
  const view = getComponentViewByInstance(component);
  view[import_root_effect_scheduler.FLAGS] |= 1024;
  detectChangesInternal(view);
}
function getDeferBlocks$1(lView, deferBlocks) {
  const tView = lView[import_root_effect_scheduler.TVIEW];
  for (let i = import_root_effect_scheduler.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if ((0, import_root_effect_scheduler.isLContainer)(lView[i])) {
      const lContainer = lView[i];
      const isLast = i === tView.bindingStartIndex - 1;
      if (!isLast) {
        const tNode = tView.data[i];
        const tDetails = getTDeferBlockDetails(tView, tNode);
        if (isTDeferBlockDetails(tDetails)) {
          deferBlocks.push({ lContainer, lView, tNode, tDetails });
          continue;
        }
      }
      if ((0, import_root_effect_scheduler.isLView)(lContainer[import_root_effect_scheduler.HOST])) {
        getDeferBlocks$1(lContainer[import_root_effect_scheduler.HOST], deferBlocks);
      }
      for (let j = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET; j < lContainer.length; j++) {
        getDeferBlocks$1(lContainer[j], deferBlocks);
      }
    } else if ((0, import_root_effect_scheduler.isLView)(lView[i])) {
      getDeferBlocks$1(lView[i], deferBlocks);
    }
  }
}
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
function getDeferBlocks(node) {
  var _a2;
  const results = [];
  const lView = (_a2 = getLContext(node)) == null ? void 0 : _a2.lView;
  if (lView) {
    findDeferBlocks(node, lView, results);
  }
  return results;
}
function findDeferBlocks(node, lView, results) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
  const viewInjector = lView[import_root_effect_scheduler.INJECTOR$1];
  const registry = viewInjector.get(DEHYDRATED_BLOCK_REGISTRY, null, { optional: true });
  const blocks = [];
  getDeferBlocks$1(lView, blocks);
  const transferState = viewInjector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  for (const details of blocks) {
    const native = (0, import_root_effect_scheduler.getNativeByTNode)(details.tNode, details.lView);
    const lDetails = getLDeferBlockDetails(details.lView, details.tNode);
    if (!node.contains(native)) {
      continue;
    }
    const tDetails = details.tDetails;
    const renderedLView = getRendererLView(details);
    const rootNodes = [];
    const hydrationState = inferHydrationState(tDetails, lDetails, registry);
    if (renderedLView !== null) {
      collectNativeNodes(renderedLView[import_root_effect_scheduler.TVIEW], renderedLView, renderedLView[import_root_effect_scheduler.TVIEW].firstChild, rootNodes);
    } else if (hydrationState === "dehydrated") {
      const deferId = lDetails[SSR_UNIQUE_ID];
      const deferData = deferBlockParents[deferId];
      const numberOfRootNodes = deferData[NUM_ROOT_NODES];
      let collectedNodeCount = 0;
      const deferBlockCommentNode = details.lContainer[import_root_effect_scheduler.NATIVE];
      let currentNode = deferBlockCommentNode.previousSibling;
      while (collectedNodeCount < numberOfRootNodes && currentNode) {
        rootNodes.unshift(currentNode);
        currentNode = currentNode.previousSibling;
        collectedNodeCount++;
      }
    }
    const data = {
      state: stringifyState(lDetails[DEFER_BLOCK_STATE]),
      incrementalHydrationState: hydrationState,
      hasErrorBlock: tDetails.errorTmplIndex !== null,
      loadingBlock: {
        exists: tDetails.loadingTmplIndex !== null,
        minimumTime: (_b2 = (_a2 = tDetails.loadingBlockConfig) == null ? void 0 : _a2[MINIMUM_SLOT]) != null ? _b2 : null,
        afterTime: (_d2 = (_c2 = tDetails.loadingBlockConfig) == null ? void 0 : _c2[LOADING_AFTER_SLOT]) != null ? _d2 : null
      },
      placeholderBlock: {
        exists: tDetails.placeholderTmplIndex !== null,
        minimumTime: (_f2 = (_e2 = tDetails.placeholderBlockConfig) == null ? void 0 : _e2[MINIMUM_SLOT]) != null ? _f2 : null
      },
      triggers: ((_g2 = tDetails.debug) == null ? void 0 : _g2.triggers) ? Array.from(tDetails.debug.triggers).sort() : [],
      rootNodes
    };
    results.push(data);
    if (renderedLView !== null) {
      findDeferBlocks(node, renderedLView, results);
    }
  }
}
function stringifyState(state) {
  switch (state) {
    case DeferBlockState.Complete:
      return "complete";
    case DeferBlockState.Loading:
      return "loading";
    case DeferBlockState.Placeholder:
      return "placeholder";
    case DeferBlockState.Error:
      return "error";
    case DeferBlockInternalState.Initial:
      return "initial";
    default:
      throw new Error(`Unrecognized state ${state}`);
  }
}
function inferHydrationState(tDetails, lDetails, registry) {
  if (registry === null || lDetails[SSR_UNIQUE_ID] === null || tDetails.hydrateTriggers === null || tDetails.hydrateTriggers.has(
    7
    /* DeferBlockTrigger.Never */
  )) {
    return "not-configured";
  }
  return registry.has(lDetails[SSR_UNIQUE_ID]) ? "dehydrated" : "hydrated";
}
function getRendererLView(details) {
  if (details.lContainer.length <= import_root_effect_scheduler.CONTAINER_HEADER_OFFSET) {
    return null;
  }
  const lView = details.lContainer[import_root_effect_scheduler.CONTAINER_HEADER_OFFSET];
  ngDevMode && (0, import_root_effect_scheduler.assertLView)(lView);
  return lView;
}
function getDependenciesFromInjectable(injector, token) {
  const instance = injector.get(token, null, { self: true, optional: true });
  if (instance === null) {
    throw new Error(`Unable to determine instance of ${token} in given injector`);
  }
  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);
  const resolutionPath = getInjectorResolutionPath(injector);
  const dependencies = unformattedDependencies.map((dep) => {
    const formattedDependency = {
      value: dep.value
    };
    const flags = dep.flags;
    formattedDependency.flags = {
      optional: (8 & flags) === 8,
      host: (1 & flags) === 1,
      self: (2 & flags) === 2,
      skipSelf: (4 & flags) === 4
    };
    for (let i = 0; i < resolutionPath.length; i++) {
      const injectorToCheck = resolutionPath[i];
      if (i === 0 && formattedDependency.flags.skipSelf) {
        continue;
      }
      if (formattedDependency.flags.host && injectorToCheck instanceof import_root_effect_scheduler.EnvironmentInjector) {
        break;
      }
      const instance2 = injectorToCheck.get(dep.token, null, {
        self: true,
        optional: true
      });
      if (instance2 !== null) {
        if (formattedDependency.flags.host) {
          const firstInjector = resolutionPath[0];
          const lookupFromFirstInjector = firstInjector.get(dep.token, null, __spreadProps(__spreadValues({}, formattedDependency.flags), {
            optional: true
          }));
          if (lookupFromFirstInjector !== null) {
            formattedDependency.providedIn = injectorToCheck;
          }
          break;
        }
        formattedDependency.providedIn = injectorToCheck;
        break;
      }
      if (i === 0 && formattedDependency.flags.self) {
        break;
      }
    }
    if (dep.token)
      formattedDependency.token = dep.token;
    return formattedDependency;
  });
  return { instance, dependencies };
}
function getDependenciesForTokenInInjector(token, injector) {
  var _a2, _b2, _c2, _d2;
  const { resolverToTokenToDependencies } = getFrameworkDIDebugData();
  if (!(injector instanceof NodeInjector)) {
    return (_c2 = (_b2 = (_a2 = resolverToTokenToDependencies.get(injector)) == null ? void 0 : _a2.get) == null ? void 0 : _b2.call(_a2, token)) != null ? _c2 : [];
  }
  const lView = getNodeInjectorLView(injector);
  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);
  const dependencies = (_d2 = tokenDependencyMap == null ? void 0 : tokenDependencyMap.get(token)) != null ? _d2 : [];
  return dependencies.filter((dependency) => {
    var _a3;
    const dependencyNode = (_a3 = dependency.injectedIn) == null ? void 0 : _a3.tNode;
    if (dependencyNode === void 0) {
      return false;
    }
    const instanceNode = getNodeInjectorTNode(injector);
    (0, import_root_effect_scheduler.assertTNode)(dependencyNode);
    (0, import_root_effect_scheduler.assertTNode)(instanceNode);
    return dependencyNode === instanceNode;
  });
}
function getProviderImportsContainer(injector) {
  const { standaloneInjectorToComponent } = getFrameworkDIDebugData();
  if (standaloneInjectorToComponent.has(injector)) {
    return standaloneInjectorToComponent.get(injector);
  }
  const defTypeRef = injector.get(NgModuleRef$1, null, { self: true, optional: true });
  if (defTypeRef === null) {
    return null;
  }
  if (defTypeRef.instance === null) {
    return null;
  }
  return defTypeRef.instance.constructor;
}
function getNodeInjectorProviders(injector) {
  var _a2;
  const diResolver = getNodeInjectorTNode(injector);
  const { resolverToProviders } = getFrameworkDIDebugData();
  return (_a2 = resolverToProviders.get(diResolver)) != null ? _a2 : [];
}
function getProviderImportPaths(providerImportsContainer) {
  const providerToPath = /* @__PURE__ */ new Map();
  const visitedContainers = /* @__PURE__ */ new Set();
  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);
  (0, import_root_effect_scheduler.walkProviderTree)(providerImportsContainer, visitor, [], /* @__PURE__ */ new Set());
  return providerToPath;
}
function walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {
  return (provider, container) => {
    if (!providerToPath.has(provider)) {
      providerToPath.set(provider, [container]);
    }
    if (!visitedContainers.has(container)) {
      for (const prov of providerToPath.keys()) {
        const existingImportPath = providerToPath.get(prov);
        let containerDef = (0, import_root_effect_scheduler.getInjectorDef)(container);
        if (!containerDef) {
          const ngModule = container.ngModule;
          containerDef = (0, import_root_effect_scheduler.getInjectorDef)(ngModule);
        }
        if (!containerDef) {
          return;
        }
        const lastContainerAddedToPath = existingImportPath[0];
        let isNextStepInPath = false;
        (0, import_root_effect_scheduler.deepForEach)(containerDef.imports, (moduleImport) => {
          var _a2;
          if (isNextStepInPath) {
            return;
          }
          isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;
          if (isNextStepInPath) {
            (_a2 = providerToPath.get(prov)) == null ? void 0 : _a2.unshift(container);
          }
        });
      }
    }
    visitedContainers.add(container);
  };
}
function getEnvironmentInjectorProviders(injector) {
  var _a2, _b2;
  const providerRecordsWithoutImportPaths = (_a2 = getFrameworkDIDebugData().resolverToProviders.get(injector)) != null ? _a2 : [];
  if (isPlatformInjector(injector)) {
    return providerRecordsWithoutImportPaths;
  }
  const providerImportsContainer = getProviderImportsContainer(injector);
  if (providerImportsContainer === null) {
    return providerRecordsWithoutImportPaths;
  }
  const providerToPath = getProviderImportPaths(providerImportsContainer);
  const providerRecords = [];
  for (const providerRecord of providerRecordsWithoutImportPaths) {
    const provider = providerRecord.provider;
    const token = provider.provide;
    if (token === import_root_effect_scheduler.ENVIRONMENT_INITIALIZER || token === import_root_effect_scheduler.INJECTOR_DEF_TYPES) {
      continue;
    }
    let importPath = (_b2 = providerToPath.get(provider)) != null ? _b2 : [];
    const def = (0, import_root_effect_scheduler.getComponentDef)(providerImportsContainer);
    const isStandaloneComponent2 = !!(def == null ? void 0 : def.standalone);
    if (isStandaloneComponent2) {
      importPath = [providerImportsContainer, ...importPath];
    }
    providerRecords.push(__spreadProps(__spreadValues({}, providerRecord), { importPath }));
  }
  return providerRecords;
}
function isPlatformInjector(injector) {
  return injector instanceof import_root_effect_scheduler.R3Injector && injector.scopes.has("platform");
}
function getInjectorProviders(injector) {
  if (injector instanceof NodeInjector) {
    return getNodeInjectorProviders(injector);
  } else if (injector instanceof import_root_effect_scheduler.EnvironmentInjector) {
    return getEnvironmentInjectorProviders(injector);
  }
  (0, import_root_effect_scheduler.throwError)("getInjectorProviders only supports NodeInjector and EnvironmentInjector");
}
function getInjectorMetadata(injector) {
  var _a2;
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    const tNode = getNodeInjectorTNode(injector);
    (0, import_root_effect_scheduler.assertTNodeForLView)(tNode, lView);
    return { type: "element", source: (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView) };
  }
  if (injector instanceof import_root_effect_scheduler.R3Injector) {
    return { type: "environment", source: (_a2 = injector.source) != null ? _a2 : null };
  }
  if (injector instanceof import_root_effect_scheduler.NullInjector) {
    return { type: "null", source: null };
  }
  return null;
}
function getInjectorResolutionPath(injector) {
  const resolutionPath = [injector];
  getInjectorResolutionPathHelper(injector, resolutionPath);
  return resolutionPath;
}
function getInjectorResolutionPathHelper(injector, resolutionPath) {
  const parent = getInjectorParent(injector);
  if (parent === null) {
    if (injector instanceof NodeInjector) {
      const firstInjector = resolutionPath[0];
      if (firstInjector instanceof NodeInjector) {
        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);
        if (moduleInjector === null) {
          (0, import_root_effect_scheduler.throwError)("NodeInjector must have some connection to the module injector tree");
        }
        resolutionPath.push(moduleInjector);
        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);
      }
      return resolutionPath;
    }
  } else {
    resolutionPath.push(parent);
    getInjectorResolutionPathHelper(parent, resolutionPath);
  }
  return resolutionPath;
}
function getInjectorParent(injector) {
  var _a2;
  if (injector instanceof import_root_effect_scheduler.R3Injector) {
    return injector.parent;
  }
  let tNode;
  let lView;
  if (injector instanceof NodeInjector) {
    tNode = getNodeInjectorTNode(injector);
    lView = getNodeInjectorLView(injector);
  } else if (injector instanceof import_root_effect_scheduler.NullInjector) {
    return null;
  } else if (injector instanceof ChainedInjector) {
    return injector.parentInjector;
  } else {
    (0, import_root_effect_scheduler.throwError)("getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector");
  }
  const parentLocation = getParentInjectorLocation(tNode, lView);
  if (hasParentInjector(parentLocation)) {
    const parentInjectorIndex = getParentInjectorIndex(parentLocation);
    const parentLView = getParentInjectorView(parentLocation, lView);
    const parentTView = parentLView[import_root_effect_scheduler.TVIEW];
    const parentTNode = parentTView.data[
      parentInjectorIndex + 8
      /* NodeInjectorOffset.TNODE */
    ];
    return new NodeInjector(parentTNode, parentLView);
  } else {
    const chainedInjector = lView[import_root_effect_scheduler.INJECTOR$1];
    const injectorParent = (_a2 = chainedInjector.injector) == null ? void 0 : _a2.parent;
    if (injectorParent instanceof NodeInjector) {
      return injectorParent;
    }
  }
  return null;
}
function getModuleInjectorOfNodeInjector(injector) {
  let lView;
  if (injector instanceof NodeInjector) {
    lView = getNodeInjectorLView(injector);
  } else {
    (0, import_root_effect_scheduler.throwError)("getModuleInjectorOfNodeInjector must be called with a NodeInjector");
  }
  const inj = lView[import_root_effect_scheduler.INJECTOR$1];
  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;
  if (!moduleInjector) {
    (0, import_root_effect_scheduler.throwError)("NodeInjector must have some connection to the module injector tree");
  }
  return moduleInjector;
}
function isComputedNode(node) {
  return node.kind === "computed";
}
function isTemplateEffectNode(node) {
  return node.kind === "template";
}
function isSignalNode(node) {
  return node.kind === "signal";
}
function getTemplateConsumer(injector) {
  var _a2;
  const tNode = getNodeInjectorTNode(injector);
  (0, import_root_effect_scheduler.assertTNode)(tNode);
  const lView = getNodeInjectorLView(injector);
  (0, import_root_effect_scheduler.assertLView)(lView);
  const templateLView = lView[tNode.index];
  if ((0, import_root_effect_scheduler.isLView)(templateLView)) {
    return (_a2 = templateLView[import_root_effect_scheduler.REACTIVE_TEMPLATE_CONSUMER]) != null ? _a2 : null;
  }
  return null;
}
const signalDebugMap = /* @__PURE__ */ new WeakMap();
let counter$1 = 0;
function getNodesAndEdgesFromSignalMap(signalMap) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
  const nodes = Array.from(signalMap.keys());
  const debugSignalGraphNodes = [];
  const edges = [];
  for (const [consumer, producers] of signalMap.entries()) {
    const consumerIndex = nodes.indexOf(consumer);
    let id = signalDebugMap.get(consumer);
    if (!id) {
      counter$1++;
      id = counter$1.toString();
      signalDebugMap.set(consumer, id);
    }
    if (isComputedNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        value: consumer.value,
        kind: consumer.kind,
        epoch: consumer.version,
        debuggableFn: consumer.computation,
        id
      });
    } else if (isSignalNode(consumer)) {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        value: consumer.value,
        kind: consumer.kind,
        epoch: consumer.version,
        id
      });
    } else if (isTemplateEffectNode(consumer)) {
      debugSignalGraphNodes.push({
        label: (_e2 = consumer.debugName) != null ? _e2 : (_d2 = (_c2 = (_b2 = (_a2 = consumer.lView) == null ? void 0 : _a2[import_root_effect_scheduler.HOST]) == null ? void 0 : _b2.tagName) == null ? void 0 : _c2.toLowerCase) == null ? void 0 : _d2.call(_c2),
        kind: consumer.kind,
        epoch: consumer.version,
        // The `lView[CONTEXT]` is a reference to an instance of the component's class.
        // We get the constructor so that `inspect(.constructor)` shows the component class.
        debuggableFn: (_g2 = (_f2 = consumer.lView) == null ? void 0 : _f2[import_root_effect_scheduler.CONTEXT]) == null ? void 0 : _g2.constructor,
        id
      });
    } else {
      debugSignalGraphNodes.push({
        label: consumer.debugName,
        kind: consumer.kind,
        epoch: consumer.version,
        id
      });
    }
    for (const producer of producers) {
      edges.push({ consumer: consumerIndex, producer: nodes.indexOf(producer) });
    }
  }
  return { nodes: debugSignalGraphNodes, edges };
}
function extractEffectsFromInjector(injector) {
  var _a2;
  let diResolver = injector;
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    diResolver = lView;
  }
  const resolverToEffects = getFrameworkDIDebugData().resolverToEffects;
  const effects = (_a2 = resolverToEffects.get(diResolver)) != null ? _a2 : [];
  return effects.map((effect) => effect[import_signal.SIGNAL]);
}
function extractSignalNodesAndEdgesFromRoots(nodes, signalDependenciesMap = /* @__PURE__ */ new Map()) {
  for (const node of nodes) {
    if (signalDependenciesMap.has(node)) {
      continue;
    }
    const producerNodes = [];
    for (let link = node.producers; link !== void 0; link = link.nextProducer) {
      const producer = link.producer;
      producerNodes.push(producer);
    }
    signalDependenciesMap.set(node, producerNodes);
    extractSignalNodesAndEdgesFromRoots(producerNodes, signalDependenciesMap);
  }
  return signalDependenciesMap;
}
function getSignalGraph(injector) {
  let templateConsumer = null;
  if (!(injector instanceof NodeInjector) && !(injector instanceof import_root_effect_scheduler.R3Injector)) {
    return (0, import_root_effect_scheduler.throwError)("getSignalGraph must be called with a NodeInjector or R3Injector");
  }
  if (injector instanceof NodeInjector) {
    templateConsumer = getTemplateConsumer(injector);
  }
  const nonTemplateEffectNodes = extractEffectsFromInjector(injector);
  const signalNodes = templateConsumer ? [templateConsumer, ...nonTemplateEffectNodes] : nonTemplateEffectNodes;
  const signalDependenciesMap = extractSignalNodesAndEdgesFromRoots(signalNodes);
  return getNodesAndEdgesFromSignalMap(signalDependenciesMap);
}
let changeDetectionRuns = 0;
let changeDetectionSyncRuns = 0;
let counter = 0;
const eventsStack = [];
function measureStart(startEvent) {
  eventsStack.push([startEvent, counter]);
  console.timeStamp("Event_" + startEvent + "_" + counter++);
}
function measureEnd(startEvent, entryName, color) {
  const top = eventsStack.pop();
  (0, import_root_effect_scheduler.assertDefined)(top, "Profiling error: could not find start event entry " + startEvent);
  (0, import_root_effect_scheduler.assertEqual)(top[0], startEvent, `Profiling error: expected to see ${startEvent} event but got ${top[0]}`);
  console.timeStamp(entryName, "Event_" + top[0] + "_" + top[1], void 0, "\u{1F170}\uFE0F Angular", void 0, color);
}
const chromeDevToolsInjectorProfiler = (event) => {
  const eventType = event.type;
  if (eventType === 4) {
    measureStart(
      100
      /* ProfilerDIEvent.InjectorToCreateInstanceEvent */
    );
  } else if (eventType === 1) {
    const token = event.context.token;
    measureEnd(100, getProviderTokenMeasureName(token), "tertiary-dark");
  }
};
const devToolsProfiler = (event, instance, eventFn) => {
  switch (event) {
    case 8:
    case 10:
    case 12:
    case 14:
    case 16:
    case 18:
    case 20:
    case 22:
    case 0:
    case 4:
    case 2:
    case 24:
    case 6: {
      measureStart(event);
      break;
    }
    case 9: {
      measureEnd(8, "Bootstrap application", "primary-dark");
      break;
    }
    case 11: {
      measureEnd(10, "Bootstrap component", "primary-dark");
      break;
    }
    case 13: {
      changeDetectionSyncRuns = 0;
      measureEnd(12, "Change detection " + changeDetectionRuns++, "primary-dark");
      break;
    }
    case 15: {
      measureEnd(14, "Synchronization " + changeDetectionSyncRuns++, "primary");
      break;
    }
    case 17: {
      measureEnd(16, "After render hooks", "primary");
      break;
    }
    case 19: {
      const typeName = getComponentMeasureName(instance);
      measureEnd(18, typeName, "primary-light");
      break;
    }
    case 21: {
      measureEnd(20, "Defer block", "primary-dark");
      break;
    }
    case 23: {
      measureEnd(22, "Dynamic component creation", "primary-dark");
      break;
    }
    case 3: {
      measureEnd(2, (0, import_root_effect_scheduler.stringifyForError)(eventFn) + " (update)", "secondary-dark");
      break;
    }
    case 1: {
      measureEnd(0, (0, import_root_effect_scheduler.stringifyForError)(eventFn) + " (create)", "secondary");
      break;
    }
    case 25: {
      measureEnd(24, "HostBindings", "secondary-dark");
      break;
    }
    case 5: {
      const typeName = getComponentMeasureName(instance);
      measureEnd(4, `${typeName}:${(0, import_root_effect_scheduler.stringifyForError)(eventFn)}`, "tertiary");
      break;
    }
    case 7: {
      measureEnd(6, (0, import_root_effect_scheduler.stringifyForError)(eventFn), "tertiary-light");
      break;
    }
    default: {
      throw new Error("Unexpected profiling event type: " + event);
    }
  }
};
function getComponentMeasureName(instance) {
  return instance.constructor.name;
}
function getProviderTokenMeasureName(token) {
  if ((0, import_root_effect_scheduler.isTypeProvider)(token)) {
    return token.name;
  } else if (token.provide != null) {
    return getProviderTokenMeasureName(token.provide);
  }
  return token.toString();
}
function enableProfiling() {
  performanceMarkFeature("Chrome DevTools profiling");
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    const removeInjectorProfiler = (0, import_root_effect_scheduler.setInjectorProfiler)(chromeDevToolsInjectorProfiler);
    const removeProfiler2 = setProfiler(devToolsProfiler);
    return () => {
      removeInjectorProfiler();
      removeProfiler2();
    };
  }
  return () => {
  };
}
function getTransferState(injector) {
  const doc = getDocument();
  const appId = injector.get(APP_ID);
  const transferState = retrieveTransferredState(doc, appId);
  const filteredEntries = {};
  for (const [key, value] of Object.entries(transferState)) {
    if (!isInternalHydrationTransferStateKey(key)) {
      filteredEntries[key] = value;
    }
  }
  return filteredEntries;
}
const GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
const globalUtilsFunctions = {
  /**
   * Warning: functions that start with `` are considered *INTERNAL* and should not be relied upon
   * in application's code. The contract of those functions might be changed in any release and/or a
   * function can be removed completely.
   */
  "\u0275getDependenciesFromInjectable": getDependenciesFromInjectable,
  "\u0275getInjectorProviders": getInjectorProviders,
  "\u0275getInjectorResolutionPath": getInjectorResolutionPath,
  "\u0275getInjectorMetadata": getInjectorMetadata,
  "\u0275setProfiler": setProfiler,
  "\u0275getSignalGraph": getSignalGraph,
  "\u0275getDeferBlocks": getDeferBlocks,
  "\u0275getTransferState": getTransferState,
  "getDirectiveMetadata": getDirectiveMetadata$1,
  "getComponent": getComponent,
  "getContext": getContext,
  "getListeners": getListeners,
  "getOwningComponent": getOwningComponent,
  "getHostElement": getHostElement,
  "getInjector": getInjector,
  "getRootComponents": getRootComponents,
  "getDirectives": getDirectives,
  "applyChanges": applyChanges,
  "isSignal": import_root_effect_scheduler.isSignal,
  "enableProfiling": enableProfiling
};
let _published = false;
function publishDefaultGlobalUtils$1() {
  if (!_published) {
    _published = true;
    if (typeof window !== "undefined") {
      setupFrameworkInjectorProfiler();
    }
    for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {
      publishGlobalUtil(methodName, method);
    }
  }
}
function publishGlobalUtil(name, fn) {
  publishUtil(name, fn);
}
function publishExternalGlobalUtil(name, fn) {
  publishUtil(name, fn);
}
function publishUtil(name, fn) {
  var _a2;
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const w = import_root_effect_scheduler._global;
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(fn, "function not defined");
    (_a2 = w[GLOBAL_PUBLISH_EXPANDO_KEY]) != null ? _a2 : w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};
    w[GLOBAL_PUBLISH_EXPANDO_KEY][name] = fn;
  }
}
const TESTABILITY = new import_root_effect_scheduler.InjectionToken("");
const TESTABILITY_GETTER = new import_root_effect_scheduler.InjectionToken("");
const _Testability = class _Testability {
  constructor(_ngZone, registry, testabilityGetter) {
    __publicField(this, "_ngZone");
    __publicField(this, "registry");
    __publicField(this, "_isZoneStable", true);
    __publicField(this, "_callbacks", []);
    __publicField(this, "_taskTrackingZone", null);
    __publicField(this, "_destroyRef");
    var _a2;
    this._ngZone = _ngZone;
    this.registry = registry;
    if ((0, import_root_effect_scheduler.isInInjectionContext)()) {
      this._destroyRef = (_a2 = (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.DestroyRef, { optional: true })) != null ? _a2 : void 0;
    }
    if (!_testabilityGetter) {
      setTestabilityGetter(testabilityGetter);
      testabilityGetter.addToWindow(registry);
    }
    this._watchAngularEvents();
    _ngZone.run(() => {
      this._taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
    });
  }
  _watchAngularEvents() {
    var _a2;
    const onUnstableSubscription = this._ngZone.onUnstable.subscribe({
      next: () => {
        this._isZoneStable = false;
      }
    });
    const onStableSubscription = this._ngZone.runOutsideAngular(() => this._ngZone.onStable.subscribe({
      next: () => {
        NgZone.assertNotInAngularZone();
        queueMicrotask(() => {
          this._isZoneStable = true;
          this._runCallbacksIfReady();
        });
      }
    }));
    (_a2 = this._destroyRef) == null ? void 0 : _a2.onDestroy(() => {
      onUnstableSubscription.unsubscribe();
      onStableSubscription.unsubscribe();
    });
  }
  /**
   * Whether an associated application is stable
   */
  isStable() {
    return this._isZoneStable && !this._ngZone.hasPendingMacrotasks;
  }
  _runCallbacksIfReady() {
    if (this.isStable()) {
      queueMicrotask(() => {
        while (this._callbacks.length !== 0) {
          let cb = this._callbacks.pop();
          clearTimeout(cb.timeoutId);
          cb.doneCb();
        }
      });
    } else {
      let pending = this.getPendingTasks();
      this._callbacks = this._callbacks.filter((cb) => {
        if (cb.updateCb && cb.updateCb(pending)) {
          clearTimeout(cb.timeoutId);
          return false;
        }
        return true;
      });
    }
  }
  getPendingTasks() {
    if (!this._taskTrackingZone) {
      return [];
    }
    return this._taskTrackingZone.macroTasks.map((t) => {
      return {
        source: t.source,
        // From TaskTrackingZone:
        // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
        creationLocation: t.creationLocation,
        data: t.data
      };
    });
  }
  addCallback(cb, timeout, updateCb) {
    let timeoutId = -1;
    if (timeout && timeout > 0) {
      timeoutId = setTimeout(() => {
        this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
        cb();
      }, timeout);
    }
    this._callbacks.push({ doneCb: cb, timeoutId, updateCb });
  }
  /**
   * Wait for the application to be stable with a timeout. If the timeout is reached before that
   * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
   *
   * @param doneCb The callback to invoke when Angular is stable or the timeout expires
   *    whichever comes first.
   * @param timeout Optional. The maximum time to wait for Angular to become stable. If not
   *    specified, whenStable() will wait forever.
   * @param updateCb Optional. If specified, this callback will be invoked whenever the set of
   *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
   *    and no further updates will be issued.
   */
  whenStable(doneCb, timeout, updateCb) {
    if (updateCb && !this._taskTrackingZone) {
      throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
    }
    this.addCallback(doneCb, timeout, updateCb);
    this._runCallbacksIfReady();
  }
  /**
   * Registers an application with a testability hook so that it can be tracked.
   * @param token token of application, root element
   *
   * @internal
   */
  registerApplication(token) {
    this.registry.registerApplication(token, this);
  }
  /**
   * Unregisters an application.
   * @param token token of application, root element
   *
   * @internal
   */
  unregisterApplication(token) {
    this.registry.unregisterApplication(token);
  }
  /**
   * Find providers by name
   * @param using The root element to search from
   * @param provider The name of binding variable
   * @param exactMatch Whether using exactMatch
   */
  findProviders(using, provider, exactMatch) {
    return [];
  }
};
__publicField(_Testability, "\u0275fac", function Testability_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _Testability)((0, import_root_effect_scheduler.\u0275\u0275inject)(NgZone), (0, import_root_effect_scheduler.\u0275\u0275inject)(TestabilityRegistry), (0, import_root_effect_scheduler.\u0275\u0275inject)(TESTABILITY_GETTER));
});
__publicField(_Testability, "\u0275prov", /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({ token: _Testability, factory: _Testability.\u0275fac }));
let Testability = _Testability;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
    type: Injectable
  }], () => [{ type: NgZone }, { type: TestabilityRegistry }, { type: void 0, decorators: [{
    type: Inject,
    args: [TESTABILITY_GETTER]
  }] }], null);
})();
const _TestabilityRegistry = class _TestabilityRegistry {
  constructor() {
    /** @internal */
    __publicField(this, "_applications", /* @__PURE__ */ new Map());
  }
  /**
   * Registers an application with a testability hook so that it can be tracked
   * @param token token of application, root element
   * @param testability Testability hook
   */
  registerApplication(token, testability) {
    this._applications.set(token, testability);
  }
  /**
   * Unregisters an application.
   * @param token token of application, root element
   */
  unregisterApplication(token) {
    this._applications.delete(token);
  }
  /**
   * Unregisters all applications
   */
  unregisterAllApplications() {
    this._applications.clear();
  }
  /**
   * Get a testability hook associated with the application
   * @param elem root element
   */
  getTestability(elem) {
    return this._applications.get(elem) || null;
  }
  /**
   * Get all registered testabilities
   */
  getAllTestabilities() {
    return Array.from(this._applications.values());
  }
  /**
   * Get all registered applications(root elements)
   */
  getAllRootElements() {
    return Array.from(this._applications.keys());
  }
  /**
   * Find testability of a node in the Tree
   * @param elem node
   * @param findInAncestors whether finding testability in ancestors if testability was not found in
   * current node
   */
  findTestabilityInTree(elem, findInAncestors = true) {
    var _a2;
    return (_a2 = _testabilityGetter == null ? void 0 : _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors)) != null ? _a2 : null;
  }
};
__publicField(_TestabilityRegistry, "\u0275fac", function TestabilityRegistry_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TestabilityRegistry)();
});
__publicField(_TestabilityRegistry, "\u0275prov", /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({ token: _TestabilityRegistry, factory: _TestabilityRegistry.\u0275fac, providedIn: "platform" }));
let TestabilityRegistry = _TestabilityRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
    type: Injectable,
    args: [{ providedIn: "platform" }]
  }], null, null);
})();
function setTestabilityGetter(getter) {
  _testabilityGetter = getter;
}
let _testabilityGetter;
function isPromise(obj) {
  return !!obj && typeof obj.then === "function";
}
function isSubscribable(obj) {
  return !!obj && typeof obj.subscribe === "function";
}
const APP_INITIALIZER = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "Application Initializer" : "");
function provideAppInitializer(initializerFn) {
  return (0, import_root_effect_scheduler.makeEnvironmentProviders)([
    {
      provide: APP_INITIALIZER,
      multi: true,
      useValue: initializerFn
    }
  ]);
}
const _ApplicationInitStatus = class _ApplicationInitStatus {
  constructor() {
    // Using non null assertion, these fields are defined below
    // within the `new Promise` callback (synchronously).
    __publicField(this, "resolve");
    __publicField(this, "reject");
    __publicField(this, "initialized", false);
    __publicField(this, "done", false);
    __publicField(this, "donePromise", new Promise((res, rej) => {
      this.resolve = res;
      this.reject = rej;
    }));
    __publicField(this, "appInits", (_c = (0, import_root_effect_scheduler.inject)(APP_INITIALIZER, { optional: true })) != null ? _c : []);
    __publicField(this, "injector", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.Injector));
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !Array.isArray(this.appInits)) {
      throw new import_root_effect_scheduler.RuntimeError(-209, `Unexpected type of the \`APP_INITIALIZER\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \`APP_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
    }
  }
  /** @internal */
  runInitializers() {
    if (this.initialized) {
      return;
    }
    const asyncInitPromises = [];
    for (const appInits of this.appInits) {
      const initResult = (0, import_root_effect_scheduler.runInInjectionContext)(this.injector, appInits);
      if (isPromise(initResult)) {
        asyncInitPromises.push(initResult);
      } else if (isSubscribable(initResult)) {
        const observableAsPromise = new Promise((resolve, reject) => {
          initResult.subscribe({ complete: resolve, error: reject });
        });
        asyncInitPromises.push(observableAsPromise);
      }
    }
    const complete = () => {
      this.done = true;
      this.resolve();
    };
    Promise.all(asyncInitPromises).then(() => {
      complete();
    }).catch((e) => {
      this.reject(e);
    });
    if (asyncInitPromises.length === 0) {
      complete();
    }
    this.initialized = true;
  }
};
__publicField(_ApplicationInitStatus, "\u0275fac", function ApplicationInitStatus_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ApplicationInitStatus)();
});
__publicField(_ApplicationInitStatus, "\u0275prov", /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({ token: _ApplicationInitStatus, factory: _ApplicationInitStatus.\u0275fac, providedIn: "root" }));
let ApplicationInitStatus = _ApplicationInitStatus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], () => [], null);
})();
const APP_BOOTSTRAP_LISTENER = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "appBootstrapListener" : "");
function publishDefaultGlobalUtils() {
  ngDevMode && publishDefaultGlobalUtils$1();
}
function publishSignalConfiguration() {
  (0, import_signal.setThrowInvalidWriteToSignalError)(() => {
    let errorMessage = "";
    if (ngDevMode) {
      const activeConsumer = (0, import_signal.getActiveConsumer)();
      errorMessage = activeConsumer && isReactiveLViewConsumer(activeConsumer) ? "Writing to signals is not allowed while Angular renders the template (eg. interpolations)" : "Writing to signals is not allowed in a `computed`";
    }
    throw new import_root_effect_scheduler.RuntimeError(600, errorMessage);
  });
}
function isBoundToModule(cf) {
  return cf.isBoundToModule;
}
class NgProbeToken {
  constructor(name, token) {
    __publicField(this, "name");
    __publicField(this, "token");
    this.name = name;
    this.token = token;
  }
}
const MAXIMUM_REFRESH_RERUNS = 10;
function optionsReducer(dst, objs) {
  if (Array.isArray(objs)) {
    return objs.reduce(optionsReducer, dst);
  }
  return __spreadValues(__spreadValues({}, dst), objs);
}
const _ApplicationRef = class _ApplicationRef {
  constructor() {
    /** @internal */
    __publicField(this, "_runningTick", false);
    __publicField(this, "_destroyed", false);
    __publicField(this, "_destroyListeners", []);
    /** @internal */
    __publicField(this, "_views", []);
    __publicField(this, "internalErrorHandler", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.INTERNAL_APPLICATION_ERROR_HANDLER));
    __publicField(this, "afterRenderManager", (0, import_root_effect_scheduler.inject)(AfterRenderManager));
    __publicField(this, "zonelessEnabled", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.ZONELESS_ENABLED));
    __publicField(this, "rootEffectScheduler", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.EffectScheduler));
    /**
     * Current dirty state of the application across a number of dimensions (views, afterRender hooks,
     * etc).
     *
     * A flag set here means that `tick()` will attempt to resolve the dirtiness when executed.
     *
     * @internal
     */
    __publicField(this, "dirtyFlags", 0);
    /**
     * Most recent snapshot from the `TracingService`, if any.
     *
     * This snapshot attempts to capture the context when `tick()` was first
     * scheduled. It then runs wrapped in this context.
     *
     * @internal
     */
    __publicField(this, "tracingSnapshot", null);
    // Needed for ComponentFixture temporarily during migration of autoDetect behavior
    // Eventually the hostView of the fixture should just attach to ApplicationRef.
    __publicField(this, "allTestViews", /* @__PURE__ */ new Set());
    __publicField(this, "autoDetectTestViews", /* @__PURE__ */ new Set());
    __publicField(this, "includeAllTestViews", false);
    /** @internal */
    __publicField(this, "afterTick", new import_rxjs.Subject());
    /**
     * Get a list of component types registered to this application.
     * This list is populated even before the component is created.
     */
    __publicField(this, "componentTypes", []);
    /**
     * Get a list of components registered to this application.
     */
    __publicField(this, "components", []);
    __publicField(this, "internalPendingTask", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.PendingTasksInternal));
    __publicField(this, "_injector", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.EnvironmentInjector));
    __publicField(this, "_rendererFactory", null);
    __publicField(this, "tickImpl", () => {
      var _a2;
      (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
      if (this._runningTick) {
        throw new import_root_effect_scheduler.RuntimeError(101, ngDevMode && "ApplicationRef.tick is called recursively");
      }
      const prevConsumer = (0, import_signal.setActiveConsumer)(null);
      try {
        this._runningTick = true;
        this.synchronize();
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          for (let view of this.allViews) {
            view.checkNoChanges();
          }
        }
      } finally {
        this._runningTick = false;
        (_a2 = this.tracingSnapshot) == null ? void 0 : _a2.dispose();
        this.tracingSnapshot = null;
        (0, import_signal.setActiveConsumer)(prevConsumer);
        this.afterTick.next();
        profiler(
          13
          /* ProfilerEvent.ChangeDetectionEnd */
        );
      }
    });
    (0, import_root_effect_scheduler.inject)(TracingService, { optional: true });
  }
  /** @internal */
  get allViews() {
    return [
      ...(this.includeAllTestViews ? this.allTestViews : this.autoDetectTestViews).keys(),
      ...this._views
    ];
  }
  /**
   * Indicates whether this instance was destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  /**
   * Returns an Observable that indicates when the application is stable or unstable.
   */
  get isStable() {
    return this.internalPendingTask.hasPendingTasksObservable.pipe((0, import_operators.map)((pending) => !pending));
  }
  /**
   * @returns A promise that resolves when the application becomes stable
   */
  whenStable() {
    let subscription;
    return new Promise((resolve) => {
      subscription = this.isStable.subscribe({
        next: (stable) => {
          if (stable) {
            resolve();
          }
        }
      });
    }).finally(() => {
      subscription.unsubscribe();
    });
  }
  /**
   * The `EnvironmentInjector` used to create this application.
   */
  get injector() {
    return this._injector;
  }
  /**
   * Bootstrap a component onto the element identified by its selector or, optionally, to a
   * specified element.
   *
   * @usageNotes
   * ### Bootstrap process
   *
   * When bootstrapping a component, Angular mounts it onto a target DOM element
   * and kicks off automatic change detection. The target DOM element can be
   * provided using the `rootSelectorOrNode` argument.
   *
   * If the target DOM element is not provided, Angular tries to find one on a page
   * using the `selector` of the component that is being bootstrapped
   * (first matched element is used).
   *
   * ### Example
   *
   * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,
   * but it requires us to know the component while writing the application code.
   *
   * Imagine a situation where we have to wait for an API call to decide about the component to
   * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to
   * dynamically bootstrap a component.
   *
   * {@example core/ts/platform/platform.ts region='componentSelector'}
   *
   * Optionally, a component can be mounted onto a DOM element that does not match the
   * selector of the bootstrapped component.
   *
   * In the following example, we are providing a CSS selector to match the target element.
   *
   * {@example core/ts/platform/platform.ts region='cssSelector'}
   *
   * While in this example, we are providing reference to a DOM node.
   *
   * {@example core/ts/platform/platform.ts region='domNode'}
   */
  bootstrap(componentOrFactory, rootSelectorOrNode) {
    return this.bootstrapImpl(componentOrFactory, rootSelectorOrNode);
  }
  bootstrapImpl(componentOrFactory, rootSelectorOrNode, injector = import_root_effect_scheduler.Injector.NULL) {
    const ngZone = this._injector.get(NgZone);
    return ngZone.run(() => {
      profiler(
        10
        /* ProfilerEvent.BootstrapComponentStart */
      );
      (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
      const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
      const initStatus = this._injector.get(ApplicationInitStatus);
      if (!initStatus.done) {
        let errorMessage = "";
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const standalone = !isComponentFactory && (0, import_root_effect_scheduler.isStandalone)(componentOrFactory);
          errorMessage = "Cannot bootstrap as there are still asynchronous initializers running." + (standalone ? "" : " Bootstrap components in the `ngDoBootstrap` method of the root module.");
        }
        throw new import_root_effect_scheduler.RuntimeError(405, errorMessage);
      }
      let componentFactory;
      if (isComponentFactory) {
        componentFactory = componentOrFactory;
      } else {
        const resolver = this._injector.get(ComponentFactoryResolver$1);
        componentFactory = resolver.resolveComponentFactory(componentOrFactory);
      }
      this.componentTypes.push(componentFactory.componentType);
      const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
      const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
      const compRef = componentFactory.create(injector, [], selectorOrNode, ngModule);
      const nativeElement = compRef.location.nativeElement;
      const testability = compRef.injector.get(TESTABILITY, null);
      testability == null ? void 0 : testability.registerApplication(nativeElement);
      compRef.onDestroy(() => {
        this.detachView(compRef.hostView);
        remove(this.components, compRef);
        testability == null ? void 0 : testability.unregisterApplication(nativeElement);
      });
      this._loadComponent(compRef);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        const _console = this._injector.get(Console);
        _console.log(`Angular is running in development mode.`);
      }
      profiler(11, compRef);
      return compRef;
    });
  }
  /**
   * Invoke this method to explicitly process change detection and its side-effects.
   *
   * In development mode, `tick()` also performs a second change detection cycle to ensure that no
   * further changes are detected. If additional changes are picked up during this second cycle,
   * bindings in the app have side-effects that cannot be resolved in a single change detection
   * pass.
   * In this case, Angular throws an error, since an Angular application can only have one change
   * detection pass during which all change detection must complete.
   */
  tick() {
    if (!this.zonelessEnabled) {
      this.dirtyFlags |= 1;
    }
    this._tick();
  }
  /** @internal */
  _tick() {
    profiler(
      12
      /* ProfilerEvent.ChangeDetectionStart */
    );
    if (this.tracingSnapshot !== null) {
      this.tracingSnapshot.run(TracingAction.CHANGE_DETECTION, this.tickImpl);
    } else {
      this.tickImpl();
    }
  }
  /**
   * Performs the core work of synchronizing the application state with the UI, resolving any
   * pending dirtiness (potentially in a loop).
   */
  synchronize() {
    if (this._rendererFactory === null && !this._injector.destroyed) {
      this._rendererFactory = this._injector.get(RendererFactory2, null, { optional: true });
    }
    let runs = 0;
    while (this.dirtyFlags !== 0 && runs++ < MAXIMUM_REFRESH_RERUNS) {
      profiler(
        14
        /* ProfilerEvent.ChangeDetectionSyncStart */
      );
      this.synchronizeOnce();
      profiler(
        15
        /* ProfilerEvent.ChangeDetectionSyncEnd */
      );
    }
    if ((typeof ngDevMode === "undefined" || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {
      throw new import_root_effect_scheduler.RuntimeError(103, ngDevMode && "Infinite change detection while refreshing application views. Ensure views are not calling `markForCheck` on every template execution or that afterRender hooks always mark views for check.");
    }
  }
  /**
   * Perform a single synchronization pass.
   */
  synchronizeOnce() {
    var _a2, _b2, _c2, _d2;
    if (this.dirtyFlags & 16) {
      this.dirtyFlags &= ~16;
      this.rootEffectScheduler.flush();
    }
    let ranDetectChanges = false;
    if (this.dirtyFlags & 7) {
      const useGlobalCheck = Boolean(
        this.dirtyFlags & 1
        /* ApplicationRefDirtyFlags.ViewTreeGlobal */
      );
      this.dirtyFlags &= ~7;
      this.dirtyFlags |= 8;
      for (let { _lView } of this.allViews) {
        if (!useGlobalCheck && !(0, import_root_effect_scheduler.requiresRefreshOrTraversal)(_lView)) {
          continue;
        }
        const mode = useGlobalCheck && !this.zonelessEnabled ? (
          // Global mode includes `CheckAlways` views.
          0
        ) : (
          // Only refresh views with the `RefreshView` flag or views is a changed signal
          1
        );
        detectChangesInternal(_lView, mode);
        ranDetectChanges = true;
      }
      this.dirtyFlags &= ~4;
      this.syncDirtyFlagsWithViews();
      if (this.dirtyFlags & (7 | 16)) {
        return;
      }
    }
    if (!ranDetectChanges) {
      (_b2 = (_a2 = this._rendererFactory) == null ? void 0 : _a2.begin) == null ? void 0 : _b2.call(_a2);
      (_d2 = (_c2 = this._rendererFactory) == null ? void 0 : _c2.end) == null ? void 0 : _d2.call(_c2);
    }
    if (this.dirtyFlags & 8) {
      this.dirtyFlags &= ~8;
      this.afterRenderManager.execute();
    }
    this.syncDirtyFlagsWithViews();
  }
  /**
   * Checks `allViews` for views which require refresh/traversal, and updates `dirtyFlags`
   * accordingly, with two potential behaviors:
   *
   * 1. If any of our views require updating, then this adds the `ViewTreeTraversal` dirty flag.
   *    This _should_ be a no-op, since the scheduler should've added the flag at the same time the
   *    view was marked as needing updating.
   *
   *    TODO(alxhub): figure out if this behavior is still needed for edge cases.
   *
   * 2. If none of our views require updating, then clear the view-related `dirtyFlag`s. This
   *    happens when the scheduler is notified of a view becoming dirty, but the view itself isn't
   *    reachable through traversal from our roots (e.g. it's detached from the CD tree).
   */
  syncDirtyFlagsWithViews() {
    if (this.allViews.some(({ _lView }) => (0, import_root_effect_scheduler.requiresRefreshOrTraversal)(_lView))) {
      this.dirtyFlags |= 2;
      return;
    } else {
      this.dirtyFlags &= ~7;
    }
  }
  /**
   * Attaches a view so that it will be dirty checked.
   * The view will be automatically detached when it is destroyed.
   * This will throw if the view is already attached to a ViewContainer.
   */
  attachView(viewRef) {
    (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
    const view = viewRef;
    this._views.push(view);
    view.attachToAppRef(this);
  }
  /**
   * Detaches a view from dirty checking again.
   */
  detachView(viewRef) {
    (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
    const view = viewRef;
    remove(this._views, view);
    view.detachFromAppRef();
  }
  _loadComponent(componentRef) {
    this.attachView(componentRef.hostView);
    try {
      this.tick();
    } catch (e) {
      this.internalErrorHandler(e);
    }
    this.components.push(componentRef);
    const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
    if (ngDevMode && !Array.isArray(listeners)) {
      throw new import_root_effect_scheduler.RuntimeError(-209, `Unexpected type of the \`APP_BOOTSTRAP_LISTENER\` token value (expected an array, but got ${typeof listeners}). Please check that the \`APP_BOOTSTRAP_LISTENER\` token is configured as a \`multi: true\` provider.`);
    }
    listeners.forEach((listener) => listener(componentRef));
  }
  /** @internal */
  ngOnDestroy() {
    if (this._destroyed)
      return;
    try {
      this._destroyListeners.forEach((listener) => listener());
      this._views.slice().forEach((view) => view.destroy());
    } finally {
      this._destroyed = true;
      this._views = [];
      this._destroyListeners = [];
    }
  }
  /**
   * Registers a listener to be called when an instance is destroyed.
   *
   * @param callback A callback function to add as a listener.
   * @returns A function which unregisters a listener.
   */
  onDestroy(callback) {
    (typeof ngDevMode === "undefined" || ngDevMode) && warnIfDestroyed(this._destroyed);
    this._destroyListeners.push(callback);
    return () => remove(this._destroyListeners, callback);
  }
  /**
   * Destroys an Angular application represented by this `ApplicationRef`. Calling this function
   * will destroy the associated environment injectors as well as all the bootstrapped components
   * with their views.
   */
  destroy() {
    if (this._destroyed) {
      throw new import_root_effect_scheduler.RuntimeError(406, ngDevMode && "This instance of the `ApplicationRef` has already been destroyed.");
    }
    const injector = this._injector;
    if (injector.destroy && !injector.destroyed) {
      injector.destroy();
    }
  }
  /**
   * Returns the number of attached views.
   */
  get viewCount() {
    return this._views.length;
  }
};
__publicField(_ApplicationRef, "\u0275fac", function ApplicationRef_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ApplicationRef)();
});
__publicField(_ApplicationRef, "\u0275prov", /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({ token: _ApplicationRef, factory: _ApplicationRef.\u0275fac, providedIn: "root" }));
let ApplicationRef = _ApplicationRef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], () => [], null);
})();
function warnIfDestroyed(destroyed) {
  if (destroyed) {
    console.warn((0, import_root_effect_scheduler.formatRuntimeError)(406, "This instance of the `ApplicationRef` has already been destroyed."));
  }
}
function remove(list, el) {
  const index = list.indexOf(el);
  if (index > -1) {
    list.splice(index, 1);
  }
}
function promiseWithResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function scheduleDelayedTrigger(scheduleFn) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  renderPlaceholder(lView, tNode);
  if (!shouldTriggerDeferBlock(0, lView))
    return;
  const injector = lView[import_root_effect_scheduler.INJECTOR$1];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const cleanupFn = scheduleFn(() => triggerDeferBlock(0, lView, tNode), injector);
  storeTriggerCleanupFn(0, lDetails, cleanupFn);
}
function scheduleDelayedPrefetching(scheduleFn) {
  if (typeof ngServerMode !== "undefined" && ngServerMode)
    return;
  const lView = (0, import_root_effect_scheduler.getLView)();
  const injector = lView[import_root_effect_scheduler.INJECTOR$1];
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const prefetch = () => triggerPrefetching(tDetails, lView, tNode);
    const cleanupFn = scheduleFn(prefetch, injector);
    storeTriggerCleanupFn(1, lDetails, cleanupFn);
  }
}
function scheduleDelayedHydrating(scheduleFn, lView, tNode) {
  if (typeof ngServerMode !== "undefined" && ngServerMode)
    return;
  const injector = lView[import_root_effect_scheduler.INJECTOR$1];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
  ngDevMode && assertSsrIdDefined(ssrUniqueId);
  const cleanupFn = scheduleFn(() => triggerHydrationFromBlockName(injector, ssrUniqueId), injector);
  storeTriggerCleanupFn(2, lDetails, cleanupFn);
}
function triggerPrefetching(tDetails, lView, tNode) {
  triggerResourceLoading(tDetails, lView, tNode);
}
function triggerResourceLoading(tDetails, lView, tNode) {
  var _a2;
  const injector = lView[import_root_effect_scheduler.INJECTOR$1];
  const tView = lView[import_root_effect_scheduler.TVIEW];
  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {
    return (_a2 = tDetails.loadingPromise) != null ? _a2 : Promise.resolve();
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);
  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;
  invokeTriggerCleanupFns(1, lDetails);
  let dependenciesFn = tDetails.dependencyResolverFn;
  if (ngDevMode) {
    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {
      optional: true
    });
    if (deferDependencyInterceptor) {
      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);
    }
  }
  const removeTask = injector.get(import_root_effect_scheduler.PendingTasks).add();
  if (!dependenciesFn) {
    tDetails.loadingPromise = Promise.resolve().then(() => {
      tDetails.loadingPromise = null;
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      removeTask();
    });
    return tDetails.loadingPromise;
  }
  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then((results) => {
    let failed = false;
    const directiveDefs = [];
    const pipeDefs = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        const dependency = result.value;
        const directiveDef = (0, import_root_effect_scheduler.getComponentDef)(dependency) || (0, import_root_effect_scheduler.getDirectiveDef)(dependency);
        if (directiveDef) {
          directiveDefs.push(directiveDef);
        } else {
          const pipeDef = (0, import_root_effect_scheduler.getPipeDef)(dependency);
          if (pipeDef) {
            pipeDefs.push(pipeDef);
          }
        }
      } else {
        failed = true;
        break;
      }
    }
    if (failed) {
      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;
      if (tDetails.errorTmplIndex === null) {
        const templateLocation = ngDevMode ? getTemplateLocationDetails(lView) : "";
        const error = new import_root_effect_scheduler.RuntimeError(-750, ngDevMode && `Loading dependencies for \`@defer\` block failed, but no \`@error\` block was configured${templateLocation}. Consider using the \`@error\` block to render an error state.`);
        handleUncaughtError(lView, error);
      }
    } else {
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      const primaryBlockTView = primaryBlockTNode.tView;
      if (directiveDefs.length > 0) {
        primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);
        const directiveTypes = directiveDefs.map((def) => def.type);
        const providers = (0, import_root_effect_scheduler.internalImportProvidersFrom)(false, ...directiveTypes);
        tDetails.providers = providers;
      }
      if (pipeDefs.length > 0) {
        primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);
      }
    }
  });
  return tDetails.loadingPromise.finally(() => {
    tDetails.loadingPromise = null;
    removeTask();
  });
}
function shouldTriggerDeferBlock(triggerType, lView) {
  if (triggerType === 0 && typeof ngServerMode !== "undefined" && ngServerMode) {
    return false;
  }
  const injector = lView[import_root_effect_scheduler.INJECTOR$1];
  const config = injector.get(DEFER_BLOCK_CONFIG, null, { optional: true });
  if ((config == null ? void 0 : config.behavior) === DeferBlockBehavior.Manual) {
    return false;
  }
  return true;
}
function triggerDeferBlock(triggerType, lView, tNode) {
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const lContainer = lView[tNode.index];
  ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(lContainer);
  if (!shouldTriggerDeferBlock(triggerType, lView))
    return;
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(tView, tNode);
  invokeAllTriggerCleanupFns(lDetails);
  switch (tDetails.loadingState) {
    case DeferDependenciesLoadingState.NOT_STARTED:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      triggerResourceLoading(tDetails, lView, tNode);
      if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {
        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      }
      break;
    case DeferDependenciesLoadingState.IN_PROGRESS:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.COMPLETE:
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.FAILED:
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
      break;
    default:
      if (ngDevMode) {
        (0, import_root_effect_scheduler.throwError)("Unknown defer block state");
      }
  }
}
function triggerHydrationFromBlockName(injector, blockName, replayQueuedEventsFn) {
  return __async(this, null, function* () {
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    if (blocksBeingHydrated.has(blockName)) {
      return;
    }
    const { parentBlockPromise, hydrationQueue } = getParentBlockHydrationQueue(blockName, injector);
    if (hydrationQueue.length === 0)
      return;
    if (parentBlockPromise !== null) {
      hydrationQueue.shift();
    }
    populateHydratingStateForQueue(dehydratedBlockRegistry, hydrationQueue);
    if (parentBlockPromise !== null) {
      yield parentBlockPromise;
    }
    const topmostParentBlock = hydrationQueue[0];
    if (dehydratedBlockRegistry.has(topmostParentBlock)) {
      yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);
    } else {
      dehydratedBlockRegistry.awaitParentBlock(topmostParentBlock, () => __async(null, null, function* () {
        return yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);
      }));
    }
  });
}
function triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn) {
  return __async(this, null, function* () {
    var _a2;
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    const pendingTasks = injector.get(import_root_effect_scheduler.PendingTasksInternal);
    const taskId = pendingTasks.add();
    for (let blockQueueIdx = 0; blockQueueIdx < hydrationQueue.length; blockQueueIdx++) {
      const dehydratedBlockId = hydrationQueue[blockQueueIdx];
      const dehydratedDeferBlock = dehydratedBlockRegistry.get(dehydratedBlockId);
      if (dehydratedDeferBlock != null) {
        yield triggerResourceLoadingForHydration(dehydratedDeferBlock);
        yield nextRender(injector);
        if (deferBlockHasErrored(dehydratedDeferBlock)) {
          removeDehydratedViewList(dehydratedDeferBlock);
          cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);
          break;
        }
        blocksBeingHydrated.get(dehydratedBlockId).resolve();
      } else {
        cleanupParentContainer(blockQueueIdx, hydrationQueue, dehydratedBlockRegistry);
        cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);
        break;
      }
    }
    const lastBlockName = hydrationQueue[hydrationQueue.length - 1];
    yield (_a2 = blocksBeingHydrated.get(lastBlockName)) == null ? void 0 : _a2.promise;
    pendingTasks.remove(taskId);
    if (replayQueuedEventsFn) {
      replayQueuedEventsFn(hydrationQueue);
    }
    cleanupHydratedDeferBlocks(dehydratedBlockRegistry.get(lastBlockName), hydrationQueue, dehydratedBlockRegistry, injector.get(ApplicationRef));
  });
}
function deferBlockHasErrored(deferBlock) {
  return getLDeferBlockDetails(deferBlock.lView, deferBlock.tNode)[DEFER_BLOCK_STATE] === DeferBlockState.Error;
}
function cleanupParentContainer(currentBlockIdx, hydrationQueue, dehydratedBlockRegistry) {
  const parentDeferBlockIdx = currentBlockIdx - 1;
  const parentDeferBlock = parentDeferBlockIdx > -1 ? dehydratedBlockRegistry.get(hydrationQueue[parentDeferBlockIdx]) : null;
  if (parentDeferBlock) {
    cleanupLContainer(parentDeferBlock.lContainer);
  }
}
function cleanupRemainingHydrationQueue(hydrationQueue, dehydratedBlockRegistry) {
  var _a2;
  const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
  for (const dehydratedBlockId in hydrationQueue) {
    (_a2 = blocksBeingHydrated.get(dehydratedBlockId)) == null ? void 0 : _a2.reject();
  }
  dehydratedBlockRegistry.cleanup(hydrationQueue);
}
function populateHydratingStateForQueue(registry, queue) {
  for (let blockId of queue) {
    registry.hydrating.set(blockId, promiseWithResolvers());
  }
}
function nextRender(injector) {
  return new Promise((resolveFn) => afterNextRender(resolveFn, { injector }));
}
function triggerResourceLoadingForHydration(dehydratedBlock) {
  return __async(this, null, function* () {
    const { tNode, lView } = dehydratedBlock;
    const lDetails = getLDeferBlockDetails(lView, tNode);
    return new Promise((resolve) => {
      onDeferBlockCompletion(lDetails, resolve);
      triggerDeferBlock(2, lView, tNode);
    });
  });
}
function onDeferBlockCompletion(lDetails, callback) {
  if (!Array.isArray(lDetails[ON_COMPLETE_FNS])) {
    lDetails[ON_COMPLETE_FNS] = [];
  }
  lDetails[ON_COMPLETE_FNS].push(callback);
}
function shouldAttachTrigger(triggerType, lView, tNode) {
  if (triggerType === 0) {
    return shouldAttachRegularTrigger(lView, tNode);
  } else if (triggerType === 2) {
    return !shouldAttachRegularTrigger(lView, tNode);
  }
  return !(typeof ngServerMode !== "undefined" && ngServerMode);
}
function hasHydrateTriggers(flags) {
  return flags != null && (flags & 1) === 1;
}
function shouldAttachRegularTrigger(lView, tNode) {
  const injector = lView[import_root_effect_scheduler.INJECTOR$1];
  const tDetails = getTDeferBlockDetails(lView[import_root_effect_scheduler.TVIEW], tNode);
  const incrementalHydrationEnabled = isIncrementalHydrationEnabled(injector);
  const _hasHydrateTriggers = hasHydrateTriggers(tDetails.flags);
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    return !incrementalHydrationEnabled || !_hasHydrateTriggers;
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const wasServerSideRendered = lDetails[SSR_UNIQUE_ID] !== null;
  if (_hasHydrateTriggers && wasServerSideRendered && incrementalHydrationEnabled) {
    return false;
  }
  return true;
}
function getHydrateTriggers(tView, tNode) {
  var _a2;
  const tDetails = getTDeferBlockDetails(tView, tNode);
  return (_a2 = tDetails.hydrateTriggers) != null ? _a2 : tDetails.hydrateTriggers = /* @__PURE__ */ new Map();
}
function processAndInitTriggers(injector, blockData, nodes) {
  const idleElements = [];
  const timerElements = [];
  const viewportElements = [];
  const immediateElements = [];
  for (let [blockId, blockSummary] of blockData) {
    const commentNode = nodes.get(blockId);
    if (commentNode !== void 0) {
      const numRootNodes = blockSummary.data[NUM_ROOT_NODES];
      let currentNode = commentNode;
      for (let i = 0; i < numRootNodes; i++) {
        currentNode = currentNode.previousSibling;
        if (currentNode.nodeType !== Node.ELEMENT_NODE) {
          continue;
        }
        const elementTrigger = { el: currentNode, blockName: blockId };
        if (blockSummary.hydrate.idle) {
          idleElements.push(elementTrigger);
        }
        if (blockSummary.hydrate.immediate) {
          immediateElements.push(elementTrigger);
        }
        if (blockSummary.hydrate.timer !== null) {
          elementTrigger.delay = blockSummary.hydrate.timer;
          timerElements.push(elementTrigger);
        }
        if (blockSummary.hydrate.viewport) {
          viewportElements.push(elementTrigger);
        }
      }
    }
  }
  setIdleTriggers(injector, idleElements);
  setImmediateTriggers(injector, immediateElements);
  setViewportTriggers(injector, viewportElements);
  setTimerTriggers(injector, timerElements);
}
function setIdleTriggers(injector, elementTriggers) {
  for (const elementTrigger of elementTriggers) {
    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const onInvoke = () => triggerHydrationFromBlockName(injector, elementTrigger.blockName);
    const cleanupFn = onIdle(onInvoke, injector);
    registry.addCleanupFn(elementTrigger.blockName, cleanupFn);
  }
}
function setViewportTriggers(injector, elementTriggers) {
  if (elementTriggers.length > 0) {
    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    for (let elementTrigger of elementTriggers) {
      const cleanupFn = onViewportWrapper(elementTrigger.el, () => triggerHydrationFromBlockName(injector, elementTrigger.blockName), injector);
      registry.addCleanupFn(elementTrigger.blockName, cleanupFn);
    }
  }
}
function setTimerTriggers(injector, elementTriggers) {
  for (const elementTrigger of elementTriggers) {
    const registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const onInvoke = () => triggerHydrationFromBlockName(injector, elementTrigger.blockName);
    const timerFn = onTimer(elementTrigger.delay);
    const cleanupFn = timerFn(onInvoke, injector);
    registry.addCleanupFn(elementTrigger.blockName, cleanupFn);
  }
}
function setImmediateTriggers(injector, elementTriggers) {
  for (const elementTrigger of elementTriggers) {
    triggerHydrationFromBlockName(injector, elementTrigger.blockName);
  }
}
let _hmrWarningProduced = false;
function logHmrWarning(injector) {
  if (!_hmrWarningProduced) {
    _hmrWarningProduced = true;
    const console2 = injector.get(Console);
    console2.log((0, import_root_effect_scheduler.formatRuntimeError)(-751, "Angular has detected that this application contains `@defer` blocks and the hot module replacement (HMR) mode is enabled. All `@defer` block dependencies will be loaded eagerly."));
  }
}
function \u0275\u0275defer(index, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling, flags) {
  var _a2, _b2;
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const tNode = declareNoDirectiveHostTemplate(lView, tView, index, null, 0, 0);
  const injector = lView[import_root_effect_scheduler.INJECTOR$1];
  const incrementalHydrationEnabled = isIncrementalHydrationEnabled(injector);
  if (tView.firstCreatePass) {
    performanceMarkFeature("NgDefer");
    if (ngDevMode) {
      if (typeof ngHmrMode !== "undefined" && ngHmrMode) {
        logHmrWarning(injector);
      }
      if (hasHydrateTriggers(flags) && !incrementalHydrationEnabled) {
        warnIncrementalHydrationNotConfigured();
      }
    }
    const tDetails = {
      primaryTmplIndex,
      loadingTmplIndex: loadingTmplIndex != null ? loadingTmplIndex : null,
      placeholderTmplIndex: placeholderTmplIndex != null ? placeholderTmplIndex : null,
      errorTmplIndex: errorTmplIndex != null ? errorTmplIndex : null,
      placeholderBlockConfig: null,
      loadingBlockConfig: null,
      dependencyResolverFn: dependencyResolverFn != null ? dependencyResolverFn : null,
      loadingState: DeferDependenciesLoadingState.NOT_STARTED,
      loadingPromise: null,
      providers: null,
      hydrateTriggers: null,
      debug: null,
      flags: flags != null ? flags : 0
    };
    enableTimerScheduling == null ? void 0 : enableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);
    setTDeferBlockDetails(tView, adjustedIndex, tDetails);
  }
  const lContainer = lView[adjustedIndex];
  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
  let ssrBlockState = null;
  let ssrUniqueId = null;
  if (((_a2 = lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS]) == null ? void 0 : _a2.length) > 0) {
    const info = lContainer[import_root_effect_scheduler.DEHYDRATED_VIEWS][0].data;
    ssrUniqueId = (_b2 = info[DEFER_BLOCK_ID]) != null ? _b2 : null;
    ssrBlockState = info[DEFER_BLOCK_STATE$1];
  }
  const lDetails = [
    null,
    // NEXT_DEFER_BLOCK_STATE
    DeferBlockInternalState.Initial,
    // DEFER_BLOCK_STATE
    null,
    // STATE_IS_FROZEN_UNTIL
    null,
    // LOADING_AFTER_CLEANUP_FN
    null,
    // TRIGGER_CLEANUP_FNS
    null,
    // PREFETCH_TRIGGER_CLEANUP_FNS
    ssrUniqueId,
    // SSR_UNIQUE_ID
    ssrBlockState,
    // SSR_BLOCK_STATE
    null,
    // ON_COMPLETE_FNS
    null
    // HYDRATE_TRIGGER_CLEANUP_FNS
  ];
  setLDeferBlockDetails(lView, adjustedIndex, lDetails);
  let registry = null;
  if (ssrUniqueId !== null && incrementalHydrationEnabled) {
    registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    registry.add(ssrUniqueId, { lView, tNode, lContainer });
  }
  const onLViewDestroy = () => {
    invokeAllTriggerCleanupFns(lDetails);
    if (ssrUniqueId !== null) {
      registry == null ? void 0 : registry.cleanup([ssrUniqueId]);
    }
  };
  storeTriggerCleanupFn(0, lDetails, () => (0, import_root_effect_scheduler.removeLViewOnDestroy)(lView, onLViewDestroy));
  (0, import_root_effect_scheduler.storeLViewOnDestroy)(lView, onLViewDestroy);
}
function \u0275\u0275deferWhen(rawValue) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "when <expression>");
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = (0, import_signal.setActiveConsumer)(null);
    try {
      const value = Boolean(rawValue);
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const renderedState = lDetails[DEFER_BLOCK_STATE];
      if (value === false && renderedState === DeferBlockInternalState.Initial) {
        renderPlaceholder(lView, tNode);
      } else if (value === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder)) {
        triggerDeferBlock(0, lView, tNode);
      }
    } finally {
      (0, import_signal.setActiveConsumer)(prevConsumer);
    }
  }
}
function \u0275\u0275deferPrefetchWhen(rawValue) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "prefetch when <expression>");
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = (0, import_signal.setActiveConsumer)(null);
    try {
      const value = Boolean(rawValue);
      const tView = lView[import_root_effect_scheduler.TVIEW];
      const tDetails = getTDeferBlockDetails(tView, tNode);
      if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
        triggerPrefetching(tDetails, lView, tNode);
      }
    } finally {
      (0, import_signal.setActiveConsumer)(prevConsumer);
    }
  }
}
function \u0275\u0275deferHydrateWhen(rawValue) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "hydrate when <expression>");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const hydrateTriggers = getHydrateTriggers(tView, tNode);
  hydrateTriggers.set(6, null);
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    if (typeof ngServerMode !== "undefined" && ngServerMode) {
      triggerDeferBlock(2, lView, tNode);
    } else {
      const injector = lView[import_root_effect_scheduler.INJECTOR$1];
      const prevConsumer = (0, import_signal.setActiveConsumer)(null);
      try {
        const value = Boolean(rawValue);
        if (value === true) {
          const lDetails = getLDeferBlockDetails(lView, tNode);
          const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
          ngDevMode && assertSsrIdDefined(ssrUniqueId);
          triggerHydrationFromBlockName(injector, ssrUniqueId);
        }
      } finally {
        (0, import_signal.setActiveConsumer)(prevConsumer);
      }
    }
  }
}
function \u0275\u0275deferHydrateNever() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "hydrate never");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers((0, import_root_effect_scheduler.getTView)(), tNode);
  hydrateTriggers.set(7, null);
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275deferOnIdle() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "on idle");
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  scheduleDelayedTrigger(onIdle);
}
function \u0275\u0275deferPrefetchOnIdle() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "prefetch on idle");
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  scheduleDelayedPrefetching(onIdle);
}
function \u0275\u0275deferHydrateOnIdle() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "hydrate on idle");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers((0, import_root_effect_scheduler.getTView)(), tNode);
  hydrateTriggers.set(0, null);
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    scheduleDelayedHydrating(onIdle, lView, tNode);
  }
}
function \u0275\u0275deferOnImmediate() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "on immediate");
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  const tDetails = getTDeferBlockDetails(lView[import_root_effect_scheduler.TVIEW], tNode);
  if (tDetails.loadingTmplIndex === null) {
    renderPlaceholder(lView, tNode);
  }
  triggerDeferBlock(0, lView, tNode);
}
function \u0275\u0275deferPrefetchOnImmediate() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "prefetch on immediate");
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function \u0275\u0275deferHydrateOnImmediate() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "hydrate on immediate");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers((0, import_root_effect_scheduler.getTView)(), tNode);
  hydrateTriggers.set(1, null);
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    const injector = lView[import_root_effect_scheduler.INJECTOR$1];
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
    ngDevMode && assertSsrIdDefined(ssrUniqueId);
    triggerHydrationFromBlockName(injector, ssrUniqueId);
  }
}
function \u0275\u0275deferOnTimer(delay) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, `on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  scheduleDelayedTrigger(onTimer(delay));
}
function \u0275\u0275deferPrefetchOnTimer(delay) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, `prefetch on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  scheduleDelayedPrefetching(onTimer(delay));
}
function \u0275\u0275deferHydrateOnTimer(delay) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, `hydrate on timer(${delay}ms)`);
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers((0, import_root_effect_scheduler.getTView)(), tNode);
  hydrateTriggers.set(5, { delay });
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  } else {
    scheduleDelayedHydrating(onTimer(delay), lView, tNode);
  }
}
function \u0275\u0275deferOnHover(triggerIndex, walkUpTimes) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, `on hover${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  renderPlaceholder(lView, tNode);
  if (!(typeof ngServerMode !== "undefined" && ngServerMode)) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerDeferBlock(0, lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnHover(triggerIndex, walkUpTimes) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, `prefetch on hover${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnHover() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "hydrate on hover");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers((0, import_root_effect_scheduler.getTView)(), tNode);
  hydrateTriggers.set(4, null);
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275deferOnInteraction(triggerIndex, walkUpTimes) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, `on interaction${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  renderPlaceholder(lView, tNode);
  if (!(typeof ngServerMode !== "undefined" && ngServerMode)) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerDeferBlock(0, lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnInteraction(triggerIndex, walkUpTimes) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, `prefetch on interaction${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnInteraction() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "hydrate on interaction");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers((0, import_root_effect_scheduler.getTView)(), tNode);
  hydrateTriggers.set(3, null);
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275deferOnViewport(triggerIndex, walkUpTimes) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, `on viewport${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(0, lView, tNode))
    return;
  renderPlaceholder(lView, tNode);
  if (!(typeof ngServerMode !== "undefined" && ngServerMode)) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewportWrapper,
      () => triggerDeferBlock(0, lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnViewport(triggerIndex, walkUpTimes) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, `prefetch on viewport${walkUpTimes === -1 ? "" : "(<target>)"}`);
  }
  if (!shouldAttachTrigger(1, lView, tNode))
    return;
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewportWrapper,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnViewport() {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (ngDevMode) {
    trackTriggerForDebugging(lView[import_root_effect_scheduler.TVIEW], tNode, "hydrate on viewport");
  }
  if (!shouldAttachTrigger(2, lView, tNode))
    return;
  const hydrateTriggers = getHydrateTriggers((0, import_root_effect_scheduler.getTView)(), tNode);
  hydrateTriggers.set(2, null);
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    triggerDeferBlock(2, lView, tNode);
  }
}
function \u0275\u0275ariaProperty(name, value) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0, import_root_effect_scheduler.getTView)();
    const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
    const hasSetInput = setAllInputsForProperty(tNode, tView, lView, name, value);
    if (hasSetInput) {
      (0, import_root_effect_scheduler.isComponentHost)(tNode) && markDirtyIfOnPush(lView, tNode.index);
      ngDevMode && setNgReflectProperties(lView, tView, tNode, name, value);
    } else {
      ngDevMode && assertTNodeType(
        tNode,
        2
        /* TNodeType.Element */
      );
      const element = (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
      setElementAttribute(lView[import_root_effect_scheduler.RENDERER], element, null, tNode.value, name, value, null);
    }
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, name, bindingIndex);
  }
  return \u0275\u0275ariaProperty;
}
function \u0275\u0275attribute(name, value, sanitizer, namespace) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0, import_root_effect_scheduler.getTView)();
    const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, "attr." + name, bindingIndex);
  }
  return \u0275\u0275attribute;
}
const ANIMATIONS_DISABLED = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "AnimationsDisabled" : "", {
  providedIn: "root",
  factory: () => false
});
const MAX_ANIMATION_TIMEOUT = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "MaxAnimationTimeout" : "", {
  providedIn: "root",
  factory: () => MAX_ANIMATION_TIMEOUT_DEFAULT
});
const MAX_ANIMATION_TIMEOUT_DEFAULT = 4e3;
const DEFAULT_ANIMATIONS_DISABLED = false;
const areAnimationSupported = (typeof ngServerMode === "undefined" || !ngServerMode) && typeof document !== "undefined" && // tslint:disable-next-line:no-toplevel-property-access
typeof ((_d = document == null ? void 0 : document.documentElement) == null ? void 0 : _d.getAnimations) === "function";
function areAnimationsDisabled(lView) {
  const injector = lView[import_root_effect_scheduler.INJECTOR$1];
  return injector.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);
}
function assertAnimationTypes(value, instruction) {
  if (value == null || typeof value !== "string" && typeof value !== "function") {
    throw new import_root_effect_scheduler.RuntimeError(650, `'${instruction}' value must be a string of CSS classes or an animation function, got ${(0, import_root_effect_scheduler.stringify)(value)}`);
  }
}
function assertElementNodes(nativeElement, instruction) {
  if (nativeElement.nodeType !== Node.ELEMENT_NODE) {
    throw new import_root_effect_scheduler.RuntimeError(650, `'${instruction}' can only be used on an element node, got ${(0, import_root_effect_scheduler.stringify)(nativeElement.nodeType)}`);
  }
}
function trackEnterClasses(el, classList, cleanupFns) {
  const elementData = enterClassMap.get(el);
  if (elementData) {
    for (const klass of classList) {
      elementData.classList.push(klass);
    }
    for (const fn of cleanupFns) {
      elementData.cleanupFns.push(fn);
    }
  } else {
    enterClassMap.set(el, { classList, cleanupFns });
  }
}
function cleanupEnterClassData(element) {
  const elementData = enterClassMap.get(element);
  if (elementData) {
    for (const fn of elementData.cleanupFns) {
      fn();
    }
    enterClassMap.delete(element);
  }
  longestAnimations.delete(element);
}
const noOpAnimationComplete = () => {
};
const enterClassMap = /* @__PURE__ */ new WeakMap();
const longestAnimations = /* @__PURE__ */ new WeakMap();
const leavingNodes = /* @__PURE__ */ new WeakMap();
function clearLeavingNodes(tNode, el) {
  const nodes = leavingNodes.get(tNode);
  if (nodes && nodes.length > 0) {
    const ix = nodes.findIndex((node) => node === el);
    if (ix > -1)
      nodes.splice(ix, 1);
  }
  if ((nodes == null ? void 0 : nodes.length) === 0) {
    leavingNodes.delete(tNode);
  }
}
function cancelLeavingNodes(tNode, lView) {
  var _a2;
  const leavingEl = (_a2 = leavingNodes.get(tNode)) == null ? void 0 : _a2.shift();
  const lContainer = lView[import_root_effect_scheduler.DECLARATION_LCONTAINER];
  if (lContainer) {
    const beforeNode = getBeforeNodeForView(tNode.index, lContainer);
    const previousNode = beforeNode == null ? void 0 : beforeNode.previousSibling;
    if (leavingEl && previousNode && leavingEl === previousNode) {
      leavingEl.dispatchEvent(new CustomEvent("animationend", { detail: { cancel: true } }));
    }
  }
}
function trackLeavingNodes(tNode, el) {
  var _a2;
  if (leavingNodes.has(tNode)) {
    (_a2 = leavingNodes.get(tNode)) == null ? void 0 : _a2.push(el);
  } else {
    leavingNodes.set(tNode, [el]);
  }
}
function getLViewEnterAnimations(lView) {
  var _a2, _b2, _c2;
  const animationData = (_b2 = lView[_a2 = import_root_effect_scheduler.ANIMATIONS]) != null ? _b2 : lView[_a2] = {};
  return (_c2 = animationData.enter) != null ? _c2 : animationData.enter = /* @__PURE__ */ new Map();
}
function getLViewLeaveAnimations(lView) {
  var _a2, _b2, _c2;
  const animationData = (_b2 = lView[_a2 = import_root_effect_scheduler.ANIMATIONS]) != null ? _b2 : lView[_a2] = {};
  return (_c2 = animationData.leave) != null ? _c2 : animationData.leave = /* @__PURE__ */ new Map();
}
function getClassListFromValue(value) {
  const classes = typeof value === "function" ? value() : value;
  let classList = Array.isArray(classes) ? classes : null;
  if (typeof classes === "string") {
    classList = classes.trim().split(/\s+/).filter((k) => k);
  }
  return classList;
}
function cancelAnimationsIfRunning(element, renderer) {
  if (!areAnimationSupported)
    return;
  const elementData = enterClassMap.get(element);
  if (elementData && elementData.classList.length > 0 && elementHasClassList(element, elementData.classList)) {
    for (const klass of elementData.classList) {
      renderer.removeClass(element, klass);
    }
  }
  cleanupEnterClassData(element);
}
function elementHasClassList(element, classList) {
  for (const className of classList) {
    if (element.classList.contains(className))
      return true;
  }
  return false;
}
function isLongestAnimation(event, nativeElement) {
  const longestAnimation = longestAnimations.get(nativeElement);
  if (longestAnimation === void 0)
    return true;
  return nativeElement === event.target && (longestAnimation.animationName !== void 0 && event.animationName === longestAnimation.animationName || longestAnimation.propertyName !== void 0 && event.propertyName === longestAnimation.propertyName);
}
function addAnimationToLView(animations, tNode, fn) {
  var _a2;
  const nodeAnimations = (_a2 = animations.get(tNode.index)) != null ? _a2 : { animateFns: [] };
  nodeAnimations.animateFns.push(fn);
  animations.set(tNode.index, nodeAnimations);
}
function cleanupAfterLeaveAnimations(resolvers, cleanupFns) {
  if (resolvers) {
    for (const fn of resolvers) {
      fn();
    }
  }
  for (const fn of cleanupFns) {
    fn();
  }
}
function clearLViewNodeAnimationResolvers(lView, tNode) {
  const nodeAnimations = getLViewLeaveAnimations(lView).get(tNode.index);
  if (nodeAnimations)
    nodeAnimations.resolvers = void 0;
}
function leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns) {
  clearLeavingNodes(tNode, nativeElement);
  cleanupAfterLeaveAnimations(resolvers, cleanupFns);
  clearLViewNodeAnimationResolvers(lView, tNode);
}
function \u0275\u0275animateEnter(value) {
  performanceMarkFeature("NgAnimateEnter");
  if (typeof ngServerMode !== "undefined" && ngServerMode || !areAnimationSupported) {
    return \u0275\u0275animateEnter;
  }
  ngDevMode && assertAnimationTypes(value, "animate.enter");
  const lView = (0, import_root_effect_scheduler.getLView)();
  if (areAnimationsDisabled(lView)) {
    return \u0275\u0275animateEnter;
  }
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  addAnimationToLView(getLViewEnterAnimations(lView), tNode, () => runEnterAnimation(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[import_root_effect_scheduler.INJECTOR$1]);
  queueEnterAnimations(lView[import_root_effect_scheduler.INJECTOR$1], getLViewEnterAnimations(lView));
  return \u0275\u0275animateEnter;
}
function runEnterAnimation(lView, tNode, value) {
  const nativeElement = (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, "animate.enter");
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  const ngZone = lView[import_root_effect_scheduler.INJECTOR$1].get(NgZone);
  const activeClasses = getClassListFromValue(value);
  const cleanupFns = [];
  const handleEnterAnimationStart = (event) => {
    if (event.target !== nativeElement)
      return;
    const eventName = event instanceof AnimationEvent ? "animationend" : "transitionend";
    ngZone.runOutsideAngular(() => {
      renderer.listen(nativeElement, eventName, handleEnterAnimationEnd);
    });
  };
  const handleEnterAnimationEnd = (event) => {
    if (event.target !== nativeElement)
      return;
    enterAnimationEnd(event, nativeElement, renderer);
  };
  if (activeClasses && activeClasses.length > 0) {
    ngZone.runOutsideAngular(() => {
      cleanupFns.push(renderer.listen(nativeElement, "animationstart", handleEnterAnimationStart));
      cleanupFns.push(renderer.listen(nativeElement, "transitionstart", handleEnterAnimationStart));
    });
    trackEnterClasses(nativeElement, activeClasses, cleanupFns);
    for (const klass of activeClasses) {
      renderer.addClass(nativeElement, klass);
    }
    ngZone.runOutsideAngular(() => {
      requestAnimationFrame(() => {
        determineLongestAnimation(nativeElement, longestAnimations, areAnimationSupported);
        if (!longestAnimations.has(nativeElement)) {
          for (const klass of activeClasses) {
            renderer.removeClass(nativeElement, klass);
          }
          cleanupEnterClassData(nativeElement);
        }
      });
    });
  }
}
function enterAnimationEnd(event, nativeElement, renderer) {
  const elementData = enterClassMap.get(nativeElement);
  if (event.target !== nativeElement || !elementData)
    return;
  if (isLongestAnimation(event, nativeElement)) {
    event.stopImmediatePropagation();
    for (const klass of elementData.classList) {
      renderer.removeClass(nativeElement, klass);
    }
    cleanupEnterClassData(nativeElement);
  }
}
function \u0275\u0275animateEnterListener(value) {
  performanceMarkFeature("NgAnimateEnter");
  if (typeof ngServerMode !== "undefined" && ngServerMode || !areAnimationSupported) {
    return \u0275\u0275animateEnterListener;
  }
  ngDevMode && assertAnimationTypes(value, "animate.enter");
  const lView = (0, import_root_effect_scheduler.getLView)();
  if (areAnimationsDisabled(lView)) {
    return \u0275\u0275animateEnterListener;
  }
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  addAnimationToLView(getLViewEnterAnimations(lView), tNode, () => runEnterAnimationFunction(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[import_root_effect_scheduler.INJECTOR$1]);
  queueEnterAnimations(lView[import_root_effect_scheduler.INJECTOR$1], getLViewEnterAnimations(lView));
  return \u0275\u0275animateEnterListener;
}
function runEnterAnimationFunction(lView, tNode, value) {
  const nativeElement = (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, "animate.enter");
  value.call(lView[import_root_effect_scheduler.CONTEXT], { target: nativeElement, animationComplete: noOpAnimationComplete });
}
function \u0275\u0275animateLeave(value) {
  performanceMarkFeature("NgAnimateLeave");
  if (typeof ngServerMode !== "undefined" && ngServerMode || !areAnimationSupported) {
    return \u0275\u0275animateLeave;
  }
  ngDevMode && assertAnimationTypes(value, "animate.leave");
  const lView = (0, import_root_effect_scheduler.getLView)();
  const animationsDisabled = areAnimationsDisabled(lView);
  if (animationsDisabled) {
    return \u0275\u0275animateLeave;
  }
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  addAnimationToLView(getLViewLeaveAnimations(lView), tNode, () => runLeaveAnimations(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[import_root_effect_scheduler.INJECTOR$1]);
  return \u0275\u0275animateLeave;
}
function runLeaveAnimations(lView, tNode, value) {
  var _a2, _b2;
  const { promise, resolve } = promiseWithResolvers();
  const nativeElement = (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, "animate.leave");
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  const ngZone = lView[import_root_effect_scheduler.INJECTOR$1].get(NgZone);
  allLeavingAnimations.add(lView);
  ((_b2 = (_a2 = getLViewLeaveAnimations(lView).get(tNode.index)).resolvers) != null ? _b2 : _a2.resolvers = []).push(resolve);
  const activeClasses = getClassListFromValue(value);
  if (activeClasses && activeClasses.length > 0) {
    animateLeaveClassRunner(nativeElement, tNode, lView, activeClasses, renderer, ngZone);
  } else {
    resolve();
  }
  return { promise, resolve };
}
function animateLeaveClassRunner(el, tNode, lView, classList, renderer, ngZone) {
  var _a2;
  cancelAnimationsIfRunning(el, renderer);
  const cleanupFns = [];
  const resolvers = (_a2 = getLViewLeaveAnimations(lView).get(tNode.index)) == null ? void 0 : _a2.resolvers;
  const handleOutAnimationEnd = (event) => {
    if (event.target !== el)
      return;
    if (event instanceof CustomEvent || isLongestAnimation(event, el)) {
      event.stopImmediatePropagation();
      longestAnimations.delete(el);
      clearLeavingNodes(tNode, el);
      if (Array.isArray(tNode.projection)) {
        for (const item of classList) {
          renderer.removeClass(el, item);
        }
      }
      cleanupAfterLeaveAnimations(resolvers, cleanupFns);
      clearLViewNodeAnimationResolvers(lView, tNode);
    }
  };
  ngZone.runOutsideAngular(() => {
    cleanupFns.push(renderer.listen(el, "animationend", handleOutAnimationEnd));
    cleanupFns.push(renderer.listen(el, "transitionend", handleOutAnimationEnd));
  });
  trackLeavingNodes(tNode, el);
  for (const item of classList) {
    renderer.addClass(el, item);
  }
  ngZone.runOutsideAngular(() => {
    requestAnimationFrame(() => {
      determineLongestAnimation(el, longestAnimations, areAnimationSupported);
      if (!longestAnimations.has(el)) {
        clearLeavingNodes(tNode, el);
        cleanupAfterLeaveAnimations(resolvers, cleanupFns);
        clearLViewNodeAnimationResolvers(lView, tNode);
      }
    });
  });
}
function \u0275\u0275animateLeaveListener(value) {
  performanceMarkFeature("NgAnimateLeave");
  if (typeof ngServerMode !== "undefined" && ngServerMode || !areAnimationSupported) {
    return \u0275\u0275animateLeaveListener;
  }
  ngDevMode && assertAnimationTypes(value, "animate.leave");
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  cancelLeavingNodes(tNode, lView);
  allLeavingAnimations.add(lView);
  addAnimationToLView(getLViewLeaveAnimations(lView), tNode, () => runLeaveAnimationFunction(lView, tNode, value));
  initializeAnimationQueueScheduler(lView[import_root_effect_scheduler.INJECTOR$1]);
  return \u0275\u0275animateLeaveListener;
}
function runLeaveAnimationFunction(lView, tNode, value) {
  var _a2, _b2, _c2;
  const { promise, resolve } = promiseWithResolvers();
  const nativeElement = (0, import_root_effect_scheduler.getNativeByTNode)(tNode, lView);
  ngDevMode && assertElementNodes(nativeElement, "animate.leave");
  const cleanupFns = [];
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  const animationsDisabled = areAnimationsDisabled(lView);
  const ngZone = lView[import_root_effect_scheduler.INJECTOR$1].get(NgZone);
  const maxAnimationTimeout = lView[import_root_effect_scheduler.INJECTOR$1].get(MAX_ANIMATION_TIMEOUT);
  ((_b2 = (_a2 = getLViewLeaveAnimations(lView).get(tNode.index)).resolvers) != null ? _b2 : _a2.resolvers = []).push(resolve);
  const resolvers = (_c2 = getLViewLeaveAnimations(lView).get(tNode.index)) == null ? void 0 : _c2.resolvers;
  if (animationsDisabled) {
    leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns);
  } else {
    const timeoutId = setTimeout(() => leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns), maxAnimationTimeout);
    const event = {
      target: nativeElement,
      animationComplete: () => {
        leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns);
        clearTimeout(timeoutId);
      }
    };
    trackLeavingNodes(tNode, nativeElement);
    ngZone.runOutsideAngular(() => {
      cleanupFns.push(renderer.listen(nativeElement, "animationend", () => {
        leaveAnimationFunctionCleanup(lView, tNode, nativeElement, resolvers, cleanupFns);
        clearTimeout(timeoutId);
      }, { once: true }));
    });
    value.call(lView[import_root_effect_scheduler.CONTEXT], event);
  }
  return { promise, resolve };
}
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
function \u0275\u0275componentInstance() {
  const instance = (0, import_root_effect_scheduler.getLView)()[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW][import_root_effect_scheduler.CONTEXT];
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(instance, "Expected component instance to be defined");
  return instance;
}
class LiveCollection {
  destroy(item) {
  }
  updateValue(index, value) {
  }
  // operations below could be implemented on top of the operations defined so far, but having
  // them explicitly allow clear expression of intent and potentially more performant
  // implementations
  swap(index1, index2) {
    const startIdx = Math.min(index1, index2);
    const endIdx = Math.max(index1, index2);
    const endItem = this.detach(endIdx);
    if (endIdx - startIdx > 1) {
      const startItem = this.detach(startIdx);
      this.attach(startIdx, endItem);
      this.attach(endIdx, startItem);
    } else {
      this.attach(startIdx, endItem);
    }
  }
  move(prevIndex, newIdx) {
    this.attach(newIdx, this.detach(prevIndex));
  }
}
function valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {
  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {
    return 1;
  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {
    return -1;
  }
  return 0;
}
function recordDuplicateKeys(keyToIdx, key, idx) {
  const idxSoFar = keyToIdx.get(key);
  if (idxSoFar !== void 0) {
    idxSoFar.add(idx);
  } else {
    keyToIdx.set(key, /* @__PURE__ */ new Set([idx]));
  }
}
function reconcile(liveCollection, newCollection, trackByFn) {
  let detachedItems = void 0;
  let liveKeysInTheFuture = void 0;
  let liveStartIdx = 0;
  let liveEndIdx = liveCollection.length - 1;
  const duplicateKeys = ngDevMode ? /* @__PURE__ */ new Map() : void 0;
  if (Array.isArray(newCollection)) {
    let newEndIdx = newCollection.length - 1;
    while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {
      const liveStartValue = liveCollection.at(liveStartIdx);
      const newStartValue = newCollection[liveStartIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newStartValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newStartValue);
        }
        liveStartIdx++;
        continue;
      }
      const liveEndValue = liveCollection.at(liveEndIdx);
      const newEndValue = newCollection[newEndIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(newEndIdx, newEndValue), newEndIdx);
      }
      const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);
      if (isEndMatching !== 0) {
        if (isEndMatching < 0) {
          liveCollection.updateValue(liveEndIdx, newEndValue);
        }
        liveEndIdx--;
        newEndIdx--;
        continue;
      }
      const liveStartKey = trackByFn(liveStartIdx, liveStartValue);
      const liveEndKey = trackByFn(liveEndIdx, liveEndValue);
      const newStartKey = trackByFn(liveStartIdx, newStartValue);
      if (Object.is(newStartKey, liveEndKey)) {
        const newEndKey = trackByFn(newEndIdx, newEndValue);
        if (Object.is(newEndKey, liveStartKey)) {
          liveCollection.swap(liveStartIdx, liveEndIdx);
          liveCollection.updateValue(liveEndIdx, newEndValue);
          newEndIdx--;
          liveEndIdx--;
        } else {
          liveCollection.move(liveEndIdx, liveStartIdx);
        }
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        continue;
      }
      detachedItems != null ? detachedItems : detachedItems = new UniqueValueMultiKeyMap();
      liveKeysInTheFuture != null ? liveKeysInTheFuture : liveKeysInTheFuture = initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
      if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        liveEndIdx++;
      } else if (!liveKeysInTheFuture.has(newStartKey)) {
        const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);
        liveCollection.attach(liveStartIdx, newItem);
        liveStartIdx++;
        liveEndIdx++;
      } else {
        detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));
        liveEndIdx--;
      }
    }
    while (liveStartIdx <= newEndIdx) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);
      liveStartIdx++;
    }
  } else if (newCollection != null) {
    const newCollectionIterator = newCollection[Symbol.iterator]();
    let newIterationResult = newCollectionIterator.next();
    while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {
      const liveValue = liveCollection.at(liveStartIdx);
      const newValue = newIterationResult.value;
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newValue);
        }
        liveStartIdx++;
        newIterationResult = newCollectionIterator.next();
      } else {
        detachedItems != null ? detachedItems : detachedItems = new UniqueValueMultiKeyMap();
        liveKeysInTheFuture != null ? liveKeysInTheFuture : liveKeysInTheFuture = initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
        const newKey = trackByFn(liveStartIdx, newValue);
        if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {
          liveCollection.updateValue(liveStartIdx, newValue);
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else if (!liveKeysInTheFuture.has(newKey)) {
          liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else {
          const liveKey = trackByFn(liveStartIdx, liveValue);
          detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));
          liveEndIdx--;
        }
      }
    }
    while (!newIterationResult.done) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);
      newIterationResult = newCollectionIterator.next();
    }
  }
  while (liveStartIdx <= liveEndIdx) {
    liveCollection.destroy(liveCollection.detach(liveEndIdx--));
  }
  detachedItems == null ? void 0 : detachedItems.forEach((item) => {
    liveCollection.destroy(item);
  });
  if (ngDevMode) {
    let duplicatedKeysMsg = [];
    for (const [key, idxSet] of duplicateKeys) {
      if (idxSet.size > 1) {
        const idx = [...idxSet].sort((a, b) => a - b);
        for (let i = 1; i < idx.length; i++) {
          duplicatedKeysMsg.push(`key "${(0, import_root_effect_scheduler.stringifyForError)(key)}" at index "${idx[i - 1]}" and "${idx[i]}"`);
        }
      }
    }
    if (duplicatedKeysMsg.length > 0) {
      const message = (0, import_root_effect_scheduler.formatRuntimeError)(-955, "The provided track expression resulted in duplicated keys for a given collection. Adjust the tracking expression such that it uniquely identifies all the items in the collection. Duplicated keys were: \n" + duplicatedKeysMsg.join(", \n") + ".");
      console.warn(message);
    }
  }
}
function attachPreviouslyDetached(prevCollection, detachedItems, index, key) {
  if (detachedItems !== void 0 && detachedItems.has(key)) {
    prevCollection.attach(index, detachedItems.get(key));
    detachedItems.delete(key);
    return true;
  }
  return false;
}
function createOrAttach(liveCollection, detachedItems, trackByFn, index, value) {
  if (!attachPreviouslyDetached(liveCollection, detachedItems, index, trackByFn(index, value))) {
    const newItem = liveCollection.create(index, value);
    liveCollection.attach(index, newItem);
  } else {
    liveCollection.updateValue(index, value);
  }
}
function initLiveItemsInTheFuture(liveCollection, start, end, trackByFn) {
  const keys = /* @__PURE__ */ new Set();
  for (let i = start; i <= end; i++) {
    keys.add(trackByFn(i, liveCollection.at(i)));
  }
  return keys;
}
class UniqueValueMultiKeyMap {
  constructor() {
    // A map from a key to the first value corresponding to this key.
    __publicField(this, "kvMap", /* @__PURE__ */ new Map());
    // A map that acts as a linked list of values - each value maps to the next value in this "linked
    // list" (this only works if values are unique). Allocated lazily to avoid memory consumption when
    // there are no duplicated values.
    __publicField(this, "_vMap");
  }
  has(key) {
    return this.kvMap.has(key);
  }
  delete(key) {
    if (!this.has(key))
      return false;
    const value = this.kvMap.get(key);
    if (this._vMap !== void 0 && this._vMap.has(value)) {
      this.kvMap.set(key, this._vMap.get(value));
      this._vMap.delete(value);
    } else {
      this.kvMap.delete(key);
    }
    return true;
  }
  get(key) {
    return this.kvMap.get(key);
  }
  set(key, value) {
    if (this.kvMap.has(key)) {
      let prevValue = this.kvMap.get(key);
      if (ngDevMode && prevValue === value) {
        throw new Error(`Detected a duplicated value ${value} for the key ${key}`);
      }
      if (this._vMap === void 0) {
        this._vMap = /* @__PURE__ */ new Map();
      }
      const vMap = this._vMap;
      while (vMap.has(prevValue)) {
        prevValue = vMap.get(prevValue);
      }
      vMap.set(prevValue, value);
    } else {
      this.kvMap.set(key, value);
    }
  }
  forEach(cb) {
    for (let [key, value] of this.kvMap) {
      cb(value, key);
      if (this._vMap !== void 0) {
        const vMap = this._vMap;
        while (vMap.has(value)) {
          value = vMap.get(value);
          cb(value, key);
        }
      }
    }
  }
}
function \u0275\u0275conditionalCreate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  performanceMarkFeature("NgControlFlow");
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const attrs = (0, import_root_effect_scheduler.getConstant)(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, 256, localRefsIndex, localRefExtractor);
  return \u0275\u0275conditionalBranchCreate;
}
function \u0275\u0275conditionalBranchCreate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  performanceMarkFeature("NgControlFlow");
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const attrs = (0, import_root_effect_scheduler.getConstant)(tView.consts, attrsIndex);
  declareNoDirectiveHostTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, 512, localRefsIndex, localRefExtractor);
  return \u0275\u0275conditionalBranchCreate;
}
function \u0275\u0275conditional(matchingTemplateIndex, contextValue) {
  performanceMarkFeature("NgControlFlow");
  const hostLView = (0, import_root_effect_scheduler.getLView)();
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  const prevMatchingTemplateIndex = hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;
  const prevContainer = prevMatchingTemplateIndex !== -1 ? getLContainer(hostLView, import_root_effect_scheduler.HEADER_OFFSET + prevMatchingTemplateIndex) : void 0;
  const viewInContainerIdx = 0;
  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
    const prevConsumer = (0, import_signal.setActiveConsumer)(null);
    try {
      if (prevContainer !== void 0) {
        removeLViewFromLContainer(prevContainer, viewInContainerIdx);
      }
      if (matchingTemplateIndex !== -1) {
        const nextLContainerIndex = import_root_effect_scheduler.HEADER_OFFSET + matchingTemplateIndex;
        const nextContainer = getLContainer(hostLView, nextLContainerIndex);
        const templateTNode = getExistingTNode(hostLView[import_root_effect_scheduler.TVIEW], nextLContainerIndex);
        const dehydratedView = findAndReconcileMatchingDehydratedViews(nextContainer, templateTNode, hostLView);
        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {
          dehydratedView
        });
        addLViewToLContainer(nextContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
      }
    } finally {
      (0, import_signal.setActiveConsumer)(prevConsumer);
    }
  } else if (prevContainer !== void 0) {
    const lView = getLViewFromLContainer(prevContainer, viewInContainerIdx);
    if (lView !== void 0) {
      lView[import_root_effect_scheduler.CONTEXT] = contextValue;
    }
  }
}
class RepeaterContext {
  constructor(lContainer, $implicit, $index) {
    __publicField(this, "lContainer");
    __publicField(this, "$implicit");
    __publicField(this, "$index");
    this.lContainer = lContainer;
    this.$implicit = $implicit;
    this.$index = $index;
  }
  get $count() {
    return this.lContainer.length - import_root_effect_scheduler.CONTAINER_HEADER_OFFSET;
  }
}
function \u0275\u0275repeaterTrackByIndex(index) {
  return index;
}
function \u0275\u0275repeaterTrackByIdentity(_, value) {
  return value;
}
class RepeaterMetadata {
  constructor(hasEmptyBlock, trackByFn, liveCollection) {
    __publicField(this, "hasEmptyBlock");
    __publicField(this, "trackByFn");
    __publicField(this, "liveCollection");
    this.hasEmptyBlock = hasEmptyBlock;
    this.trackByFn = trackByFn;
    this.liveCollection = liveCollection;
  }
}
function \u0275\u0275repeaterCreate(index, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {
  performanceMarkFeature("NgControlFlow");
  ngDevMode && (0, import_root_effect_scheduler.assertFunction)(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const hasEmptyBlock = emptyTemplateFn !== void 0;
  const hostLView = (0, import_root_effect_scheduler.getLView)();
  const boundTrackBy = trackByUsesComponentInstance ? (
    // We only want to bind when necessary, because it produces a
    // new function. For pure functions it's not necessary.
    trackByFn.bind(hostLView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW][import_root_effect_scheduler.CONTEXT])
  ) : trackByFn;
  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);
  hostLView[import_root_effect_scheduler.HEADER_OFFSET + index] = metadata;
  declareNoDirectiveHostTemplate(
    lView,
    tView,
    index + 1,
    templateFn,
    decls,
    vars,
    tagName,
    (0, import_root_effect_scheduler.getConstant)(tView.consts, attrsIndex),
    256
    /* TNodeFlags.isControlFlowStart */
  );
  if (hasEmptyBlock) {
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(emptyDecls, "Missing number of declarations for the empty repeater block.");
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(emptyVars, "Missing number of bindings for the empty repeater block.");
    declareNoDirectiveHostTemplate(
      lView,
      tView,
      index + 2,
      emptyTemplateFn,
      emptyDecls,
      emptyVars,
      emptyTagName,
      (0, import_root_effect_scheduler.getConstant)(tView.consts, emptyAttrsIndex),
      512
      /* TNodeFlags.isInControlFlow */
    );
  }
}
function isViewExpensiveToRecreate(lView) {
  return lView.length - import_root_effect_scheduler.HEADER_OFFSET > 2;
}
class OperationsCounter {
  constructor() {
    __publicField(this, "created", 0);
    __publicField(this, "destroyed", 0);
  }
  reset() {
    this.created = 0;
    this.destroyed = 0;
  }
  recordCreate() {
    this.created++;
  }
  recordDestroy() {
    this.destroyed++;
  }
  /**
   * A method indicating if the entire collection was re-created as part of the reconciliation pass.
   * Used to warn developers about the usage of a tracking function that might result in excessive
   * amount of view creation / destroy operations.
   *
   * @returns boolean value indicating if a live collection was re-created
   */
  wasReCreated(collectionLen) {
    return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;
  }
}
class LiveCollectionLContainerImpl extends LiveCollection {
  constructor(lContainer, hostLView, templateTNode) {
    super();
    __publicField(this, "lContainer");
    __publicField(this, "hostLView");
    __publicField(this, "templateTNode");
    __publicField(this, "operationsCounter", ngDevMode ? new OperationsCounter() : void 0);
    /**
      Property indicating if indexes in the repeater context need to be updated following the live
      collection changes. Index updates are necessary if and only if views are inserted / removed in
      the middle of LContainer. Adds and removals at the end don't require index updates.
    */
    __publicField(this, "needsIndexUpdate", false);
    this.lContainer = lContainer;
    this.hostLView = hostLView;
    this.templateTNode = templateTNode;
  }
  get length() {
    return this.lContainer.length - import_root_effect_scheduler.CONTAINER_HEADER_OFFSET;
  }
  at(index) {
    return this.getLView(index)[import_root_effect_scheduler.CONTEXT].$implicit;
  }
  attach(index, lView) {
    const dehydratedView = lView[import_root_effect_scheduler.HYDRATION];
    this.needsIndexUpdate || (this.needsIndexUpdate = index !== this.length);
    addLViewToLContainer(this.lContainer, lView, index, shouldAddViewToDom(this.templateTNode, dehydratedView));
    clearDetachAnimationList(this.lContainer, index);
  }
  detach(index) {
    this.needsIndexUpdate || (this.needsIndexUpdate = index !== this.length - 1);
    maybeInitDetachAnimationList(this.lContainer, index);
    return detachExistingView(this.lContainer, index);
  }
  create(index, value) {
    var _a2;
    const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);
    const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value, index), { dehydratedView });
    (_a2 = this.operationsCounter) == null ? void 0 : _a2.recordCreate();
    return embeddedLView;
  }
  destroy(lView) {
    var _a2;
    destroyLView(lView[import_root_effect_scheduler.TVIEW], lView);
    (_a2 = this.operationsCounter) == null ? void 0 : _a2.recordDestroy();
  }
  updateValue(index, value) {
    this.getLView(index)[import_root_effect_scheduler.CONTEXT].$implicit = value;
  }
  reset() {
    var _a2;
    this.needsIndexUpdate = false;
    (_a2 = this.operationsCounter) == null ? void 0 : _a2.reset();
  }
  updateIndexes() {
    if (this.needsIndexUpdate) {
      for (let i = 0; i < this.length; i++) {
        this.getLView(i)[import_root_effect_scheduler.CONTEXT].$index = i;
      }
    }
  }
  getLView(index) {
    return getExistingLViewFromLContainer(this.lContainer, index);
  }
}
function \u0275\u0275repeater(collection) {
  var _a2;
  const prevConsumer = (0, import_signal.setActiveConsumer)(null);
  const metadataSlotIdx = (0, import_root_effect_scheduler.getSelectedIndex)();
  try {
    const hostLView = (0, import_root_effect_scheduler.getLView)();
    const hostTView = hostLView[import_root_effect_scheduler.TVIEW];
    const metadata = hostLView[metadataSlotIdx];
    const containerIndex = metadataSlotIdx + 1;
    const lContainer = getLContainer(hostLView, containerIndex);
    if (metadata.liveCollection === void 0) {
      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
      metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);
    } else {
      metadata.liveCollection.reset();
    }
    const liveCollection = metadata.liveCollection;
    reconcile(liveCollection, collection, metadata.trackByFn);
    if (ngDevMode && metadata.trackByFn === \u0275\u0275repeaterTrackByIdentity && ((_a2 = liveCollection.operationsCounter) == null ? void 0 : _a2.wasReCreated(liveCollection.length)) && isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))) {
      const message = (0, import_root_effect_scheduler.formatRuntimeError)(-956, `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. Please review the "track expression" and make sure that it uniquely identifies items in a collection.`);
      console.warn(message);
    }
    liveCollection.updateIndexes();
    if (metadata.hasEmptyBlock) {
      const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
      const isCollectionEmpty = liveCollection.length === 0;
      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {
        const emptyTemplateIndex = metadataSlotIdx + 2;
        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);
        if (isCollectionEmpty) {
          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
          const dehydratedView = findAndReconcileMatchingDehydratedViews(lContainerForEmpty, emptyTemplateTNode, hostLView);
          const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, void 0, { dehydratedView });
          addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
        } else {
          if (hostTView.firstUpdatePass) {
            removeDehydratedViews(lContainerForEmpty);
          }
          removeLViewFromLContainer(lContainerForEmpty, 0);
        }
      }
    }
  } finally {
    (0, import_signal.setActiveConsumer)(prevConsumer);
  }
}
function getLContainer(lView, index) {
  const lContainer = lView[index];
  ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(lContainer);
  return lContainer;
}
function clearDetachAnimationList(lContainer, index) {
  if (lContainer.length <= import_root_effect_scheduler.CONTAINER_HEADER_OFFSET)
    return;
  const indexInContainer = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET + index;
  const viewToDetach = lContainer[indexInContainer];
  const animations = viewToDetach ? viewToDetach[import_root_effect_scheduler.ANIMATIONS] : void 0;
  if (viewToDetach && animations && animations.detachedLeaveAnimationFns && animations.detachedLeaveAnimationFns.length > 0) {
    const injector = viewToDetach[import_root_effect_scheduler.INJECTOR$1];
    removeFromAnimationQueue(injector, animations);
    allLeavingAnimations.delete(viewToDetach);
    animations.detachedLeaveAnimationFns = void 0;
  }
}
function maybeInitDetachAnimationList(lContainer, index) {
  if (lContainer.length <= import_root_effect_scheduler.CONTAINER_HEADER_OFFSET)
    return;
  const indexInContainer = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET + index;
  const viewToDetach = lContainer[indexInContainer];
  const animations = viewToDetach ? viewToDetach[import_root_effect_scheduler.ANIMATIONS] : void 0;
  if (animations && animations.leave && animations.leave.size > 0) {
    animations.detachedLeaveAnimationFns = [];
  }
}
function detachExistingView(lContainer, index) {
  const existingLView = detachView(lContainer, index);
  ngDevMode && (0, import_root_effect_scheduler.assertLView)(existingLView);
  return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
  const existingLView = getLViewFromLContainer(lContainer, index);
  ngDevMode && (0, import_root_effect_scheduler.assertLView)(existingLView);
  return existingLView;
}
function getExistingTNode(tView, index) {
  const tNode = (0, import_root_effect_scheduler.getTNode)(tView, index);
  ngDevMode && (0, import_root_effect_scheduler.assertTNode)(tNode);
  return tNode;
}
function \u0275\u0275property(propName, value, sanitizer) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0, import_root_effect_scheduler.getTView)();
    const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
    setPropertyAndInputs(tNode, lView, propName, value, lView[import_root_effect_scheduler.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275property;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
  setAllInputsForProperty(tNode, tView, lView, isClassBased ? "class" : "style", value);
}
function \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  ngDevMode && (0, import_root_effect_scheduler.assertTNodeCreationIndex)(lView, index);
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? directiveHostFirstCreatePass(adjustedIndex, lView, 2, name, findDirectiveDefMatches, (0, import_root_effect_scheduler.getBindingsEnabled)(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, name, _locateOrCreateElementNode);
  if ((0, import_root_effect_scheduler.isDirectiveHost)(tNode)) {
    const tView2 = lView[import_root_effect_scheduler.TVIEW];
    createDirectivesInstances(tView2, lView, tNode);
    executeContentQueries(tView2, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  if (ngDevMode && lView[import_root_effect_scheduler.TVIEW].firstCreatePass) {
    validateElementIsKnown(lView, tNode);
  }
  return \u0275\u0275elementStart;
}
function \u0275\u0275elementEnd() {
  const tView = (0, import_root_effect_scheduler.getTView)();
  const initialTNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(
    currentTNode,
    3
    /* TNodeType.AnyRNode */
  );
  if (tView.firstCreatePass) {
    directiveHostEndFirstCreatePass(tView, currentTNode);
  }
  if ((0, import_root_effect_scheduler.isSkipHydrationRootTNode)(currentTNode)) {
    (0, import_root_effect_scheduler.leaveSkipHydrationBlock)();
  }
  (0, import_root_effect_scheduler.decreaseElementDepthCount)();
  if (currentTNode.classesWithoutHost != null && hasClassInput(currentTNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, currentTNode, (0, import_root_effect_scheduler.getLView)(), currentTNode.classesWithoutHost, true);
  }
  if (currentTNode.stylesWithoutHost != null && hasStyleInput(currentTNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, currentTNode, (0, import_root_effect_scheduler.getLView)(), currentTNode.stylesWithoutHost, false);
  }
  return \u0275\u0275elementEnd;
}
function \u0275\u0275element(index, name, attrsIndex, localRefsIndex) {
  \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex);
  \u0275\u0275elementEnd();
  return \u0275\u0275element;
}
function \u0275\u0275domElementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  ngDevMode && (0, import_root_effect_scheduler.assertTNodeCreationIndex)(lView, index);
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? domOnlyFirstCreatePass(adjustedIndex, tView, 2, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, name, _locateOrCreateElementNode);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  if (ngDevMode && lView[import_root_effect_scheduler.TVIEW].firstCreatePass) {
    validateElementIsKnown(lView, tNode);
  }
  return \u0275\u0275domElementStart;
}
function \u0275\u0275domElementEnd() {
  const initialTNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(
    currentTNode,
    3
    /* TNodeType.AnyRNode */
  );
  if ((0, import_root_effect_scheduler.isSkipHydrationRootTNode)(currentTNode)) {
    (0, import_root_effect_scheduler.leaveSkipHydrationBlock)();
  }
  (0, import_root_effect_scheduler.decreaseElementDepthCount)();
  return \u0275\u0275domElementEnd;
}
function \u0275\u0275domElement(index, name, attrsIndex, localRefsIndex) {
  \u0275\u0275domElementStart(index, name, attrsIndex, localRefsIndex);
  \u0275\u0275domElementEnd();
  return \u0275\u0275domElement;
}
let _locateOrCreateElementNode = (tView, lView, tNode, name, index) => {
  (0, import_root_effect_scheduler.lastNodeWasCreated)(true);
  return createElementNode(lView[import_root_effect_scheduler.RENDERER], name, (0, import_root_effect_scheduler.getNamespace)());
};
function locateOrCreateElementNodeImpl(tView, lView, tNode, name, index) {
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0, import_root_effect_scheduler.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createElementNode(lView[import_root_effect_scheduler.RENDERER], name, (0, import_root_effect_scheduler.getNamespace)());
  }
  const hydrationInfo = lView[import_root_effect_scheduler.HYDRATION];
  const native = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateMatchingNode(native, Node.ELEMENT_NODE, name, lView, tNode);
  ngDevMode && markRNodeAsClaimedByHydration(native);
  if (getSerializedContainerViews(hydrationInfo, index)) {
    ngDevMode && validateNodeExists(native.nextSibling, lView, tNode);
    setSegmentHead(hydrationInfo, index, native.nextSibling);
  }
  if (hydrationInfo && (hasSkipHydrationAttrOnTNode(tNode) || hasSkipHydrationAttrOnRElement(native))) {
    if ((0, import_root_effect_scheduler.isComponentHost)(tNode)) {
      (0, import_root_effect_scheduler.enterSkipHydrationBlock)(tNode);
      clearElementContents(native);
      ngDevMode && markRNodeAsSkippedByHydration(native);
    } else if (ngDevMode) {
      throw invalidSkipHydrationHost(native);
    }
  }
  return native;
}
function enableLocateOrCreateElementNodeImpl() {
  _locateOrCreateElementNode = locateOrCreateElementNodeImpl;
}
function \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  ngDevMode && (0, import_root_effect_scheduler.assertTNodeCreationIndex)(lView, index);
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? directiveHostFirstCreatePass(adjustedIndex, lView, 8, "ng-container", findDirectiveDefMatches, (0, import_root_effect_scheduler.getBindingsEnabled)(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, "ng-container", _locateOrCreateElementContainerNode);
  if ((0, import_root_effect_scheduler.isDirectiveHost)(tNode)) {
    const tView2 = lView[import_root_effect_scheduler.TVIEW];
    createDirectivesInstances(tView2, lView, tNode);
    executeContentQueries(tView2, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275elementContainerStart;
}
function \u0275\u0275elementContainerEnd() {
  const tView = (0, import_root_effect_scheduler.getTView)();
  const initialTNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  if (tView.firstCreatePass) {
    directiveHostEndFirstCreatePass(tView, currentTNode);
  }
  ngDevMode && assertTNodeType(
    currentTNode,
    8
    /* TNodeType.ElementContainer */
  );
  return \u0275\u0275elementContainerEnd;
}
function \u0275\u0275elementContainer(index, attrsIndex, localRefsIndex) {
  \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex);
  \u0275\u0275elementContainerEnd();
  return \u0275\u0275elementContainer;
}
function \u0275\u0275domElementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  ngDevMode && (0, import_root_effect_scheduler.assertTNodeCreationIndex)(lView, index);
  const tView = lView[import_root_effect_scheduler.TVIEW];
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? domOnlyFirstCreatePass(adjustedIndex, tView, 8, "ng-container", attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  elementLikeStartShared(tNode, lView, index, "ng-container", _locateOrCreateElementContainerNode);
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275domElementContainerStart;
}
function \u0275\u0275domElementContainerEnd() {
  const initialTNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(initialTNode, "No parent node to close.");
  const currentTNode = elementLikeEndShared(initialTNode);
  ngDevMode && assertTNodeType(
    currentTNode,
    8
    /* TNodeType.ElementContainer */
  );
  return \u0275\u0275elementContainerEnd;
}
function \u0275\u0275domElementContainer(index, attrsIndex, localRefsIndex) {
  \u0275\u0275domElementContainerStart(index, attrsIndex, localRefsIndex);
  \u0275\u0275domElementContainerEnd();
  return \u0275\u0275domElementContainer;
}
let _locateOrCreateElementContainerNode = (tView, lView, tNode, commentText, index) => {
  (0, import_root_effect_scheduler.lastNodeWasCreated)(true);
  return createCommentNode(lView[import_root_effect_scheduler.RENDERER], ngDevMode ? commentText : "");
};
function locateOrCreateElementContainerNode(tView, lView, tNode, commentText, index) {
  let comment;
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0, import_root_effect_scheduler.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createCommentNode(lView[import_root_effect_scheduler.RENDERER], ngDevMode ? commentText : "");
  }
  const hydrationInfo = lView[import_root_effect_scheduler.HYDRATION];
  const currentRNode = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateNodeExists(currentRNode, lView, tNode);
  const ngContainerSize = getNgContainerSize(hydrationInfo, index);
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(ngContainerSize, "Unexpected state: hydrating an <ng-container>, but no hydration info is available.");
  setSegmentHead(hydrationInfo, index, currentRNode);
  comment = siblingAfter(ngContainerSize, currentRNode);
  if (ngDevMode) {
    validateMatchingNode(comment, Node.COMMENT_NODE, null, lView, tNode);
    markRNodeAsClaimedByHydration(comment);
  }
  return comment;
}
function enableLocateOrCreateElementContainerNodeImpl() {
  _locateOrCreateElementContainerNode = locateOrCreateElementContainerNode;
}
function \u0275\u0275getCurrentView() {
  return (0, import_root_effect_scheduler.getLView)();
}
function \u0275\u0275domProperty(propName, value, sanitizer) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0, import_root_effect_scheduler.getTView)();
    const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
    setDomProperty(tNode, lView, propName, value, lView[import_root_effect_scheduler.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275domProperty;
}
function \u0275\u0275syntheticHostProperty(propName, value, sanitizer) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0, import_root_effect_scheduler.getTView)();
    const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
    const currentDef = (0, import_root_effect_scheduler.getCurrentDirectiveDef)(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    setDomProperty(tNode, lView, propName, value, renderer, sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275syntheticHostProperty;
}
const u = void 0;
function plural(val) {
  const i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
  if (i === 1 && v === 0)
    return 1;
  return 5;
}
var localeEn = ["en", [["a", "p"], ["AM", "PM"]], [["AM", "PM"]], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
let LOCALE_DATA = {};
function registerLocaleData(data, localeId, extraData) {
  if (typeof localeId !== "string") {
    extraData = localeId;
    localeId = data[LocaleDataIndex.LocaleId];
  }
  localeId = localeId.toLowerCase().replace(/_/g, "-");
  LOCALE_DATA[localeId] = data;
  if (extraData) {
    LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;
  }
}
function findLocaleData(locale) {
  const normalizedLocale = normalizeLocale(locale);
  let match = getLocaleData(normalizedLocale);
  if (match) {
    return match;
  }
  const parentLocale = normalizedLocale.split("-")[0];
  match = getLocaleData(parentLocale);
  if (match) {
    return match;
  }
  if (parentLocale === "en") {
    return localeEn;
  }
  throw new import_root_effect_scheduler.RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale}".`);
}
function getLocaleCurrencyCode(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.CurrencyCode] || null;
}
function getLocalePluralCase(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
  if (!(normalizedLocale in LOCALE_DATA)) {
    LOCALE_DATA[normalizedLocale] = import_root_effect_scheduler._global.ng && import_root_effect_scheduler._global.ng.common && import_root_effect_scheduler._global.ng.common.locales && import_root_effect_scheduler._global.ng.common.locales[normalizedLocale];
  }
  return LOCALE_DATA[normalizedLocale];
}
function unregisterAllLocaleData() {
  LOCALE_DATA = {};
}
var LocaleDataIndex;
(function(LocaleDataIndex2) {
  LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
  LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
  LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
  LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
  LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
  LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
  LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
  LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
  LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
  LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
  LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
  LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
  LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
  LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
  LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
  LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
  LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
  LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
  LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
  LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
})(LocaleDataIndex || (LocaleDataIndex = {}));
function normalizeLocale(locale) {
  return locale.toLowerCase().replace(/_/g, "-");
}
const pluralMapping = ["zero", "one", "two", "few", "many"];
function getPluralCase(value, locale) {
  const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
  const result = pluralMapping[plural2];
  return result !== void 0 ? result : "other";
}
const DEFAULT_LOCALE_ID = "en-US";
const USD_CURRENCY_CODE = "USD";
const ELEMENT_MARKER = {
  marker: "element"
};
const ICU_MARKER = {
  marker: "ICU"
};
var I18nCreateOpCode;
(function(I18nCreateOpCode2) {
  I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
  I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
  I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
})(I18nCreateOpCode || (I18nCreateOpCode = {}));
let LOCALE_ID$1 = DEFAULT_LOCALE_ID;
function setLocaleId(localeId) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(localeId, `Expected localeId to be defined`);
  if (typeof localeId === "string") {
    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
  }
}
function getLocaleId() {
  return LOCALE_ID$1;
}
let changeMask = 0;
let changeMaskCounter = 0;
function setMaskBit(hasChange) {
  if (hasChange) {
    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
  }
  changeMaskCounter++;
}
function applyI18n(tView, lView, index) {
  if (changeMaskCounter > 0) {
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(tView, `tView should be defined`);
    const tI18n = tView.data[index];
    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
    const bindingsStartIndex = (0, import_root_effect_scheduler.getBindingIndex)() - changeMaskCounter - 1;
    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
  }
  changeMask = 0;
  changeMaskCounter = 0;
}
function createNodeWithoutHydration(lView, textOrName, nodeType) {
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  switch (nodeType) {
    case Node.COMMENT_NODE:
      return createCommentNode(renderer, textOrName);
    case Node.TEXT_NODE:
      return createTextNode(renderer, textOrName);
    case Node.ELEMENT_NODE:
      return createElementNode(renderer, textOrName, null);
  }
}
let _locateOrCreateNode = (lView, index, textOrName, nodeType) => {
  (0, import_root_effect_scheduler.lastNodeWasCreated)(true);
  return createNodeWithoutHydration(lView, textOrName, nodeType);
};
function locateOrCreateNodeImpl(lView, index, textOrName, nodeType) {
  const hydrationInfo = lView[import_root_effect_scheduler.HYDRATION];
  const noOffsetIndex = index - import_root_effect_scheduler.HEADER_OFFSET;
  const isNodeCreationMode = !isI18nHydrationSupportEnabled() || !hydrationInfo || (0, import_root_effect_scheduler.isInSkipHydrationBlock)() || isDisconnectedNode$1(hydrationInfo, noOffsetIndex);
  (0, import_root_effect_scheduler.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createNodeWithoutHydration(lView, textOrName, nodeType);
  }
  const native = locateI18nRNodeByIndex(hydrationInfo, noOffsetIndex);
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(native, "expected native element");
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(native.nodeType, nodeType, "expected matching nodeType");
  ngDevMode && nodeType === Node.ELEMENT_NODE && (0, import_root_effect_scheduler.assertEqual)(native.tagName.toLowerCase(), textOrName.toLowerCase(), "expecting matching tagName");
  ngDevMode && markRNodeAsClaimedByHydration(native);
  return native;
}
function enableLocateOrCreateI18nNodeImpl() {
  _locateOrCreateNode = locateOrCreateNodeImpl;
}
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    let rNode = lView[index];
    let lastNodeWasCreated2 = false;
    if (rNode === null) {
      rNode = lView[index] = _locateOrCreateNode(lView, index, text, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);
      lastNodeWasCreated2 = (0, import_root_effect_scheduler.wasLastNodeCreated)();
    }
    if (appendNow && parentRNode !== null && lastNodeWasCreated2) {
      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
  }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
  ngDevMode && (0, import_root_effect_scheduler.assertDomNode)(anchorRNode);
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  let rootIdx = null;
  let rootRNode;
  for (let i = 0; i < mutableOpCodes.length; i++) {
    const opCode = mutableOpCodes[i];
    if (typeof opCode == "string") {
      const textNodeIndex = mutableOpCodes[++i];
      if (lView[textNodeIndex] === null) {
        ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, textNodeIndex);
        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);
      }
    } else if (typeof opCode == "number") {
      switch (opCode & 1) {
        case 0:
          const parentIdx = getParentFromIcuCreateOpCode(opCode);
          if (rootIdx === null) {
            rootIdx = parentIdx;
            rootRNode = renderer.parentNode(anchorRNode);
          }
          let insertInFrontOf;
          let parentRNode;
          if (parentIdx === rootIdx) {
            insertInFrontOf = anchorRNode;
            parentRNode = rootRNode;
          } else {
            insertInFrontOf = null;
            parentRNode = (0, import_root_effect_scheduler.unwrapRNode)(lView[parentIdx]);
          }
          if (parentRNode !== null) {
            ngDevMode && (0, import_root_effect_scheduler.assertDomNode)(parentRNode);
            const refIdx = getRefFromIcuCreateOpCode(opCode);
            ngDevMode && (0, import_root_effect_scheduler.assertGreaterThan)(refIdx, import_root_effect_scheduler.HEADER_OFFSET, "Missing ref");
            const child = lView[refIdx];
            ngDevMode && (0, import_root_effect_scheduler.assertDomNode)(child);
            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
            const tIcu = getTIcu(tView, refIdx);
            if (tIcu !== null && typeof tIcu === "object") {
              ngDevMode && (0, import_root_effect_scheduler.assertTIcu)(tIcu);
              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
              if (caseIndex !== null) {
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
              }
            }
          }
          break;
        case 1:
          const elementNodeIndex = opCode >>> 1;
          const attrName = mutableOpCodes[++i];
          const attrValue = mutableOpCodes[++i];
          setElementAttribute(renderer, (0, import_root_effect_scheduler.getNativeByIndex)(elementNodeIndex, lView), null, null, attrName, attrValue, null);
          break;
        default:
          if (ngDevMode) {
            throw new import_root_effect_scheduler.RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
          }
      }
    } else {
      switch (opCode) {
        case ICU_MARKER:
          const commentValue = mutableOpCodes[++i];
          const commentNodeIndex = mutableOpCodes[++i];
          if (lView[commentNodeIndex] === null) {
            ngDevMode && (0, import_root_effect_scheduler.assertEqual)(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
            ngDevMode && (0, import_root_effect_scheduler.assertIndexInExpandoRange)(lView, commentNodeIndex);
            const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);
            attachPatchData(commentRNode, lView);
          }
          break;
        case ELEMENT_MARKER:
          const tagName = mutableOpCodes[++i];
          const elementNodeIndex = mutableOpCodes[++i];
          if (lView[elementNodeIndex] === null) {
            ngDevMode && (0, import_root_effect_scheduler.assertEqual)(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
            ngDevMode && (0, import_root_effect_scheduler.assertIndexInExpandoRange)(lView, elementNodeIndex);
            const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);
            attachPatchData(elementRNode, lView);
          }
          break;
        default:
          ngDevMode && (0, import_root_effect_scheduler.throwError)(`Unable to determine the type of mutate operation for "${opCode}"`);
      }
    }
  }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
  for (let i = 0; i < updateOpCodes.length; i++) {
    const checkBit = updateOpCodes[i];
    const skipCodes = updateOpCodes[++i];
    if (checkBit & changeMask2) {
      let value = "";
      for (let j = i + 1; j <= i + skipCodes; j++) {
        const opCode = updateOpCodes[j];
        if (typeof opCode == "string") {
          value += opCode;
        } else if (typeof opCode == "number") {
          if (opCode < 0) {
            value += (0, import_root_effect_scheduler.renderStringify)(lView[bindingsStartIndex - opCode]);
          } else {
            const nodeIndex = opCode >>> 2;
            switch (opCode & 3) {
              case 1:
                const propName = updateOpCodes[++j];
                const sanitizeFn = updateOpCodes[++j];
                const tNodeOrTagName = tView.data[nodeIndex];
                ngDevMode && (0, import_root_effect_scheduler.assertDefined)(tNodeOrTagName, "Experting TNode or string");
                if (typeof tNodeOrTagName === "string") {
                  setElementAttribute(lView[import_root_effect_scheduler.RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                } else {
                  setPropertyAndInputs(tNodeOrTagName, lView, propName, value, lView[import_root_effect_scheduler.RENDERER], sanitizeFn);
                }
                break;
              case 0:
                const rText = lView[nodeIndex];
                rText !== null && updateTextNode(lView[import_root_effect_scheduler.RENDERER], rText, value);
                break;
              case 2:
                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                break;
              case 3:
                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                break;
            }
          }
        }
      }
    } else {
      const opCode = updateOpCodes[i + 1];
      if (opCode > 0 && (opCode & 3) === 3) {
        const nodeIndex = opCode >>> 2;
        const tIcu = getTIcu(tView, nodeIndex);
        const currentIndex = lView[tIcu.currentCaseLViewIndex];
        if (currentIndex < 0) {
          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
        }
      }
    }
    i += skipCodes;
  }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, tIcu.currentCaseLViewIndex);
  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
  if (activeCaseIndex !== null) {
    let mask = changeMask;
    if (activeCaseIndex < 0) {
      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
      mask = -1;
    }
    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
  }
}
function applyIcuSwitchCase(tView, tIcu, lView, value) {
  const caseIndex = getCaseIndex(tIcu, value);
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== caseIndex) {
    applyIcuSwitchCaseRemove(tView, tIcu, lView);
    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
    if (caseIndex !== null) {
      const anchorRNode = lView[tIcu.anchorIdx];
      if (anchorRNode) {
        ngDevMode && (0, import_root_effect_scheduler.assertDomNode)(anchorRNode);
        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
      }
      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);
    }
  }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== null) {
    const removeCodes = tIcu.remove[activeCaseIndex];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        const rNode = (0, import_root_effect_scheduler.getNativeByIndex)(nodeOrIcuIndex, lView);
        rNode !== null && nativeRemoveNode(lView[import_root_effect_scheduler.RENDERER], rNode);
      } else {
        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
      }
    }
  }
}
function getCaseIndex(icuExpression, bindingValue) {
  let index = icuExpression.cases.indexOf(bindingValue);
  if (index === -1) {
    switch (icuExpression.type) {
      case 1: {
        const resolvedCase = getPluralCase(bindingValue, getLocaleId());
        index = icuExpression.cases.indexOf(resolvedCase);
        if (index === -1 && resolvedCase !== "other") {
          index = icuExpression.cases.indexOf("other");
        }
        break;
      }
      case 0: {
        index = icuExpression.cases.indexOf("other");
        break;
      }
    }
  }
  return index === -1 ? null : index;
}
function i18nCreateOpCodesToString(opcodes) {
  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
    if (appendNow) {
      lines.push(`parent.appendChild(lView[${index}]);`);
    }
  }
  return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(value) {
    const ref = value >>> 2;
    const opCode = value & 3;
    switch (opCode) {
      case 0:
        return `(lView[${ref}] as Text).textContent = $$$`;
      case 1:
        const attrName = parser.consumeString();
        const sanitizationFn = parser.consumeFunction();
        const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
      case 2:
        return `icuSwitchCase(${ref}, $$$)`;
      case 3:
        return `icuUpdateCase(${ref})`;
    }
    throw new Error("unexpected OpCode");
  }
  while (parser.hasMore()) {
    let mask = parser.consumeNumber();
    let size = parser.consumeNumber();
    const end = parser.i + size;
    const statements = [];
    let statement = "";
    while (parser.i < end) {
      let value = parser.consumeNumberOrString();
      if (typeof value === "string") {
        statement += value;
      } else if (value < 0) {
        statement += "${lView[i" + value + "]}";
      } else {
        const opCodeText = consumeOpCode(value);
        statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
        statement = "";
      }
    }
    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
  }
  return lines;
}
function icuCreateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(opCode) {
    const parent = getParentFromIcuCreateOpCode(opCode);
    const ref = getRefFromIcuCreateOpCode(opCode);
    switch (getInstructionFromIcuCreateOpCode(opCode)) {
      case 0:
        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
      case 1:
        return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
    }
    throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
  }
  let lastRef = -1;
  while (parser.hasMore()) {
    let value = parser.consumeNumberStringOrMarker();
    if (value === ICU_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
    } else if (value === ELEMENT_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
    } else if (typeof value === "string") {
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
    } else if (typeof value === "number") {
      const line = consumeOpCode(value);
      line && lines.push(line);
    } else {
      throw new Error("Unexpected value");
    }
  }
  return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < removeCodes.length; i++) {
    const nodeOrIcuIndex = removeCodes[i];
    if (nodeOrIcuIndex > 0) {
      lines.push(`remove(lView[${nodeOrIcuIndex}])`);
    } else {
      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
  }
  return lines;
}
class OpCodeParser {
  constructor(codes) {
    __publicField(this, "i", 0);
    __publicField(this, "codes");
    this.codes = codes;
  }
  hasMore() {
    return this.i < this.codes.length;
  }
  consumeNumber() {
    let value = this.codes[this.i++];
    (0, import_root_effect_scheduler.assertNumber)(value, "expecting number in OpCode");
    return value;
  }
  consumeString() {
    let value = this.codes[this.i++];
    (0, import_root_effect_scheduler.assertString)(value, "expecting string in OpCode");
    return value;
  }
  consumeFunction() {
    let value = this.codes[this.i++];
    if (value === null || typeof value === "function") {
      return value;
    }
    throw new Error("expecting function in OpCode");
  }
  consumeNumberOrString() {
    let value = this.codes[this.i++];
    if (typeof value === "string") {
      return value;
    }
    (0, import_root_effect_scheduler.assertNumber)(value, "expecting number or string in OpCode");
    return value;
  }
  consumeNumberStringOrMarker() {
    let value = this.codes[this.i++];
    if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
      return value;
    }
    (0, import_root_effect_scheduler.assertNumber)(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
    return value;
  }
}
const BINDING_REGEXP = /(\d+):?\d*/gi;
const ICU_REGEXP = /({\s*\d+:?\d*\s*,\s*\S{6}\s*,[\s\S]*})/gi;
const NESTED_ICU = /(\d+)/;
const ICU_BLOCK_REGEXP = /^\s*(\d+:?\d*)\s*,\s*(select|plural)\s*,/;
const MARKER = `\uFFFD`;
const SUBTEMPLATE_REGEXP = /\/?\*(\d+:\d+)/gi;
const PH_REGEXP = /(\/?[#*]\d+):?\d*/gi;
const NGSP_UNICODE_REGEXP = /\uE500/g;
function replaceNgsp(value) {
  return value.replace(NGSP_UNICODE_REGEXP, " ");
}
function attachDebugGetter(obj, debugGetter) {
  if (ngDevMode) {
    Object.defineProperty(obj, "debug", { get: debugGetter, enumerable: false });
  } else {
    throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
  }
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
  const rootTNode = (0, import_root_effect_scheduler.getCurrentParentTNode)();
  const createOpCodes = [];
  const updateOpCodes = [];
  const existingTNodeStack = [[]];
  const astStack = [[]];
  if (ngDevMode) {
    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  message = getTranslationForTemplate(message, subTemplateIndex);
  const msgParts = replaceNgsp(message).split(PH_REGEXP);
  for (let i = 0; i < msgParts.length; i++) {
    let value = msgParts[i];
    if ((i & 1) === 0) {
      const parts = i18nParseTextIntoPartsAndICU(value);
      for (let j = 0; j < parts.length; j++) {
        let part = parts[j];
        if ((j & 1) === 0) {
          const text = part;
          ngDevMode && (0, import_root_effect_scheduler.assertString)(text, "Parsed ICU part should be string");
          if (text !== "") {
            i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
          }
        } else {
          const icuExpression = part;
          if (typeof icuExpression !== "object") {
            throw new Error(`Unable to parse ICU expression in "${message}" message.`);
          }
          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
          const icuNodeIndex = icuContainerTNode.index;
          ngDevMode && (0, import_root_effect_scheduler.assertGreaterThanOrEqual)(icuNodeIndex, import_root_effect_scheduler.HEADER_OFFSET, "Index must be in absolute LView offset");
          icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
        }
      }
    } else {
      const isClosing = value.charCodeAt(0) === 47;
      const type = value.charCodeAt(isClosing ? 1 : 0);
      ngDevMode && (0, import_root_effect_scheduler.assertOneOf)(
        type,
        42,
        35
        /* CharCode.HASH */
      );
      const index2 = import_root_effect_scheduler.HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
      if (isClosing) {
        existingTNodeStack.shift();
        astStack.shift();
        (0, import_root_effect_scheduler.setCurrentTNode)((0, import_root_effect_scheduler.getCurrentParentTNode)(), false);
      } else {
        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
        existingTNodeStack.unshift([]);
        (0, import_root_effect_scheduler.setCurrentTNode)(tNode, true);
        const placeholderNode = {
          kind: 2,
          index: index2,
          children: [],
          type: type === 35 ? 0 : 1
        };
        astStack[0].push(placeholderNode);
        astStack.unshift(placeholderNode.children);
      }
    }
  }
  tView.data[index] = {
    create: createOpCodes,
    update: updateOpCodes,
    ast: astStack[0],
    parentTNodeIndex
  };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
  let parentTNode = (0, import_root_effect_scheduler.getCurrentParentTNode)();
  if (rootTNode === parentTNode) {
    parentTNode = null;
  }
  if (parentTNode === null) {
    opCode |= I18nCreateOpCode.APPEND_EAGERLY;
  }
  if (isICU) {
    opCode |= I18nCreateOpCode.COMMENT;
    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
  }
  createOpCodes.push(opCode, text === null ? "" : text);
  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? "{{?}}" : "" : text, null);
  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
  const tNodeIdx = tNode.index;
  (0, import_root_effect_scheduler.setCurrentTNode)(
    tNode,
    false
    /* Text nodes are self closing */
  );
  if (parentTNode !== null && rootTNode !== parentTNode) {
    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
  }
  return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
  const hasBinding = text.match(BINDING_REGEXP);
  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
  const index = tNode.index;
  if (hasBinding) {
    generateBindingUpdateOpCodes(updateOpCodes, text, index, null, 0, null);
  }
  ast.push({ kind: 0, index });
}
function i18nAttributesFirstPass(tView, index, values) {
  const previousElement = (0, import_root_effect_scheduler.getCurrentTNode)();
  const previousElementIndex = previousElement.index;
  const updateOpCodes = [];
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  if (tView.firstCreatePass && tView.data[index] === null) {
    for (let i = 0; i < values.length; i += 2) {
      const attrName = values[i];
      const message = values[i + 1];
      if (message !== "") {
        if (ICU_REGEXP.test(message)) {
          throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
        }
        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
      }
    }
    tView.data[index] = updateOpCodes;
  }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
  ngDevMode && (0, import_root_effect_scheduler.assertGreaterThanOrEqual)(destinationNode, import_root_effect_scheduler.HEADER_OFFSET, "Index must be in absolute LView offset");
  const maskIndex = updateOpCodes.length;
  const sizeIndex = maskIndex + 1;
  updateOpCodes.push(null, null);
  const startIndex = maskIndex + 2;
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  const textParts = str.split(BINDING_REGEXP);
  let mask = 0;
  for (let j = 0; j < textParts.length; j++) {
    const textValue = textParts[j];
    if (j & 1) {
      const bindingIndex = bindingStart + parseInt(textValue, 10);
      updateOpCodes.push(-1 - bindingIndex);
      mask = mask | toMaskBit(bindingIndex);
    } else if (textValue !== "") {
      updateOpCodes.push(textValue);
    }
  }
  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
  if (attrName) {
    updateOpCodes.push(attrName, sanitizeFn);
  }
  updateOpCodes[maskIndex] = mask;
  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
  return mask;
}
function countBindings(opCodes) {
  let count = 0;
  for (let i = 0; i < opCodes.length; i++) {
    const opCode = opCodes[i];
    if (typeof opCode === "number" && opCode < 0) {
      count++;
    }
  }
  return count;
}
function toMaskBit(bindingIndex) {
  return 1 << Math.min(bindingIndex, 31);
}
function removeInnerTemplateTranslation(message) {
  let match;
  let res = "";
  let index = 0;
  let inTemplate = false;
  let tagMatched;
  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
    if (!inTemplate) {
      res += message.substring(index, match.index + match[0].length);
      tagMatched = match[1];
      inTemplate = true;
    } else {
      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
        index = match.index;
        inTemplate = false;
      }
    }
  }
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
  res += message.slice(index);
  return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
  if (isRootTemplateMessage(subTemplateIndex)) {
    return removeInnerTemplateTranslation(message);
  } else {
    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
    const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
    return removeInnerTemplateTranslation(message.substring(start, end));
  }
}
function icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(icuExpression, "ICU expression must be defined");
  let bindingMask = 0;
  const tIcu = {
    type: icuExpression.type,
    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
    anchorIdx,
    cases: [],
    create: [],
    remove: [],
    update: []
  };
  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
  setTIcu(tView, anchorIdx, tIcu);
  const values = icuExpression.values;
  const cases = [];
  for (let i = 0; i < values.length; i++) {
    const valueArr = values[i];
    const nestedIcus = [];
    for (let j = 0; j < valueArr.length; j++) {
      const value = valueArr[j];
      if (typeof value !== "string") {
        const icuIndex = nestedIcus.push(value) - 1;
        valueArr[j] = `<!--\uFFFD${icuIndex}\uFFFD-->`;
      }
    }
    const caseAst = [];
    cases.push(caseAst);
    bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(""), nestedIcus) | bindingMask;
  }
  if (bindingMask) {
    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
  }
  ast.push({
    kind: 3,
    index: anchorIdx,
    cases,
    currentCaseLViewIndex: tIcu.currentCaseLViewIndex
  });
}
function parseICUBlock(pattern) {
  const cases = [];
  const values = [];
  let icuType = 1;
  let mainBinding = 0;
  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
    if (type === "select") {
      icuType = 0;
    } else {
      icuType = 1;
    }
    mainBinding = parseInt(binding.slice(1), 10);
    return "";
  });
  const parts = i18nParseTextIntoPartsAndICU(pattern);
  for (let pos = 0; pos < parts.length; ) {
    let key = parts[pos++].trim();
    if (icuType === 1) {
      key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
    }
    if (key.length) {
      cases.push(key);
    }
    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
    if (cases.length > values.length) {
      values.push(blocks);
    }
  }
  return { type: icuType, mainBinding, cases, values };
}
function i18nParseTextIntoPartsAndICU(pattern) {
  if (!pattern) {
    return [];
  }
  let prevPos = 0;
  const braceStack = [];
  const results = [];
  const braces = /[{}]/g;
  braces.lastIndex = 0;
  let match;
  while (match = braces.exec(pattern)) {
    const pos = match.index;
    if (match[0] == "}") {
      braceStack.pop();
      if (braceStack.length == 0) {
        const block = pattern.substring(prevPos, pos);
        if (ICU_BLOCK_REGEXP.test(block)) {
          results.push(parseICUBlock(block));
        } else {
          results.push(block);
        }
        prevPos = pos + 1;
      }
    } else {
      if (braceStack.length == 0) {
        const substring2 = pattern.substring(prevPos, pos);
        results.push(substring2);
        prevPos = pos + 1;
      }
      braceStack.push("{");
    }
  }
  const substring = pattern.substring(prevPos);
  results.push(substring);
  return results;
}
function parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
  const create = [];
  const remove2 = [];
  const update = [];
  if (ngDevMode) {
    attachDebugGetter(create, icuCreateOpCodesToString);
    attachDebugGetter(remove2, i18nRemoveOpCodesToString);
    attachDebugGetter(update, i18nUpdateOpCodesToString);
  }
  tIcu.cases.push(caseName);
  tIcu.create.push(create);
  tIcu.remove.push(remove2);
  tIcu.update.push(update);
  const inertBodyHelper2 = getInertBodyHelper(getDocument());
  const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(inertBodyElement, "Unable to generate inert body element");
  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
  if (inertRootNode) {
    return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx, nestedIcus, 0);
  } else {
    return 0;
  }
}
function walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx, nestedIcus, depth) {
  let bindingMask = 0;
  let currentNode = parentNode.firstChild;
  while (currentNode) {
    const newIndex = allocExpando(tView, lView, 1, null);
    switch (currentNode.nodeType) {
      case Node.ELEMENT_NODE:
        const element = currentNode;
        const tagName = element.tagName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
          tView.data[newIndex] = tagName;
          const elAttrs = element.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
            const attr = elAttrs.item(i);
            const lowerAttrName = attr.name.toLowerCase();
            const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
            if (hasBinding2) {
              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                if (URI_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                } else {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                }
              } else {
                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${import_root_effect_scheduler.XSS_SECURITY_URL})`);
              }
            } else {
              addCreateAttribute(create, newIndex, attr);
            }
          }
          const elementNode = {
            kind: 1,
            index: newIndex,
            children: []
          };
          ast.push(elementNode);
          bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
          addRemoveNode(remove2, newIndex, depth);
        }
        break;
      case Node.TEXT_NODE:
        const value = currentNode.textContent || "";
        const hasBinding = value.match(BINDING_REGEXP);
        addCreateNodeAndAppend(create, null, hasBinding ? "" : value, parentIdx, newIndex);
        addRemoveNode(remove2, newIndex, depth);
        if (hasBinding) {
          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
        }
        ast.push({
          kind: 0,
          index: newIndex
        });
        break;
      case Node.COMMENT_NODE:
        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
        if (isNestedIcu) {
          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
          const icuExpression = nestedIcus[nestedIcuIndex];
          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
          addRemoveNestedIcu(remove2, newIndex, depth);
        }
        break;
    }
    currentNode = currentNode.nextSibling;
  }
  return bindingMask;
}
function addRemoveNode(remove2, index, depth) {
  if (depth === 0) {
    remove2.push(index);
  }
}
function addRemoveNestedIcu(remove2, index, depth) {
  if (depth === 0) {
    remove2.push(~index);
    remove2.push(index);
  }
}
function addUpdateIcuSwitch(update, icuExpression, index) {
  update.push(
    toMaskBit(icuExpression.mainBinding),
    2,
    -1 - icuExpression.mainBinding,
    index << 2 | 2
    /* I18nUpdateOpCode.IcuSwitch */
  );
}
function addUpdateIcuUpdate(update, bindingMask, index) {
  update.push(
    bindingMask,
    1,
    index << 2 | 3
    /* I18nUpdateOpCode.IcuUpdate */
  );
}
function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
  if (marker !== null) {
    create.push(marker);
  }
  create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
}
function addCreateAttribute(create, newIndex, attr) {
  create.push(newIndex << 1 | 1, attr.name, attr.value);
}
const ROOT_TEMPLATE_ID = 0;
const PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(.+??)\]/;
const PP_PLACEHOLDERS_REGEXP = /\[(.+??)\]|(\/?\*\d+:\d+)/g;
const PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
const PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
const PP_ICUS_REGEXP = /I18N_EXP_(ICU(_\d+)?)/g;
const PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
const PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
function i18nPostprocess(message, replacements = {}) {
  let result = message;
  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
    const matches = {};
    const templateIdsStack = [ROOT_TEMPLATE_ID];
    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
      const content = phs || tmpl;
      const placeholders = matches[content] || [];
      if (!placeholders.length) {
        content.split("|").forEach((placeholder2) => {
          const match = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
          const templateId2 = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;
          const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
          placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
        });
        matches[content] = placeholders;
      }
      if (!placeholders.length) {
        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
      }
      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
      let idx = 0;
      for (let i = 0; i < placeholders.length; i++) {
        if (placeholders[i][0] === currentTemplateId) {
          idx = i;
          break;
        }
      }
      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
      if (isCloseTemplateTag) {
        templateIdsStack.pop();
      } else if (currentTemplateId !== templateId) {
        templateIdsStack.push(templateId);
      }
      placeholders.splice(idx, 1);
      return placeholder;
    });
  }
  if (!Object.keys(replacements).length) {
    return result;
  }
  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {
    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;
  });
  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {
    return replacements.hasOwnProperty(key) ? replacements[key] : match;
  });
  result = result.replace(PP_ICUS_REGEXP, (match, key) => {
    if (replacements.hasOwnProperty(key)) {
      const list = replacements[key];
      if (!list.length) {
        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);
      }
      return list.shift();
    }
    return match;
  });
  return result;
}
function \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {
  const tView = (0, import_root_effect_scheduler.getTView)();
  const lView = (0, import_root_effect_scheduler.getLView)();
  const adjustedIndex = import_root_effect_scheduler.HEADER_OFFSET + index;
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(tView, `tView should be defined`);
  const message = (0, import_root_effect_scheduler.getConstant)(tView.consts, messageIndex);
  const parentTNode = (0, import_root_effect_scheduler.getCurrentParentTNode)();
  if (tView.firstCreatePass) {
    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
  }
  if (tView.type === 2) {
    const componentLView = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW];
    componentLView[import_root_effect_scheduler.FLAGS] |= 32;
  } else {
    lView[import_root_effect_scheduler.FLAGS] |= 32;
  }
  const tI18n = tView.data[adjustedIndex];
  const sameViewParentTNode = parentTNode === lView[import_root_effect_scheduler.T_HOST] ? null : parentTNode;
  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
  prepareI18nBlockForHydration(lView, adjustedIndex, parentTNode, subTemplateIndex);
  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
  (0, import_root_effect_scheduler.setInI18nBlock)(true);
}
function \u0275\u0275i18nEnd() {
  (0, import_root_effect_scheduler.setInI18nBlock)(false);
}
function \u0275\u0275i18n(index, messageIndex, subTemplateIndex) {
  \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex);
  \u0275\u0275i18nEnd();
}
function \u0275\u0275i18nAttributes(index, attrsIndex) {
  const tView = (0, import_root_effect_scheduler.getTView)();
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(tView, `tView should be defined`);
  const attrs = (0, import_root_effect_scheduler.getConstant)(tView.consts, attrsIndex);
  i18nAttributesFirstPass(tView, index + import_root_effect_scheduler.HEADER_OFFSET, attrs);
}
function \u0275\u0275i18nExp(value) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  setMaskBit(bindingUpdated(lView, (0, import_root_effect_scheduler.nextBindingIndex)(), value));
  return \u0275\u0275i18nExp;
}
function \u0275\u0275i18nApply(index) {
  applyI18n((0, import_root_effect_scheduler.getTView)(), (0, import_root_effect_scheduler.getLView)(), index + import_root_effect_scheduler.HEADER_OFFSET);
}
function \u0275\u0275i18nPostprocess(message, replacements = {}) {
  return i18nPostprocess(message, replacements);
}
function \u0275\u0275listener(eventName, listenerFn, eventTargetResolver) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  listenerInternal(tView, lView, lView[import_root_effect_scheduler.RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
  return \u0275\u0275listener;
}
function \u0275\u0275syntheticHostListener(eventName, listenerFn) {
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const currentDef = (0, import_root_effect_scheduler.getCurrentDirectiveDef)(tView.data);
  const renderer = loadComponentRenderer(currentDef, tNode, lView);
  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
  return \u0275\u0275syntheticHostListener;
}
function \u0275\u0275domListener(eventName, listenerFn, eventTargetResolver) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  if (tNode.type & 3 || eventTargetResolver) {
    listenToDomEvent(tNode, tView, lView, eventTargetResolver, lView[import_root_effect_scheduler.RENDERER], eventName, listenerFn, wrapListener(tNode, lView, listenerFn));
  }
  return \u0275\u0275domListener;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
  var _a2, _b2;
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  let processOutputs = true;
  let wrappedListener = null;
  if (tNode.type & 3 || eventTargetResolver) {
    wrappedListener != null ? wrappedListener : wrappedListener = wrapListener(tNode, lView, listenerFn);
    const hasCoalescedDomEvent = listenToDomEvent(tNode, tView, lView, eventTargetResolver, renderer, eventName, listenerFn, wrappedListener);
    if (hasCoalescedDomEvent) {
      processOutputs = false;
    }
  }
  if (processOutputs) {
    const outputConfig = (_a2 = tNode.outputs) == null ? void 0 : _a2[eventName];
    const hostDirectiveOutputConfig = (_b2 = tNode.hostDirectiveOutputs) == null ? void 0 : _b2[eventName];
    if (hostDirectiveOutputConfig && hostDirectiveOutputConfig.length) {
      for (let i = 0; i < hostDirectiveOutputConfig.length; i += 2) {
        const index = hostDirectiveOutputConfig[i];
        const lookupName = hostDirectiveOutputConfig[i + 1];
        wrappedListener != null ? wrappedListener : wrappedListener = wrapListener(tNode, lView, listenerFn);
        listenToOutput(tNode, lView, index, lookupName, eventName, wrappedListener);
      }
    }
    if (outputConfig && outputConfig.length) {
      for (const index of outputConfig) {
        wrappedListener != null ? wrappedListener : wrappedListener = wrapListener(tNode, lView, listenerFn);
        listenToOutput(tNode, lView, index, eventName, eventName, wrappedListener);
      }
    }
  }
}
function \u0275\u0275nextContext(level = 1) {
  return (0, import_root_effect_scheduler.nextContextImpl)(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
  let wildcardNgContentIndex = null;
  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
  for (let i = 0; i < projectionSlots.length; i++) {
    const slotValue = projectionSlots[i];
    if (slotValue === "*") {
      wildcardNgContentIndex = i;
      continue;
    }
    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(
      tNode,
      slotValue,
      /* isProjectionMode */
      true
    ) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
      return i;
    }
  }
  return wildcardNgContentIndex;
}
function \u0275\u0275projectionDef(projectionSlots) {
  const componentNode = (0, import_root_effect_scheduler.getLView)()[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW][import_root_effect_scheduler.T_HOST];
  if (!componentNode.projection) {
    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
    const projectionHeads = componentNode.projection = (0, import_root_effect_scheduler.newArray)(numProjectionSlots, null);
    const tails = projectionHeads.slice();
    let componentChild = componentNode.child;
    while (componentChild !== null) {
      if (componentChild.type !== 128) {
        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
      }
      componentChild = componentChild.next;
    }
  }
}
function \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs, fallbackTemplateFn, fallbackDecls, fallbackVars) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;
  if (fallbackIndex !== null) {
    declareNoDirectiveHostTemplate(lView, tView, fallbackIndex, fallbackTemplateFn, fallbackDecls, fallbackVars, null, attrs);
  }
  const tProjectionNode = getOrCreateTNode(tView, import_root_effect_scheduler.HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
  if (tProjectionNode.projection === null) {
    tProjectionNode.projection = selectorIndex;
  }
  (0, import_root_effect_scheduler.setCurrentTNodeAsNotParent)();
  const hydrationInfo = lView[import_root_effect_scheduler.HYDRATION];
  const isNodeCreationMode = !hydrationInfo || (0, import_root_effect_scheduler.isInSkipHydrationBlock)();
  const componentHostNode = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW][import_root_effect_scheduler.T_HOST];
  const isEmpty = componentHostNode.projection[tProjectionNode.projection] === null;
  if (isEmpty && fallbackIndex !== null) {
    insertFallbackContent(lView, tView, fallbackIndex);
  } else if (isNodeCreationMode && !isDetachedByI18n(tProjectionNode)) {
    applyProjection(tView, lView, tProjectionNode);
  }
}
function insertFallbackContent(lView, tView, fallbackIndex) {
  const adjustedIndex = import_root_effect_scheduler.HEADER_OFFSET + fallbackIndex;
  const fallbackTNode = tView.data[adjustedIndex];
  const fallbackLContainer = lView[adjustedIndex];
  ngDevMode && (0, import_root_effect_scheduler.assertTNode)(fallbackTNode);
  ngDevMode && (0, import_root_effect_scheduler.assertLContainer)(fallbackLContainer);
  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView.ssrId);
  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, void 0, {
    dehydratedView
  });
  addLViewToLContainer(fallbackLContainer, fallbackLView, 0, shouldAddViewToDom(fallbackTNode, dehydratedView));
}
function \u0275\u0275contentQuery(directiveIndex, predicate, flags, read) {
  createContentQuery(directiveIndex, predicate, flags, read);
}
function \u0275\u0275viewQuery(predicate, flags, read) {
  createViewQuery(predicate, flags, read);
}
function \u0275\u0275queryRefresh(queryList) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const queryIndex = (0, import_root_effect_scheduler.getCurrentQueryIndex)();
  (0, import_root_effect_scheduler.setCurrentQueryIndex)(queryIndex + 1);
  const tQuery = getTQuery(tView, queryIndex);
  if (queryList.dirty && (0, import_root_effect_scheduler.isCreationMode)(lView) === ((tQuery.metadata.flags & 2) === 2)) {
    if (tQuery.matches === null) {
      queryList.reset([]);
    } else {
      const result = getQueryResults(lView, queryIndex);
      queryList.reset(result, unwrapElementRef);
      queryList.notifyOnChanges();
    }
    return true;
  }
  return false;
}
function \u0275\u0275loadQuery() {
  return loadQueryInternal((0, import_root_effect_scheduler.getLView)(), (0, import_root_effect_scheduler.getCurrentQueryIndex)());
}
function \u0275\u0275contentQuerySignal(directiveIndex, target, predicate, flags, read) {
  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));
}
function \u0275\u0275viewQuerySignal(target, predicate, flags, read) {
  bindQueryToSignal(target, createViewQuery(predicate, flags, read));
}
function \u0275\u0275queryAdvance(indexOffset = 1) {
  (0, import_root_effect_scheduler.setCurrentQueryIndex)((0, import_root_effect_scheduler.getCurrentQueryIndex)() + indexOffset);
}
function \u0275\u0275reference(index) {
  const contextLView = (0, import_root_effect_scheduler.getContextLView)();
  return (0, import_root_effect_scheduler.load)(contextLView, import_root_effect_scheduler.HEADER_OFFSET + index);
}
function toTStylingRange(prev, next) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumberInRange)(
    prev,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  ngDevMode && (0, import_root_effect_scheduler.assertNumberInRange)(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(tStylingRange, "expected number");
  return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(tStylingRange, "expected number");
  return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(tStylingRange, "expected number");
  ngDevMode && (0, import_root_effect_scheduler.assertNumberInRange)(
    previous,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~4294836224 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(tStylingRange, "expected number");
  return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(tStylingRange, "expected number");
  return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(tStylingRange, "expected number");
  ngDevMode && (0, import_root_effect_scheduler.assertNumberInRange)(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~131068 | //
  next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(tStylingRange, "expected number");
  return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && (0, import_root_effect_scheduler.assertNumber)(tStylingRange, "expected number");
  return tStylingRange | 1;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
  ngDevMode && (0, import_root_effect_scheduler.assertFirstUpdatePass)((0, import_root_effect_scheduler.getTView)());
  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
  let tmplHead = getTStylingRangePrev(tBindings);
  let tmplTail = getTStylingRangeNext(tBindings);
  tData[index] = tStylingKeyWithStatic;
  let isKeyDuplicateOfStatic = false;
  let tStylingKey;
  if (Array.isArray(tStylingKeyWithStatic)) {
    const staticKeyValueArray = tStylingKeyWithStatic;
    tStylingKey = staticKeyValueArray[1];
    if (tStylingKey === null || (0, import_root_effect_scheduler.keyValueArrayIndexOf)(staticKeyValueArray, tStylingKey) > 0) {
      isKeyDuplicateOfStatic = true;
    }
  } else {
    tStylingKey = tStylingKeyWithStatic;
  }
  if (isHostBinding) {
    const hasTemplateBindings = tmplTail !== 0;
    if (hasTemplateBindings) {
      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
      tData[index + 1] = toTStylingRange(previousNode, tmplHead);
      if (previousNode !== 0) {
        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
      }
      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
    } else {
      tData[index + 1] = toTStylingRange(tmplHead, 0);
      if (tmplHead !== 0) {
        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
      }
      tmplHead = index;
    }
  } else {
    tData[index + 1] = toTStylingRange(tmplTail, 0);
    ngDevMode && (0, import_root_effect_scheduler.assertEqual)(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
    if (tmplHead === 0) {
      tmplHead = index;
    } else {
      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
    }
    tmplTail = index;
  }
  if (isKeyDuplicateOfStatic) {
    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
  }
  markDuplicates(tData, tStylingKey, index, true);
  markDuplicates(tData, tStylingKey, index, false);
  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
  tBindings = toTStylingRange(tmplHead, tmplTail);
  if (isClassBinding) {
    tNode.classBindings = tBindings;
  } else {
    tNode.styleBindings = tBindings;
  }
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
  if (residual != null && typeof tStylingKey == "string" && (0, import_root_effect_scheduler.keyValueArrayIndexOf)(residual, tStylingKey) >= 0) {
    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
  }
}
function markDuplicates(tData, tStylingKey, index, isPrevDir) {
  const tStylingAtIndex = tData[index + 1];
  const isMap = tStylingKey === null;
  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
  let foundDuplicate = false;
  while (cursor !== 0 && (foundDuplicate === false || isMap)) {
    ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(tData, cursor);
    const tStylingValueAtCursor = tData[cursor];
    const tStyleRangeAtCursor = tData[cursor + 1];
    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
      foundDuplicate = true;
      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
    }
    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
  }
  if (foundDuplicate) {
    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
  }
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
  ngDevMode && (0, import_root_effect_scheduler.assertNotEqual)(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
  if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that
  // location so we must assume that we have a match.
  tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it
  // contains a match.
  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
    return true;
  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
    return (0, import_root_effect_scheduler.keyValueArrayIndexOf)(tStylingKeyCursor, tStylingKey) >= 0;
  }
  return false;
}
const parserState = {
  textEnd: 0,
  key: 0,
  keyEnd: 0,
  value: 0,
  valueEnd: 0
};
function getLastParsedKey(text) {
  return text.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text) {
  return text.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text) {
  resetParserState(text);
  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseClassNameNext(text, index) {
  const end = parserState.textEnd;
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
  return consumeWhitespace(text, index, end);
}
function parseStyle(text) {
  resetParserState(text);
  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseStyleNext(text, startIndex) {
  const end = parserState.textEnd;
  let index = parserState.key = consumeWhitespace(text, startIndex, end);
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeStyleKey(text, index, end);
  index = consumeSeparator(
    text,
    index,
    end,
    58
    /* CharCode.COLON */
  );
  index = parserState.value = consumeWhitespace(text, index, end);
  index = parserState.valueEnd = consumeStyleValue(text, index, end);
  return consumeSeparator(
    text,
    index,
    end,
    59
    /* CharCode.SEMI_COLON */
  );
}
function resetParserState(text) {
  parserState.key = 0;
  parserState.keyEnd = 0;
  parserState.value = 0;
  parserState.valueEnd = 0;
  parserState.textEnd = text.length;
}
function consumeWhitespace(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeClassToken(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeStyleKey(text, startIndex, endIndex) {
  let ch;
  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
    startIndex++;
  }
  return startIndex;
}
function consumeSeparator(text, startIndex, endIndex, separator) {
  startIndex = consumeWhitespace(text, startIndex, endIndex);
  if (startIndex < endIndex) {
    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
      malformedStyleError(text, String.fromCharCode(separator), startIndex);
    }
    startIndex++;
  }
  return startIndex;
}
function consumeStyleValue(text, startIndex, endIndex) {
  let ch1 = -1;
  let ch2 = -1;
  let ch3 = -1;
  let i = startIndex;
  let lastChIndex = i;
  while (i < endIndex) {
    const ch = text.charCodeAt(i++);
    if (ch === 59) {
      return lastChIndex;
    } else if (ch === 34 || ch === 39) {
      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
    } else if (startIndex === i - 4 && // We have seen only 4 characters so far "URL(" (Ignore "foo_URL()")
    ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
      lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
    } else if (ch > 32) {
      lastChIndex = i;
    }
    ch3 = ch2;
    ch2 = ch1;
    ch1 = ch & -33;
  }
  return lastChIndex;
}
function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
  let ch1 = -1;
  let index = startIndex;
  while (index < endIndex) {
    const ch = text.charCodeAt(index++);
    if (ch == quoteCharCode && ch1 !== 92) {
      return index;
    }
    if (ch == 92 && ch1 === 92) {
      ch1 = 0;
    } else {
      ch1 = ch;
    }
  }
  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text, expecting, index) {
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(typeof text === "string", true, "String expected here");
  throw (0, import_root_effect_scheduler.throwError)(`Malformed style at location ${index} in string '` + text.substring(0, index) + "[>>" + text.substring(index, index + 1) + "<<]" + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
}
function \u0275\u0275styleProp(prop, value, suffix) {
  checkStylingProperty(prop, value, suffix, false);
  return \u0275\u0275styleProp;
}
function \u0275\u0275classProp(className, value) {
  checkStylingProperty(className, value, null, true);
  return \u0275\u0275classProp;
}
function \u0275\u0275styleMap(styles) {
  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
}
function styleStringParser(keyValueArray, text) {
  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
  }
}
function \u0275\u0275classMap(classes) {
  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text) {
  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
    (0, import_root_effect_scheduler.keyValueArraySet)(keyValueArray, getLastParsedKey(text), true);
  }
}
function checkStylingProperty(prop, value, suffix, isClassBased) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const bindingIndex = (0, import_root_effect_scheduler.incrementBindingIndex)(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
  }
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[(0, import_root_effect_scheduler.getSelectedIndex)()];
    updateStyling(tView, tNode, lView, lView[import_root_effect_scheduler.RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
  }
}
function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
  const tView = (0, import_root_effect_scheduler.getTView)();
  const bindingIndex = (0, import_root_effect_scheduler.incrementBindingIndex)(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
  }
  const lView = (0, import_root_effect_scheduler.getLView)();
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[(0, import_root_effect_scheduler.getSelectedIndex)()];
    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
      if (ngDevMode) {
        const tStylingKey = tView.data[bindingIndex];
        (0, import_root_effect_scheduler.assertEqual)(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
      }
      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
      ngDevMode && isClassBased === false && staticPrefix !== null && (0, import_root_effect_scheduler.assertEqual)(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
      if (staticPrefix !== null) {
        value = (0, import_root_effect_scheduler.concatStringsWithSpace)(staticPrefix, value ? value : "");
      }
      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
    } else {
      updateStylingMap(tView, tNode, lView, lView[import_root_effect_scheduler.RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
    }
  }
}
function isInHostBindings(tView, bindingIndex) {
  return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
  ngDevMode && (0, import_root_effect_scheduler.assertFirstUpdatePass)(tView);
  const tData = tView.data;
  if (tData[bindingIndex + 1] === null) {
    const tNode = tData[(0, import_root_effect_scheduler.getSelectedIndex)()];
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(tNode, "TNode expected");
    const isHostBindings = isInHostBindings(tView, bindingIndex);
    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
      tStylingKey = false;
    }
    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
  }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
  const hostDirectiveDef = (0, import_root_effect_scheduler.getCurrentDirectiveDef)(tData);
  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
  if (hostDirectiveDef === null) {
    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
    if (isFirstStylingInstructionInTemplate) {
      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
      residual = null;
    }
  } else {
    const directiveStylingLast = tNode.directiveStylingLast;
    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
    if (isFirstStylingInstructionInHostBinding) {
      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
      if (residual === null) {
        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
        if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
        }
      } else {
        residual = collectResidual(tData, tNode, isClassBased);
      }
    }
  }
  if (residual !== void 0) {
    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
  }
  return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  if (getTStylingRangeNext(bindings) === 0) {
    return void 0;
  }
  return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  ngDevMode && (0, import_root_effect_scheduler.assertNotEqual)(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
  tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
  let residual = void 0;
  const directiveEnd = tNode.directiveEnd;
  ngDevMode && (0, import_root_effect_scheduler.assertNotEqual)(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
    const attrs = tData[i].hostAttrs;
    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
  }
  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
  let currentDirective = null;
  const directiveEnd = tNode.directiveEnd;
  let directiveStylingLast = tNode.directiveStylingLast;
  if (directiveStylingLast === -1) {
    directiveStylingLast = tNode.directiveStart;
  } else {
    directiveStylingLast++;
  }
  while (directiveStylingLast < directiveEnd) {
    currentDirective = tData[directiveStylingLast];
    ngDevMode && (0, import_root_effect_scheduler.assertDefined)(currentDirective, "expected to be defined");
    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
    if (currentDirective === hostDirectiveDef)
      break;
    directiveStylingLast++;
  }
  if (hostDirectiveDef !== null) {
    tNode.directiveStylingLast = directiveStylingLast;
  }
  return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
  const desiredMarker = isClassBased ? 1 : 2;
  let currentMarker = -1;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const item = attrs[i];
      if (typeof item === "number") {
        currentMarker = item;
      } else {
        if (currentMarker === desiredMarker) {
          if (!Array.isArray(stylingKey)) {
            stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
          }
          (0, import_root_effect_scheduler.keyValueArraySet)(stylingKey, item, isClassBased ? true : attrs[++i]);
        }
      }
    }
  }
  return stylingKey === void 0 ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
  if (value == null || value === "")
    return import_root_effect_scheduler.EMPTY_ARRAY;
  const styleKeyValueArray = [];
  const unwrappedValue = unwrapSafeValue(value);
  if (Array.isArray(unwrappedValue)) {
    for (let i = 0; i < unwrappedValue.length; i++) {
      keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
    }
  } else if (typeof unwrappedValue === "object") {
    for (const key in unwrappedValue) {
      if (unwrappedValue.hasOwnProperty(key)) {
        keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
      }
    }
  } else if (typeof unwrappedValue === "string") {
    stringParser(styleKeyValueArray, unwrappedValue);
  } else {
    ngDevMode && (0, import_root_effect_scheduler.throwError)("Unsupported styling type: " + typeof unwrappedValue + " (" + unwrappedValue + ")");
  }
  return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value) {
  (0, import_root_effect_scheduler.keyValueArraySet)(keyValueArray, key, unwrapSafeValue(value));
}
function classKeyValueArraySet(keyValueArray, key, value) {
  const stringKey = String(key);
  if (stringKey !== "" && !stringKey.includes(" ")) {
    (0, import_root_effect_scheduler.keyValueArraySet)(keyValueArray, stringKey, value);
  }
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
  if (oldKeyValueArray === NO_CHANGE) {
    oldKeyValueArray = import_root_effect_scheduler.EMPTY_ARRAY;
  }
  let oldIndex = 0;
  let newIndex = 0;
  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
  while (oldKey !== null || newKey !== null) {
    ngDevMode && (0, import_root_effect_scheduler.assertLessThan)(oldIndex, 999, "Are we stuck in infinite loop?");
    ngDevMode && (0, import_root_effect_scheduler.assertLessThan)(newIndex, 999, "Are we stuck in infinite loop?");
    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
    let setKey = null;
    let setValue = void 0;
    if (oldKey === newKey) {
      oldIndex += 2;
      newIndex += 2;
      if (oldValue !== newValue) {
        setKey = newKey;
        setValue = newValue;
      }
    } else if (newKey === null || oldKey !== null && oldKey < newKey) {
      oldIndex += 2;
      setKey = oldKey;
    } else {
      ngDevMode && (0, import_root_effect_scheduler.assertDefined)(newKey, "Expecting to have a valid key");
      newIndex += 2;
      setKey = newKey;
      setValue = newValue;
    }
    if (setKey !== null) {
      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
    }
    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
  }
}
function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
  if (!(tNode.type & 3)) {
    return;
  }
  const tData = tView.data;
  const tRange = tData[bindingIndex + 1];
  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
  if (!isStylingValuePresent(higherPriorityValue)) {
    if (!isStylingValuePresent(value)) {
      if (getTStylingRangePrevDuplicate(tRange)) {
        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
      }
    }
    const rNode = (0, import_root_effect_scheduler.getNativeByIndex)((0, import_root_effect_scheduler.getSelectedIndex)(), lView);
    applyStyling(renderer, isClassBased, rNode, prop, value);
  }
}
function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
  const isPrevDirection = tNode === null;
  let value = void 0;
  while (index > 0) {
    const rawKey = tData[index];
    const containsStatics = Array.isArray(rawKey);
    const key = containsStatics ? rawKey[1] : rawKey;
    const isStylingMap = key === null;
    let valueAtLViewIndex = lView[index + 1];
    if (valueAtLViewIndex === NO_CHANGE) {
      valueAtLViewIndex = isStylingMap ? import_root_effect_scheduler.EMPTY_ARRAY : void 0;
    }
    let currentValue = isStylingMap ? (0, import_root_effect_scheduler.keyValueArrayGet)(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
    if (containsStatics && !isStylingValuePresent(currentValue)) {
      currentValue = (0, import_root_effect_scheduler.keyValueArrayGet)(rawKey, prop);
    }
    if (isStylingValuePresent(currentValue)) {
      value = currentValue;
      if (isPrevDirection) {
        return value;
      }
    }
    const tRange = tData[index + 1];
    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
  }
  if (tNode !== null) {
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null) {
      value = (0, import_root_effect_scheduler.keyValueArrayGet)(residual, prop);
    }
  }
  return value;
}
function isStylingValuePresent(value) {
  return value !== void 0;
}
function normalizeSuffix(value, suffix) {
  if (value == null || value === "") ;
  else if (typeof suffix === "string") {
    value = value + suffix;
  } else if (typeof value === "object") {
    value = (0, import_root_effect_scheduler.stringify)(unwrapSafeValue(value));
  }
  return value;
}
function hasStylingInputShadow(tNode, isClassBased) {
  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
}
function \u0275\u0275text(index, value = "") {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  ngDevMode && (0, import_root_effect_scheduler.assertTNodeCreationIndex)(lView, index);
  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);
  lView[adjustedIndex] = textNative;
  if ((0, import_root_effect_scheduler.wasLastNodeCreated)()) {
    appendChild(tView, lView, textNative, tNode);
  }
  (0, import_root_effect_scheduler.setCurrentTNode)(tNode, false);
}
let _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {
  (0, import_root_effect_scheduler.lastNodeWasCreated)(true);
  return createTextNode(lView[import_root_effect_scheduler.RENDERER], value);
};
function locateOrCreateTextNodeImpl(tView, lView, tNode, value, index) {
  const isNodeCreationMode = !canHydrateNode(lView, tNode);
  (0, import_root_effect_scheduler.lastNodeWasCreated)(isNodeCreationMode);
  if (isNodeCreationMode) {
    return createTextNode(lView[import_root_effect_scheduler.RENDERER], value);
  }
  const hydrationInfo = lView[import_root_effect_scheduler.HYDRATION];
  const textNative = locateNextRNode(hydrationInfo, tView, lView, tNode);
  ngDevMode && validateMatchingNode(textNative, Node.TEXT_NODE, null, lView, tNode);
  ngDevMode && markRNodeAsClaimedByHydration(textNative);
  return textNative;
}
function enableLocateOrCreateTextNodeImpl() {
  _locateOrCreateTextNode = locateOrCreateTextNodeImpl;
}
function interpolationV(lView, values) {
  ngDevMode && (0, import_root_effect_scheduler.assertLessThan)(2, values.length, "should have at least 3 values");
  let isBindingUpdated = false;
  let bindingIndex = (0, import_root_effect_scheduler.getBindingIndex)();
  for (let i = 1; i < values.length; i += 2) {
    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
  }
  (0, import_root_effect_scheduler.setBindingIndex)(bindingIndex);
  if (!isBindingUpdated) {
    return NO_CHANGE;
  }
  let content = values[0];
  for (let i = 1; i < values.length; i += 2) {
    content += (0, import_root_effect_scheduler.renderStringify)(values[i]) + (i + 1 !== values.length ? values[i + 1] : "");
  }
  return content;
}
function interpolation1(lView, prefix, v0, suffix = "") {
  const different = bindingUpdated(lView, (0, import_root_effect_scheduler.nextBindingIndex)(), v0);
  return different ? prefix + (0, import_root_effect_scheduler.renderStringify)(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix = "") {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingIndex)();
  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
  (0, import_root_effect_scheduler.incrementBindingIndex)(2);
  return different ? prefix + (0, import_root_effect_scheduler.renderStringify)(v0) + i0 + (0, import_root_effect_scheduler.renderStringify)(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix = "") {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingIndex)();
  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
  (0, import_root_effect_scheduler.incrementBindingIndex)(3);
  return different ? prefix + (0, import_root_effect_scheduler.renderStringify)(v0) + i0 + (0, import_root_effect_scheduler.renderStringify)(v1) + i1 + (0, import_root_effect_scheduler.renderStringify)(v2) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix = "") {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingIndex)();
  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  (0, import_root_effect_scheduler.incrementBindingIndex)(4);
  return different ? prefix + (0, import_root_effect_scheduler.renderStringify)(v0) + i0 + (0, import_root_effect_scheduler.renderStringify)(v1) + i1 + (0, import_root_effect_scheduler.renderStringify)(v2) + i2 + (0, import_root_effect_scheduler.renderStringify)(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix = "") {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
  (0, import_root_effect_scheduler.incrementBindingIndex)(5);
  return different ? prefix + (0, import_root_effect_scheduler.renderStringify)(v0) + i0 + (0, import_root_effect_scheduler.renderStringify)(v1) + i1 + (0, import_root_effect_scheduler.renderStringify)(v2) + i2 + (0, import_root_effect_scheduler.renderStringify)(v3) + i3 + (0, import_root_effect_scheduler.renderStringify)(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix = "") {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
  (0, import_root_effect_scheduler.incrementBindingIndex)(6);
  return different ? prefix + (0, import_root_effect_scheduler.renderStringify)(v0) + i0 + (0, import_root_effect_scheduler.renderStringify)(v1) + i1 + (0, import_root_effect_scheduler.renderStringify)(v2) + i2 + (0, import_root_effect_scheduler.renderStringify)(v3) + i3 + (0, import_root_effect_scheduler.renderStringify)(v4) + i4 + (0, import_root_effect_scheduler.renderStringify)(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix = "") {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
  (0, import_root_effect_scheduler.incrementBindingIndex)(7);
  return different ? prefix + (0, import_root_effect_scheduler.renderStringify)(v0) + i0 + (0, import_root_effect_scheduler.renderStringify)(v1) + i1 + (0, import_root_effect_scheduler.renderStringify)(v2) + i2 + (0, import_root_effect_scheduler.renderStringify)(v3) + i3 + (0, import_root_effect_scheduler.renderStringify)(v4) + i4 + (0, import_root_effect_scheduler.renderStringify)(v5) + i5 + (0, import_root_effect_scheduler.renderStringify)(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix = "") {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingIndex)();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
  (0, import_root_effect_scheduler.incrementBindingIndex)(8);
  return different ? prefix + (0, import_root_effect_scheduler.renderStringify)(v0) + i0 + (0, import_root_effect_scheduler.renderStringify)(v1) + i1 + (0, import_root_effect_scheduler.renderStringify)(v2) + i2 + (0, import_root_effect_scheduler.renderStringify)(v3) + i3 + (0, import_root_effect_scheduler.renderStringify)(v4) + i4 + (0, import_root_effect_scheduler.renderStringify)(v5) + i5 + (0, import_root_effect_scheduler.renderStringify)(v6) + i6 + (0, import_root_effect_scheduler.renderStringify)(v7) + suffix : NO_CHANGE;
}
function \u0275\u0275textInterpolate(v0) {
  \u0275\u0275textInterpolate1("", v0);
  return \u0275\u0275textInterpolate;
}
function \u0275\u0275textInterpolate1(prefix, v0, suffix) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const interpolated = interpolation1(lView, prefix, v0, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0, import_root_effect_scheduler.getSelectedIndex)(), interpolated);
  }
  return \u0275\u0275textInterpolate1;
}
function \u0275\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0, import_root_effect_scheduler.getSelectedIndex)(), interpolated);
  }
  return \u0275\u0275textInterpolate2;
}
function \u0275\u0275textInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0, import_root_effect_scheduler.getSelectedIndex)(), interpolated);
  }
  return \u0275\u0275textInterpolate3;
}
function \u0275\u0275textInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0, import_root_effect_scheduler.getSelectedIndex)(), interpolated);
  }
  return \u0275\u0275textInterpolate4;
}
function \u0275\u0275textInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0, import_root_effect_scheduler.getSelectedIndex)(), interpolated);
  }
  return \u0275\u0275textInterpolate5;
}
function \u0275\u0275textInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0, import_root_effect_scheduler.getSelectedIndex)(), interpolated);
  }
  return \u0275\u0275textInterpolate6;
}
function \u0275\u0275textInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0, import_root_effect_scheduler.getSelectedIndex)(), interpolated);
  }
  return \u0275\u0275textInterpolate7;
}
function \u0275\u0275textInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0, import_root_effect_scheduler.getSelectedIndex)(), interpolated);
  }
  return \u0275\u0275textInterpolate8;
}
function \u0275\u0275textInterpolateV(values) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, (0, import_root_effect_scheduler.getSelectedIndex)(), interpolated);
  }
  return \u0275\u0275textInterpolateV;
}
function textBindingInternal(lView, index, value) {
  ngDevMode && (0, import_root_effect_scheduler.assertString)(value, "Value should be a string");
  ngDevMode && (0, import_root_effect_scheduler.assertNotSame)(value, NO_CHANGE, "value should not be NO_CHANGE");
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, index);
  const element = (0, import_root_effect_scheduler.getNativeByIndex)(index, lView);
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(element, "native element should exist");
  updateTextNode(lView[import_root_effect_scheduler.RENDERER], element, value);
}
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
function \u0275\u0275twoWayProperty(propName, value, sanitizer) {
  if ((0, import_root_effect_scheduler.isWritableSignal)(value)) {
    value = value();
  }
  const lView = (0, import_root_effect_scheduler.getLView)();
  const bindingIndex = (0, import_root_effect_scheduler.nextBindingIndex)();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = (0, import_root_effect_scheduler.getTView)();
    const tNode = (0, import_root_effect_scheduler.getSelectedTNode)();
    setPropertyAndInputs(tNode, lView, propName, value, lView[import_root_effect_scheduler.RENDERER], sanitizer);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275twoWayProperty;
}
function \u0275\u0275twoWayBindingSet(target, value) {
  const canWrite = (0, import_root_effect_scheduler.isWritableSignal)(target);
  canWrite && target.set(value);
  return canWrite;
}
function \u0275\u0275twoWayListener(eventName, listenerFn) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const tView = (0, import_root_effect_scheduler.getTView)();
  const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
  listenerInternal(tView, lView, lView[import_root_effect_scheduler.RENDERER], tNode, eventName, listenerFn);
  return \u0275\u0275twoWayListener;
}
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
const UNINITIALIZED_LET = {};
function \u0275\u0275declareLet(index) {
  const tView = (0, import_root_effect_scheduler.getTView)();
  const lView = (0, import_root_effect_scheduler.getLView)();
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const tNode = getOrCreateTNode(tView, adjustedIndex, 128, null, null);
  (0, import_root_effect_scheduler.setCurrentTNode)(tNode, false);
  (0, import_root_effect_scheduler.store)(tView, lView, adjustedIndex, UNINITIALIZED_LET);
  return \u0275\u0275declareLet;
}
function \u0275\u0275storeLet(value) {
  performanceMarkFeature("NgLet");
  const tView = (0, import_root_effect_scheduler.getTView)();
  const lView = (0, import_root_effect_scheduler.getLView)();
  const index = (0, import_root_effect_scheduler.getSelectedIndex)();
  (0, import_root_effect_scheduler.store)(tView, lView, index, value);
  return value;
}
function \u0275\u0275readContextLet(index) {
  const contextLView = (0, import_root_effect_scheduler.getContextLView)();
  const value = (0, import_root_effect_scheduler.load)(contextLView, import_root_effect_scheduler.HEADER_OFFSET + index);
  if (value === UNINITIALIZED_LET) {
    throw new import_root_effect_scheduler.RuntimeError(314, ngDevMode && "Attempting to access a @let declaration whose value is not available yet");
  }
  return value;
}
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
function \u0275\u0275attachSourceLocations(templatePath, locations) {
  const tView = (0, import_root_effect_scheduler.getTView)();
  const lView = (0, import_root_effect_scheduler.getLView)();
  const renderer = lView[import_root_effect_scheduler.RENDERER];
  const attributeName2 = "data-ng-source-location";
  for (const [index, offset, line, column] of locations) {
    const tNode = (0, import_root_effect_scheduler.getTNode)(tView, index + import_root_effect_scheduler.HEADER_OFFSET);
    ngDevMode && assertTNodeType(
      tNode,
      2
      /* TNodeType.Element */
    );
    const node = (0, import_root_effect_scheduler.getNativeByIndex)(index + import_root_effect_scheduler.HEADER_OFFSET, lView);
    if (!node.hasAttribute(attributeName2)) {
      const attributeValue = `${templatePath}@o:${offset},l:${line},c:${column}`;
      renderer.setAttribute(node, attributeName2, attributeValue);
    }
  }
}
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
function \u0275\u0275interpolate(v0) {
  return bindingUpdated((0, import_root_effect_scheduler.getLView)(), (0, import_root_effect_scheduler.nextBindingIndex)(), v0) ? (0, import_root_effect_scheduler.renderStringify)(v0) : NO_CHANGE;
}
function \u0275\u0275interpolate1(prefix, v0, suffix = "") {
  return interpolation1((0, import_root_effect_scheduler.getLView)(), prefix, v0, suffix);
}
function \u0275\u0275interpolate2(prefix, v0, i0, v1, suffix = "") {
  return interpolation2((0, import_root_effect_scheduler.getLView)(), prefix, v0, i0, v1, suffix);
}
function \u0275\u0275interpolate3(prefix, v0, i0, v1, i1, v2, suffix = "") {
  return interpolation3((0, import_root_effect_scheduler.getLView)(), prefix, v0, i0, v1, i1, v2, suffix);
}
function \u0275\u0275interpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix = "") {
  return interpolation4((0, import_root_effect_scheduler.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
}
function \u0275\u0275interpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix = "") {
  return interpolation5((0, import_root_effect_scheduler.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
}
function \u0275\u0275interpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix = "") {
  return interpolation6((0, import_root_effect_scheduler.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
}
function \u0275\u0275interpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix = "") {
  return interpolation7((0, import_root_effect_scheduler.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
}
function \u0275\u0275interpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix = "") {
  return interpolation8((0, import_root_effect_scheduler.getLView)(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
}
function \u0275\u0275interpolateV(values) {
  return interpolationV((0, import_root_effect_scheduler.getLView)(), values);
}
function providersResolver(def, providers, viewProviders) {
  const tView = (0, import_root_effect_scheduler.getTView)();
  if (tView.firstCreatePass) {
    const isComponent2 = (0, import_root_effect_scheduler.isComponentDef)(def);
    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent2, true);
    resolveProvider(providers, tView.data, tView.blueprint, isComponent2, false);
  }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider) {
  provider = (0, import_root_effect_scheduler.resolveForwardRef)(provider);
  if (Array.isArray(provider)) {
    for (let i = 0; i < provider.length; i++) {
      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider);
    }
  } else {
    const tView = (0, import_root_effect_scheduler.getTView)();
    const lView = (0, import_root_effect_scheduler.getLView)();
    const tNode = (0, import_root_effect_scheduler.getCurrentTNode)();
    let token = (0, import_root_effect_scheduler.isTypeProvider)(provider) ? provider : (0, import_root_effect_scheduler.resolveForwardRef)(provider.provide);
    const providerFactory = (0, import_root_effect_scheduler.providerToFactory)(provider);
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      (0, import_root_effect_scheduler.runInInjectorProfilerContext)(injector, token, () => {
        (0, import_root_effect_scheduler.emitProviderConfiguredEvent)(provider, isViewProvider);
      });
    }
    const beginIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveStart;
    const cptViewProvidersCount = tNode.providerIndexes >> 20;
    if ((0, import_root_effect_scheduler.isTypeProvider)(provider) || !provider.multi) {
      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject, ngDevMode ? providerName(provider) : null);
      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
      if (existingFactoryIndex === -1) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        lInjectablesBlueprint[existingFactoryIndex] = factory;
        lView[existingFactoryIndex] = factory;
      }
    } else {
      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent2, providerFactory, provider);
        if (!isViewProvider && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
        }
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent2);
        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
      }
      if (!isViewProvider && isComponent2 && doesViewProvidersFactoryExist) {
        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
      }
    }
  }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
  const providerIsTypeProvider = (0, import_root_effect_scheduler.isTypeProvider)(provider);
  const providerIsClassProvider = (0, import_root_effect_scheduler.isClassProvider)(provider);
  if (providerIsTypeProvider || providerIsClassProvider) {
    const classToken = providerIsClassProvider ? (0, import_root_effect_scheduler.resolveForwardRef)(provider.useClass) : provider;
    const prototype = classToken.prototype;
    const ngOnDestroy = prototype.ngOnDestroy;
    if (ngOnDestroy) {
      const hooks = tView.destroyHooks || (tView.destroyHooks = []);
      if (!providerIsTypeProvider && provider.multi) {
        ngDevMode && (0, import_root_effect_scheduler.assertDefined)(indexInFactory, "indexInFactory when registering multi factory destroy hook");
        const existingCallbacksIndex = hooks.indexOf(contextIndex);
        if (existingCallbacksIndex === -1) {
          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
        } else {
          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
        }
      } else {
        hooks.push(contextIndex, ngOnDestroy);
      }
    }
  }
}
function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
  if (isComponentProvider) {
    multiFactory2.componentProviders++;
  }
  return multiFactory2.multi.push(factory) - 1;
}
function indexOf(item, arr, begin, end) {
  for (let i = begin; i < end; i++) {
    if (arr[i] === item)
      return i;
  }
  return -1;
}
function multiProvidersFactoryResolver(_, flags, tData, lData, tNode) {
  return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_, _flags, _tData, lView, tNode) {
  const factories = this.multi;
  let result;
  if (this.providerFactory) {
    const componentCount = this.providerFactory.componentProviders;
    const multiProviders = getNodeInjectable(lView, lView[import_root_effect_scheduler.TVIEW], this.providerFactory.index, tNode);
    result = multiProviders.slice(0, componentCount);
    multiResolve(factories, result);
    for (let i = componentCount; i < multiProviders.length; i++) {
      result.push(multiProviders[i]);
    }
  } else {
    result = [];
    multiResolve(factories, result);
  }
  return result;
}
function multiResolve(factories, result) {
  for (let i = 0; i < factories.length; i++) {
    const factory = factories[i];
    result.push(factory());
  }
  return result;
}
function multiFactory(factoryFn, index, isViewProvider, isComponent2, f, provider) {
  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject, ngDevMode ? providerName(provider) : null);
  factory.multi = [];
  factory.index = index;
  factory.componentProviders = 0;
  multiFactoryAdd(factory, f, isComponent2 && !isViewProvider);
  return factory;
}
function providerName(provider) {
  if (Array.isArray(provider)) {
    return null;
  }
  if ((0, import_root_effect_scheduler.isTypeProvider)(provider)) {
    return provider.name;
  } else if ((0, import_root_effect_scheduler.isClassProvider)(provider)) {
    if (provider.provide instanceof import_root_effect_scheduler.InjectionToken) {
      return `('${provider.provide.toString()}':${provider.useClass.name})`;
    }
    return provider.useClass.name;
  } else if (provider.provide instanceof import_root_effect_scheduler.InjectionToken) {
    return provider.provide.toString();
  } else if (typeof provider.provide === "string") {
    return provider.provide;
  } else {
    return null;
  }
}
function \u0275\u0275ProvidersFeature(providers, viewProviders = []) {
  return (definition) => {
    definition.providersResolver = (def, processProvidersFn) => {
      return providersResolver(
        def,
        //
        processProvidersFn ? processProvidersFn(providers) : providers,
        //
        viewProviders
      );
    };
  };
}
function \u0275\u0275ExternalStylesFeature(styleUrls) {
  return (definition) => {
    if (styleUrls.length < 1) {
      return;
    }
    definition.getExternalStyles = (encapsulationId) => {
      const urls = styleUrls.map((value) => value + "?ngcomp" + (encapsulationId ? "=" + encodeURIComponent(encapsulationId) : "") + "&e=" + definition.encapsulation);
      return urls;
    };
  };
}
function \u0275\u0275setComponentScope(type, directives, pipes) {
  const def = type.\u0275cmp;
  def.directiveDefs = extractDefListOrFactory(directives, extractDirectiveDef);
  def.pipeDefs = extractDefListOrFactory(pipes, import_root_effect_scheduler.getPipeDef);
}
function \u0275\u0275setNgModuleScope(type, scope) {
  return noSideEffects(() => {
    const ngModuleDef = (0, import_root_effect_scheduler.getNgModuleDefOrThrow)(type);
    ngModuleDef.declarations = convertToTypeArray(scope.declarations || import_root_effect_scheduler.EMPTY_ARRAY);
    ngModuleDef.imports = convertToTypeArray(scope.imports || import_root_effect_scheduler.EMPTY_ARRAY);
    ngModuleDef.exports = convertToTypeArray(scope.exports || import_root_effect_scheduler.EMPTY_ARRAY);
    if (scope.bootstrap) {
      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);
    }
    depsTracker.registerNgModule(type, scope);
  });
}
function convertToTypeArray(values) {
  if (typeof values === "function") {
    return values;
  }
  const flattenValues = (0, import_root_effect_scheduler.flatten)(values);
  if (flattenValues.some(import_root_effect_scheduler.isForwardRef)) {
    return () => flattenValues.map(import_root_effect_scheduler.resolveForwardRef).map(maybeUnwrapModuleWithProviders);
  } else {
    return flattenValues.map(maybeUnwrapModuleWithProviders);
  }
}
function maybeUnwrapModuleWithProviders(value) {
  return isModuleWithProviders(value) ? value.ngModule : value;
}
function \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingRoot)() + slotOffset;
  const lView = (0, import_root_effect_scheduler.getLView)();
  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
}
function \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {
  return pureFunction1Internal((0, import_root_effect_scheduler.getLView)(), (0, import_root_effect_scheduler.getBindingRoot)(), slotOffset, pureFn, exp, thisArg);
}
function \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
  return pureFunction2Internal((0, import_root_effect_scheduler.getLView)(), (0, import_root_effect_scheduler.getBindingRoot)(), slotOffset, pureFn, exp1, exp2, thisArg);
}
function \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  return pureFunction3Internal((0, import_root_effect_scheduler.getLView)(), (0, import_root_effect_scheduler.getBindingRoot)(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
}
function \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  return pureFunction4Internal((0, import_root_effect_scheduler.getLView)(), (0, import_root_effect_scheduler.getBindingRoot)(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
}
function \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingRoot)() + slotOffset;
  const lView = (0, import_root_effect_scheduler.getLView)();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function \u0275\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingRoot)() + slotOffset;
  const lView = (0, import_root_effect_scheduler.getLView)();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function \u0275\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingRoot)() + slotOffset;
  const lView = (0, import_root_effect_scheduler.getLView)();
  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function \u0275\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
  const bindingIndex = (0, import_root_effect_scheduler.getBindingRoot)() + slotOffset;
  const lView = (0, import_root_effect_scheduler.getLView)();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {
  return pureFunctionVInternal((0, import_root_effect_scheduler.getLView)(), (0, import_root_effect_scheduler.getBindingRoot)(), slotOffset, pureFn, exps, thisArg);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
  ngDevMode && (0, import_root_effect_scheduler.assertIndexInRange)(lView, returnValueIndex);
  const lastReturnValue = lView[returnValueIndex];
  return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
  let bindingIndex = bindingRoot + slotOffset;
  let different = false;
  for (let i = 0; i < exps.length; i++) {
    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
  }
  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function \u0275\u0275pipe(index, pipeName) {
  var _a2;
  const tView = (0, import_root_effect_scheduler.getTView)();
  let pipeDef;
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  if (tView.firstCreatePass) {
    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
    tView.data[adjustedIndex] = pipeDef;
    if (pipeDef.onDestroy) {
      ((_a2 = tView.destroyHooks) != null ? _a2 : tView.destroyHooks = []).push(adjustedIndex, pipeDef.onDestroy);
    }
  } else {
    pipeDef = tView.data[adjustedIndex];
  }
  const pipeFactory = pipeDef.factory || (pipeDef.factory = (0, import_root_effect_scheduler.getFactoryDef)(pipeDef.type, true));
  let previousInjectorProfilerContext;
  if (ngDevMode) {
    previousInjectorProfilerContext = (0, import_root_effect_scheduler.setInjectorProfilerContext)({
      injector: new NodeInjector((0, import_root_effect_scheduler.getCurrentTNode)(), (0, import_root_effect_scheduler.getLView)()),
      token: pipeDef.type
    });
  }
  const previousInjectImplementation = (0, import_root_effect_scheduler.setInjectImplementation)(\u0275\u0275directiveInject);
  try {
    const previousIncludeViewProviders = setIncludeViewProviders(false);
    const pipeInstance = pipeFactory();
    setIncludeViewProviders(previousIncludeViewProviders);
    (0, import_root_effect_scheduler.store)(tView, (0, import_root_effect_scheduler.getLView)(), adjustedIndex, pipeInstance);
    return pipeInstance;
  } finally {
    (0, import_root_effect_scheduler.setInjectImplementation)(previousInjectImplementation);
    ngDevMode && (0, import_root_effect_scheduler.setInjectorProfilerContext)(previousInjectorProfilerContext);
  }
}
function getPipeDef(name, registry) {
  if (registry) {
    if (ngDevMode) {
      const pipes = registry.filter((pipe) => pipe.name === name);
      if (pipes.length > 1) {
        console.warn((0, import_root_effect_scheduler.formatRuntimeError)(313, getMultipleMatchingPipesMessage(name)));
      }
    }
    for (let i = registry.length - 1; i >= 0; i--) {
      const pipeDef = registry[i];
      if (name === pipeDef.name) {
        return pipeDef;
      }
    }
  }
  if (ngDevMode) {
    throw new import_root_effect_scheduler.RuntimeError(-302, getPipeNotFoundErrorMessage(name));
  }
  return;
}
function getMultipleMatchingPipesMessage(name) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const declarationLView = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[import_root_effect_scheduler.CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : "";
  const verifyMessage = `check ${hostIsStandalone ? "'@Component.imports' of this component" : "the imports of this module"}`;
  const errorMessage = `Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function getPipeNotFoundErrorMessage(name) {
  const lView = (0, import_root_effect_scheduler.getLView)();
  const declarationLView = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW];
  const context = declarationLView[import_root_effect_scheduler.CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : "";
  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : "declared or imported in this module"}`;
  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function \u0275\u0275pipeBind1(index, offset, v1) {
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const lView = (0, import_root_effect_scheduler.getLView)();
  const pipeInstance = (0, import_root_effect_scheduler.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, (0, import_root_effect_scheduler.getBindingRoot)(), offset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function \u0275\u0275pipeBind2(index, slotOffset, v1, v2) {
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const lView = (0, import_root_effect_scheduler.getLView)();
  const pipeInstance = (0, import_root_effect_scheduler.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, (0, import_root_effect_scheduler.getBindingRoot)(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
}
function \u0275\u0275pipeBind3(index, slotOffset, v1, v2, v3) {
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const lView = (0, import_root_effect_scheduler.getLView)();
  const pipeInstance = (0, import_root_effect_scheduler.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, (0, import_root_effect_scheduler.getBindingRoot)(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
}
function \u0275\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const lView = (0, import_root_effect_scheduler.getLView)();
  const pipeInstance = (0, import_root_effect_scheduler.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, (0, import_root_effect_scheduler.getBindingRoot)(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
}
function \u0275\u0275pipeBindV(index, slotOffset, values) {
  const adjustedIndex = index + import_root_effect_scheduler.HEADER_OFFSET;
  const lView = (0, import_root_effect_scheduler.getLView)();
  const pipeInstance = (0, import_root_effect_scheduler.load)(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, (0, import_root_effect_scheduler.getBindingRoot)(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
}
function isPure(lView, index) {
  return lView[import_root_effect_scheduler.TVIEW].data[index].pure;
}
function \u0275\u0275templateRefExtractor(tNode, lView) {
  return createTemplateRef(tNode, lView);
}
function \u0275\u0275getComponentDepsFactory(type, rawImports) {
  return () => {
    try {
      return depsTracker.getComponentDependencies(type, rawImports).dependencies;
    } catch (e) {
      console.error(`Computing dependencies in local compilation mode for the component "${type.name}" failed with the exception:`, e);
      throw e;
    }
  };
}
function \u0275setClassDebugInfo(type, debugInfo) {
  const def = (0, import_root_effect_scheduler.getComponentDef)(type);
  if (def !== null) {
    def.debugInfo = debugInfo;
  }
}
/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */
function \u0275\u0275getReplaceMetadataURL(id, timestamp, base) {
  const url = `./@ng/component?c=${id}&t=${encodeURIComponent(timestamp)}`;
  return new URL(url, base).href;
}
function \u0275\u0275replaceMetadata(type, applyMetadata, namespaces, locals, importMeta = null, id = null) {
  ngDevMode && assertComponentDef(type);
  const currentDef = (0, import_root_effect_scheduler.getComponentDef)(type);
  applyMetadata.apply(null, [type, namespaces, ...locals]);
  const { newDef, oldDef } = mergeWithExistingDefinition(currentDef, (0, import_root_effect_scheduler.getComponentDef)(type));
  type[import_root_effect_scheduler.NG_COMP_DEF] = newDef;
  if (oldDef.tView) {
    const trackedViews = getTrackedLViews().values();
    for (const root of trackedViews) {
      if ((0, import_root_effect_scheduler.isRootView)(root) && root[import_root_effect_scheduler.PARENT] === null) {
        recreateMatchingLViews(importMeta, id, newDef, oldDef, root);
      }
    }
  }
}
function mergeWithExistingDefinition(currentDef, newDef) {
  const clone = __spreadValues({}, currentDef);
  const replacement = Object.assign(currentDef, newDef, {
    // We need to keep the existing directive and pipe defs, because they can get patched on
    // by a call to `setComponentScope` from a module file. That call won't make it into the
    // HMR replacement function, because it lives in an entirely different file.
    directiveDefs: clone.directiveDefs,
    pipeDefs: clone.pipeDefs,
    // Preserve the old `setInput` function, because it has some state.
    // This is fine, because the component instance is preserved as well.
    setInput: clone.setInput,
    // Externally this is redundant since we redeclare the definition using the original type.
    // Internally we may receive a definition with an alternate, but identical, type so we have
    // to ensure that the original one is preserved.
    type: clone.type
  });
  ngDevMode && (0, import_root_effect_scheduler.assertEqual)(replacement, currentDef, "Expected definition to be merged in place");
  return { newDef: replacement, oldDef: clone };
}
function recreateMatchingLViews(importMeta, id, newDef, oldDef, rootLView) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(oldDef.tView, "Expected a component definition that has been instantiated at least once");
  const tView = rootLView[import_root_effect_scheduler.TVIEW];
  if (tView === oldDef.tView) {
    ngDevMode && assertComponentDef(oldDef.type);
    recreateLView(importMeta, id, newDef, oldDef, rootLView);
    return;
  }
  for (let i = import_root_effect_scheduler.HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const current = rootLView[i];
    if ((0, import_root_effect_scheduler.isLContainer)(current)) {
      if ((0, import_root_effect_scheduler.isLView)(current[import_root_effect_scheduler.HOST])) {
        recreateMatchingLViews(importMeta, id, newDef, oldDef, current[import_root_effect_scheduler.HOST]);
      }
      for (let j = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET; j < current.length; j++) {
        recreateMatchingLViews(importMeta, id, newDef, oldDef, current[j]);
      }
    } else if ((0, import_root_effect_scheduler.isLView)(current)) {
      recreateMatchingLViews(importMeta, id, newDef, oldDef, current);
    }
  }
}
function clearRendererCache(factory, def) {
  var _a2;
  (_a2 = factory.componentReplaced) == null ? void 0 : _a2.call(factory, def.id);
}
function recreateLView(importMeta, id, newDef, oldDef, lView) {
  const instance = lView[import_root_effect_scheduler.CONTEXT];
  let host = lView[import_root_effect_scheduler.HOST];
  const parentLView = lView[import_root_effect_scheduler.PARENT];
  ngDevMode && (0, import_root_effect_scheduler.assertLView)(parentLView);
  const tNode = lView[import_root_effect_scheduler.T_HOST];
  ngDevMode && assertTNodeType(
    tNode,
    2
    /* TNodeType.Element */
  );
  ngDevMode && (0, import_root_effect_scheduler.assertNotEqual)(newDef, oldDef, "Expected different component definition");
  const zone = lView[import_root_effect_scheduler.INJECTOR$1].get(NgZone, null);
  const recreate = () => {
    if (oldDef.encapsulation === ViewEncapsulation.ShadowDom) {
      const newHost = host.cloneNode(false);
      host.replaceWith(newHost);
      host = newHost;
    }
    const newTView = getOrCreateComponentTView(newDef);
    const newLView = createLView(
      parentLView,
      newTView,
      instance,
      getInitialLViewFlagsFromDef(newDef),
      host,
      tNode,
      null,
      null,
      // The renderer will be created a bit further down once the old one is destroyed.
      null,
      null,
      null
    );
    replaceLViewInTree(parentLView, lView, newLView, tNode.index);
    destroyLView(lView[import_root_effect_scheduler.TVIEW], lView);
    const rendererFactory = lView[import_root_effect_scheduler.ENVIRONMENT].rendererFactory;
    clearRendererCache(rendererFactory, oldDef);
    newLView[import_root_effect_scheduler.RENDERER] = rendererFactory.createRenderer(host, newDef);
    removeViewFromDOM(lView[import_root_effect_scheduler.TVIEW], lView);
    resetProjectionState(tNode);
    renderView(newTView, newLView, instance);
    refreshView(newTView, newLView, newTView.template, instance);
  };
  if (zone === null) {
    executeWithInvalidateFallback(importMeta, id, recreate);
  } else {
    zone.run(() => executeWithInvalidateFallback(importMeta, id, recreate));
  }
}
function executeWithInvalidateFallback(importMeta, id, callback) {
  var _a2, _b2;
  try {
    callback();
  } catch (e) {
    const error = e;
    if (id !== null && error.message) {
      const toLog = error.message + (error.stack ? "\n" + error.stack : "");
      (_b2 = (_a2 = importMeta == null ? void 0 : importMeta.hot) == null ? void 0 : _a2.send) == null ? void 0 : _b2.call(_a2, "angular:invalidate", { id, message: toLog, error: true });
    }
    throw e;
  }
}
function replaceLViewInTree(parentLView, oldLView, newLView, index) {
  for (let i = import_root_effect_scheduler.HEADER_OFFSET; i < parentLView[import_root_effect_scheduler.TVIEW].bindingStartIndex; i++) {
    const current = parentLView[i];
    if (((0, import_root_effect_scheduler.isLView)(current) || (0, import_root_effect_scheduler.isLContainer)(current)) && current[import_root_effect_scheduler.NEXT] === oldLView) {
      current[import_root_effect_scheduler.NEXT] = newLView;
      break;
    }
  }
  if (parentLView[import_root_effect_scheduler.CHILD_HEAD] === oldLView) {
    parentLView[import_root_effect_scheduler.CHILD_HEAD] = newLView;
  }
  if (parentLView[import_root_effect_scheduler.CHILD_TAIL] === oldLView) {
    parentLView[import_root_effect_scheduler.CHILD_TAIL] = newLView;
  }
  newLView[import_root_effect_scheduler.NEXT] = oldLView[import_root_effect_scheduler.NEXT];
  oldLView[import_root_effect_scheduler.NEXT] = null;
  parentLView[index] = newLView;
}
function resetProjectionState(tNode) {
  if (tNode.projection !== null) {
    for (const current of tNode.projection) {
      if (isTNodeShape(current)) {
        current.projectionNext = null;
        current.flags &= ~2;
      }
    }
    tNode.projection = null;
  }
}
const angularCoreEnv = /* @__PURE__ */ (() => ({
  "\u0275\u0275animateEnter": \u0275\u0275animateEnter,
  "\u0275\u0275animateEnterListener": \u0275\u0275animateEnterListener,
  "\u0275\u0275animateLeave": \u0275\u0275animateLeave,
  "\u0275\u0275animateLeaveListener": \u0275\u0275animateLeaveListener,
  "\u0275\u0275attribute": \u0275\u0275attribute,
  "\u0275\u0275defineComponent": \u0275\u0275defineComponent,
  "\u0275\u0275defineDirective": \u0275\u0275defineDirective,
  "\u0275\u0275defineInjectable": import_root_effect_scheduler.\u0275\u0275defineInjectable,
  "\u0275\u0275defineInjector": import_root_effect_scheduler.\u0275\u0275defineInjector,
  "\u0275\u0275defineNgModule": \u0275\u0275defineNgModule,
  "\u0275\u0275definePipe": \u0275\u0275definePipe,
  "\u0275\u0275directiveInject": \u0275\u0275directiveInject,
  "\u0275\u0275getInheritedFactory": \u0275\u0275getInheritedFactory,
  "\u0275\u0275inject": import_root_effect_scheduler.\u0275\u0275inject,
  "\u0275\u0275injectAttribute": \u0275\u0275injectAttribute,
  "\u0275\u0275invalidFactory": \u0275\u0275invalidFactory,
  "\u0275\u0275invalidFactoryDep": import_root_effect_scheduler.\u0275\u0275invalidFactoryDep,
  "\u0275\u0275templateRefExtractor": \u0275\u0275templateRefExtractor,
  "\u0275\u0275resetView": import_root_effect_scheduler.\u0275\u0275resetView,
  "\u0275\u0275HostDirectivesFeature": \u0275\u0275HostDirectivesFeature,
  "\u0275\u0275NgOnChangesFeature": \u0275\u0275NgOnChangesFeature,
  "\u0275\u0275ProvidersFeature": \u0275\u0275ProvidersFeature,
  "\u0275\u0275CopyDefinitionFeature": \u0275\u0275CopyDefinitionFeature,
  "\u0275\u0275InheritDefinitionFeature": \u0275\u0275InheritDefinitionFeature,
  "\u0275\u0275ExternalStylesFeature": \u0275\u0275ExternalStylesFeature,
  "\u0275\u0275nextContext": \u0275\u0275nextContext,
  "\u0275\u0275namespaceHTML": import_root_effect_scheduler.\u0275\u0275namespaceHTML,
  "\u0275\u0275namespaceMathML": import_root_effect_scheduler.\u0275\u0275namespaceMathML,
  "\u0275\u0275namespaceSVG": import_root_effect_scheduler.\u0275\u0275namespaceSVG,
  "\u0275\u0275enableBindings": import_root_effect_scheduler.\u0275\u0275enableBindings,
  "\u0275\u0275disableBindings": import_root_effect_scheduler.\u0275\u0275disableBindings,
  "\u0275\u0275elementStart": \u0275\u0275elementStart,
  "\u0275\u0275elementEnd": \u0275\u0275elementEnd,
  "\u0275\u0275element": \u0275\u0275element,
  "\u0275\u0275elementContainerStart": \u0275\u0275elementContainerStart,
  "\u0275\u0275elementContainerEnd": \u0275\u0275elementContainerEnd,
  "\u0275\u0275domElement": \u0275\u0275domElement,
  "\u0275\u0275domElementStart": \u0275\u0275domElementStart,
  "\u0275\u0275domElementEnd": \u0275\u0275domElementEnd,
  "\u0275\u0275domElementContainer": \u0275\u0275domElementContainer,
  "\u0275\u0275domElementContainerStart": \u0275\u0275domElementContainerStart,
  "\u0275\u0275domElementContainerEnd": \u0275\u0275domElementContainerEnd,
  "\u0275\u0275domTemplate": \u0275\u0275domTemplate,
  "\u0275\u0275domListener": \u0275\u0275domListener,
  "\u0275\u0275elementContainer": \u0275\u0275elementContainer,
  "\u0275\u0275pureFunction0": \u0275\u0275pureFunction0,
  "\u0275\u0275pureFunction1": \u0275\u0275pureFunction1,
  "\u0275\u0275pureFunction2": \u0275\u0275pureFunction2,
  "\u0275\u0275pureFunction3": \u0275\u0275pureFunction3,
  "\u0275\u0275pureFunction4": \u0275\u0275pureFunction4,
  "\u0275\u0275pureFunction5": \u0275\u0275pureFunction5,
  "\u0275\u0275pureFunction6": \u0275\u0275pureFunction6,
  "\u0275\u0275pureFunction7": \u0275\u0275pureFunction7,
  "\u0275\u0275pureFunction8": \u0275\u0275pureFunction8,
  "\u0275\u0275pureFunctionV": \u0275\u0275pureFunctionV,
  "\u0275\u0275getCurrentView": \u0275\u0275getCurrentView,
  "\u0275\u0275restoreView": import_root_effect_scheduler.\u0275\u0275restoreView,
  "\u0275\u0275listener": \u0275\u0275listener,
  "\u0275\u0275projection": \u0275\u0275projection,
  "\u0275\u0275syntheticHostProperty": \u0275\u0275syntheticHostProperty,
  "\u0275\u0275syntheticHostListener": \u0275\u0275syntheticHostListener,
  "\u0275\u0275pipeBind1": \u0275\u0275pipeBind1,
  "\u0275\u0275pipeBind2": \u0275\u0275pipeBind2,
  "\u0275\u0275pipeBind3": \u0275\u0275pipeBind3,
  "\u0275\u0275pipeBind4": \u0275\u0275pipeBind4,
  "\u0275\u0275pipeBindV": \u0275\u0275pipeBindV,
  "\u0275\u0275projectionDef": \u0275\u0275projectionDef,
  "\u0275\u0275domProperty": \u0275\u0275domProperty,
  "\u0275\u0275ariaProperty": \u0275\u0275ariaProperty,
  "\u0275\u0275property": \u0275\u0275property,
  "\u0275\u0275pipe": \u0275\u0275pipe,
  "\u0275\u0275queryRefresh": \u0275\u0275queryRefresh,
  "\u0275\u0275queryAdvance": \u0275\u0275queryAdvance,
  "\u0275\u0275viewQuery": \u0275\u0275viewQuery,
  "\u0275\u0275viewQuerySignal": \u0275\u0275viewQuerySignal,
  "\u0275\u0275loadQuery": \u0275\u0275loadQuery,
  "\u0275\u0275contentQuery": \u0275\u0275contentQuery,
  "\u0275\u0275contentQuerySignal": \u0275\u0275contentQuerySignal,
  "\u0275\u0275reference": \u0275\u0275reference,
  "\u0275\u0275classMap": \u0275\u0275classMap,
  "\u0275\u0275styleMap": \u0275\u0275styleMap,
  "\u0275\u0275styleProp": \u0275\u0275styleProp,
  "\u0275\u0275classProp": \u0275\u0275classProp,
  "\u0275\u0275advance": \u0275\u0275advance,
  "\u0275\u0275template": \u0275\u0275template,
  "\u0275\u0275conditional": \u0275\u0275conditional,
  "\u0275\u0275conditionalCreate": \u0275\u0275conditionalCreate,
  "\u0275\u0275conditionalBranchCreate": \u0275\u0275conditionalBranchCreate,
  "\u0275\u0275defer": \u0275\u0275defer,
  "\u0275\u0275deferWhen": \u0275\u0275deferWhen,
  "\u0275\u0275deferOnIdle": \u0275\u0275deferOnIdle,
  "\u0275\u0275deferOnImmediate": \u0275\u0275deferOnImmediate,
  "\u0275\u0275deferOnTimer": \u0275\u0275deferOnTimer,
  "\u0275\u0275deferOnHover": \u0275\u0275deferOnHover,
  "\u0275\u0275deferOnInteraction": \u0275\u0275deferOnInteraction,
  "\u0275\u0275deferOnViewport": \u0275\u0275deferOnViewport,
  "\u0275\u0275deferPrefetchWhen": \u0275\u0275deferPrefetchWhen,
  "\u0275\u0275deferPrefetchOnIdle": \u0275\u0275deferPrefetchOnIdle,
  "\u0275\u0275deferPrefetchOnImmediate": \u0275\u0275deferPrefetchOnImmediate,
  "\u0275\u0275deferPrefetchOnTimer": \u0275\u0275deferPrefetchOnTimer,
  "\u0275\u0275deferPrefetchOnHover": \u0275\u0275deferPrefetchOnHover,
  "\u0275\u0275deferPrefetchOnInteraction": \u0275\u0275deferPrefetchOnInteraction,
  "\u0275\u0275deferPrefetchOnViewport": \u0275\u0275deferPrefetchOnViewport,
  "\u0275\u0275deferHydrateWhen": \u0275\u0275deferHydrateWhen,
  "\u0275\u0275deferHydrateNever": \u0275\u0275deferHydrateNever,
  "\u0275\u0275deferHydrateOnIdle": \u0275\u0275deferHydrateOnIdle,
  "\u0275\u0275deferHydrateOnImmediate": \u0275\u0275deferHydrateOnImmediate,
  "\u0275\u0275deferHydrateOnTimer": \u0275\u0275deferHydrateOnTimer,
  "\u0275\u0275deferHydrateOnHover": \u0275\u0275deferHydrateOnHover,
  "\u0275\u0275deferHydrateOnInteraction": \u0275\u0275deferHydrateOnInteraction,
  "\u0275\u0275deferHydrateOnViewport": \u0275\u0275deferHydrateOnViewport,
  "\u0275\u0275deferEnableTimerScheduling": \u0275\u0275deferEnableTimerScheduling,
  "\u0275\u0275repeater": \u0275\u0275repeater,
  "\u0275\u0275repeaterCreate": \u0275\u0275repeaterCreate,
  "\u0275\u0275repeaterTrackByIndex": \u0275\u0275repeaterTrackByIndex,
  "\u0275\u0275repeaterTrackByIdentity": \u0275\u0275repeaterTrackByIdentity,
  "\u0275\u0275componentInstance": \u0275\u0275componentInstance,
  "\u0275\u0275text": \u0275\u0275text,
  "\u0275\u0275textInterpolate": \u0275\u0275textInterpolate,
  "\u0275\u0275textInterpolate1": \u0275\u0275textInterpolate1,
  "\u0275\u0275textInterpolate2": \u0275\u0275textInterpolate2,
  "\u0275\u0275textInterpolate3": \u0275\u0275textInterpolate3,
  "\u0275\u0275textInterpolate4": \u0275\u0275textInterpolate4,
  "\u0275\u0275textInterpolate5": \u0275\u0275textInterpolate5,
  "\u0275\u0275textInterpolate6": \u0275\u0275textInterpolate6,
  "\u0275\u0275textInterpolate7": \u0275\u0275textInterpolate7,
  "\u0275\u0275textInterpolate8": \u0275\u0275textInterpolate8,
  "\u0275\u0275textInterpolateV": \u0275\u0275textInterpolateV,
  "\u0275\u0275i18n": \u0275\u0275i18n,
  "\u0275\u0275i18nAttributes": \u0275\u0275i18nAttributes,
  "\u0275\u0275i18nExp": \u0275\u0275i18nExp,
  "\u0275\u0275i18nStart": \u0275\u0275i18nStart,
  "\u0275\u0275i18nEnd": \u0275\u0275i18nEnd,
  "\u0275\u0275i18nApply": \u0275\u0275i18nApply,
  "\u0275\u0275i18nPostprocess": \u0275\u0275i18nPostprocess,
  "\u0275\u0275resolveWindow": \u0275\u0275resolveWindow,
  "\u0275\u0275resolveDocument": \u0275\u0275resolveDocument,
  "\u0275\u0275resolveBody": \u0275\u0275resolveBody,
  "\u0275\u0275setComponentScope": \u0275\u0275setComponentScope,
  "\u0275\u0275setNgModuleScope": \u0275\u0275setNgModuleScope,
  "\u0275\u0275registerNgModuleType": registerNgModuleType,
  "\u0275\u0275getComponentDepsFactory": \u0275\u0275getComponentDepsFactory,
  "\u0275setClassDebugInfo": \u0275setClassDebugInfo,
  "\u0275\u0275declareLet": \u0275\u0275declareLet,
  "\u0275\u0275storeLet": \u0275\u0275storeLet,
  "\u0275\u0275readContextLet": \u0275\u0275readContextLet,
  "\u0275\u0275attachSourceLocations": \u0275\u0275attachSourceLocations,
  "\u0275\u0275interpolate": \u0275\u0275interpolate,
  "\u0275\u0275interpolate1": \u0275\u0275interpolate1,
  "\u0275\u0275interpolate2": \u0275\u0275interpolate2,
  "\u0275\u0275interpolate3": \u0275\u0275interpolate3,
  "\u0275\u0275interpolate4": \u0275\u0275interpolate4,
  "\u0275\u0275interpolate5": \u0275\u0275interpolate5,
  "\u0275\u0275interpolate6": \u0275\u0275interpolate6,
  "\u0275\u0275interpolate7": \u0275\u0275interpolate7,
  "\u0275\u0275interpolate8": \u0275\u0275interpolate8,
  "\u0275\u0275interpolateV": \u0275\u0275interpolateV,
  "\u0275\u0275sanitizeHtml": \u0275\u0275sanitizeHtml,
  "\u0275\u0275sanitizeStyle": \u0275\u0275sanitizeStyle,
  "\u0275\u0275sanitizeResourceUrl": \u0275\u0275sanitizeResourceUrl,
  "\u0275\u0275sanitizeScript": \u0275\u0275sanitizeScript,
  "\u0275\u0275validateAttribute": \u0275\u0275validateAttribute,
  "\u0275\u0275sanitizeUrl": \u0275\u0275sanitizeUrl,
  "\u0275\u0275sanitizeUrlOrResourceUrl": \u0275\u0275sanitizeUrlOrResourceUrl,
  "\u0275\u0275trustConstantHtml": \u0275\u0275trustConstantHtml,
  "\u0275\u0275trustConstantResourceUrl": \u0275\u0275trustConstantResourceUrl,
  "forwardRef": import_root_effect_scheduler.forwardRef,
  "resolveForwardRef": import_root_effect_scheduler.resolveForwardRef,
  "\u0275\u0275twoWayProperty": \u0275\u0275twoWayProperty,
  "\u0275\u0275twoWayBindingSet": \u0275\u0275twoWayBindingSet,
  "\u0275\u0275twoWayListener": \u0275\u0275twoWayListener,
  "\u0275\u0275replaceMetadata": \u0275\u0275replaceMetadata,
  "\u0275\u0275getReplaceMetadataURL": \u0275\u0275getReplaceMetadataURL
}))();
let jitOptions = null;
function setJitOptions(options) {
  if (jitOptions !== null) {
    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
      ngDevMode && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
      return;
    }
    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
      ngDevMode && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
      return;
    }
  }
  jitOptions = options;
}
function getJitOptions() {
  return jitOptions;
}
function resetJitOptions() {
  jitOptions = null;
}
const moduleQueue = [];
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
  moduleQueue.push({ moduleType, ngModule });
}
let flushingModuleQueue = false;
function flushModuleScopingQueueAsMuchAsPossible() {
  if (!flushingModuleQueue) {
    flushingModuleQueue = true;
    try {
      for (let i = moduleQueue.length - 1; i >= 0; i--) {
        const { moduleType, ngModule } = moduleQueue[i];
        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
          moduleQueue.splice(i, 1);
          setScopeOnDeclaredComponents(moduleType, ngModule);
        }
      }
    } finally {
      flushingModuleQueue = false;
    }
  }
}
function isResolvedDeclaration(declaration) {
  if (Array.isArray(declaration)) {
    return declaration.every(isResolvedDeclaration);
  }
  return !!(0, import_root_effect_scheduler.resolveForwardRef)(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
  compileNgModuleDefs(moduleType, ngModule);
  if (ngModule.id !== void 0) {
    registerNgModuleType(moduleType, ngModule.id);
  }
  enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(moduleType, "Required value moduleType");
  ngDevMode && (0, import_root_effect_scheduler.assertDefined)(ngModule, "Required value ngModule");
  const declarations = (0, import_root_effect_scheduler.flatten)(ngModule.declarations || import_root_effect_scheduler.EMPTY_ARRAY);
  let ngModuleDef = null;
  Object.defineProperty(moduleType, import_root_effect_scheduler.NG_MOD_DEF, {
    configurable: true,
    get: () => {
      if (ngModuleDef === null) {
        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
          throw new Error(`'${(0, import_root_effect_scheduler.stringifyForError)(moduleType)}' module can't import itself`);
        }
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {
          type: moduleType,
          bootstrap: (0, import_root_effect_scheduler.flatten)(ngModule.bootstrap || import_root_effect_scheduler.EMPTY_ARRAY).map(import_root_effect_scheduler.resolveForwardRef),
          declarations: declarations.map(import_root_effect_scheduler.resolveForwardRef),
          imports: (0, import_root_effect_scheduler.flatten)(ngModule.imports || import_root_effect_scheduler.EMPTY_ARRAY).map(import_root_effect_scheduler.resolveForwardRef).map(expandModuleWithProviders),
          exports: (0, import_root_effect_scheduler.flatten)(ngModule.exports || import_root_effect_scheduler.EMPTY_ARRAY).map(import_root_effect_scheduler.resolveForwardRef).map(expandModuleWithProviders),
          schemas: ngModule.schemas ? (0, import_root_effect_scheduler.flatten)(ngModule.schemas) : null,
          id: ngModule.id || null
        });
        if (!ngModuleDef.schemas) {
          ngModuleDef.schemas = [];
        }
      }
      return ngModuleDef;
    }
  });
  let ngFactoryDef = null;
  Object.defineProperty(moduleType, import_root_effect_scheduler.NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\u0275fac.js`, {
          name: moduleType.name,
          type: moduleType,
          deps: reflectDependencies(moduleType),
          target: compiler.FactoryTarget.NgModule,
          typeArgumentCount: 0
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  let ngInjectorDef = null;
  Object.defineProperty(moduleType, import_root_effect_scheduler.NG_INJ_DEF, {
    get: () => {
      if (ngInjectorDef === null) {
        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
        const meta = {
          name: moduleType.name,
          type: moduleType,
          providers: ngModule.providers || import_root_effect_scheduler.EMPTY_ARRAY,
          imports: [
            (ngModule.imports || import_root_effect_scheduler.EMPTY_ARRAY).map(import_root_effect_scheduler.resolveForwardRef),
            (ngModule.exports || import_root_effect_scheduler.EMPTY_ARRAY).map(import_root_effect_scheduler.resolveForwardRef)
          ]
        };
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta);
      }
      return ngInjectorDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function generateStandaloneInDeclarationsError(type, location) {
  const prefix = `Unexpected "${(0, import_root_effect_scheduler.stringifyForError)(type)}" found in the "declarations" array of the`;
  const suffix = `"${(0, import_root_effect_scheduler.stringifyForError)(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`;
  return `${prefix} ${location}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
  if (verifiedNgModule.get(moduleType))
    return;
  if ((0, import_root_effect_scheduler.isStandalone)(moduleType))
    return;
  verifiedNgModule.set(moduleType, true);
  moduleType = (0, import_root_effect_scheduler.resolveForwardRef)(moduleType);
  let ngModuleDef;
  if (importingModule) {
    ngModuleDef = (0, import_root_effect_scheduler.getNgModuleDef)(moduleType);
    if (!ngModuleDef) {
      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  } else {
    ngModuleDef = (0, import_root_effect_scheduler.getNgModuleDefOrThrow)(moduleType);
  }
  const errors = [];
  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
  const imports = maybeUnwrapFn(ngModuleDef.imports);
  (0, import_root_effect_scheduler.flatten)(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt) => {
    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
  });
  const exports = maybeUnwrapFn(ngModuleDef.exports);
  declarations.forEach(verifyDeclarationsHaveDefinitions);
  declarations.forEach(verifyDirectivesHaveSelector);
  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));
  const combinedDeclarations = [
    ...declarations.map(import_root_effect_scheduler.resolveForwardRef),
    ...(0, import_root_effect_scheduler.flatten)(imports.map(computeCombinedExports)).map(import_root_effect_scheduler.resolveForwardRef)
  ];
  exports.forEach(verifyExportsAreDeclaredOrReExported);
  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
  const ngModule = getAnnotation(moduleType, "NgModule");
  if (ngModule) {
    ngModule.imports && (0, import_root_effect_scheduler.flatten)(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    ngModule.bootstrap && (0, import_root_effect_scheduler.deepForEach)(ngModule.bootstrap, verifyCorrectBootstrapType);
    ngModule.bootstrap && (0, import_root_effect_scheduler.deepForEach)(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
  }
  if (errors.length) {
    throw new Error(errors.join("\n"));
  }
  function verifyDeclarationsHaveDefinitions(type) {
    type = (0, import_root_effect_scheduler.resolveForwardRef)(type);
    const def = (0, import_root_effect_scheduler.getComponentDef)(type) || (0, import_root_effect_scheduler.getDirectiveDef)(type) || (0, import_root_effect_scheduler.getPipeDef)(type);
    if (!def) {
      errors.push(`Unexpected value '${(0, import_root_effect_scheduler.stringifyForError)(type)}' declared by the module '${(0, import_root_effect_scheduler.stringifyForError)(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
  }
  function verifyDirectivesHaveSelector(type) {
    type = (0, import_root_effect_scheduler.resolveForwardRef)(type);
    const def = (0, import_root_effect_scheduler.getDirectiveDef)(type);
    if (!(0, import_root_effect_scheduler.getComponentDef)(type) && def && def.selectors.length == 0) {
      errors.push(`Directive ${(0, import_root_effect_scheduler.stringifyForError)(type)} has no selector, please add it!`);
    }
  }
  function verifyNotStandalone(type, moduleType2) {
    type = (0, import_root_effect_scheduler.resolveForwardRef)(type);
    const def = (0, import_root_effect_scheduler.getComponentDef)(type) || (0, import_root_effect_scheduler.getDirectiveDef)(type) || (0, import_root_effect_scheduler.getPipeDef)(type);
    if (def == null ? void 0 : def.standalone) {
      const location = `"${(0, import_root_effect_scheduler.stringifyForError)(moduleType2)}" NgModule`;
      errors.push(generateStandaloneInDeclarationsError(type, location));
    }
  }
  function verifyExportsAreDeclaredOrReExported(type) {
    type = (0, import_root_effect_scheduler.resolveForwardRef)(type);
    const kind = (0, import_root_effect_scheduler.getComponentDef)(type) && "component" || (0, import_root_effect_scheduler.getDirectiveDef)(type) && "directive" || (0, import_root_effect_scheduler.getPipeDef)(type) && "pipe";
    if (kind) {
      if (combinedDeclarations.lastIndexOf(type) === -1) {
        errors.push(`Can't export ${kind} ${(0, import_root_effect_scheduler.stringifyForError)(type)} from ${(0, import_root_effect_scheduler.stringifyForError)(moduleType)} as it was neither declared nor imported!`);
      }
    }
  }
  function verifyDeclarationIsUnique(type, suppressErrors) {
    type = (0, import_root_effect_scheduler.resolveForwardRef)(type);
    const existingModule = ownerNgModule.get(type);
    if (existingModule && existingModule !== moduleType) {
      if (!suppressErrors) {
        const modules2 = [existingModule, moduleType].map(import_root_effect_scheduler.stringifyForError).sort();
        errors.push(`Type ${(0, import_root_effect_scheduler.stringifyForError)(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${(0, import_root_effect_scheduler.stringifyForError)(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${(0, import_root_effect_scheduler.stringifyForError)(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
      }
    } else {
      ownerNgModule.set(type, moduleType);
    }
  }
  function verifyComponentIsPartOfNgModule(type) {
    type = (0, import_root_effect_scheduler.resolveForwardRef)(type);
    const existingModule = ownerNgModule.get(type);
    if (!existingModule && !(0, import_root_effect_scheduler.isStandalone)(type)) {
      errors.push(`Component ${(0, import_root_effect_scheduler.stringifyForError)(type)} is not part of any NgModule or the module has not been imported into your module.`);
    }
  }
  function verifyCorrectBootstrapType(type) {
    type = (0, import_root_effect_scheduler.resolveForwardRef)(type);
    if (!(0, import_root_effect_scheduler.getComponentDef)(type)) {
      errors.push(`${(0, import_root_effect_scheduler.stringifyForError)(type)} cannot be used as an entry component.`);
    }
    if ((0, import_root_effect_scheduler.isStandalone)(type)) {
      errors.push(`The \`${(0, import_root_effect_scheduler.stringifyForError)(type)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`);
    }
  }
  function verifySemanticsOfNgModuleImport(type, importingModule2) {
    type = (0, import_root_effect_scheduler.resolveForwardRef)(type);
    const directiveDef = (0, import_root_effect_scheduler.getComponentDef)(type) || (0, import_root_effect_scheduler.getDirectiveDef)(type);
    if (directiveDef !== null && !directiveDef.standalone) {
      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
    const pipeDef = (0, import_root_effect_scheduler.getPipeDef)(type);
    if (pipeDef !== null && !pipeDef.standalone) {
      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
  }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
  typeOrWithProviders = (0, import_root_effect_scheduler.resolveForwardRef)(typeOrWithProviders);
  return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type, name) {
  let annotation = null;
  collect(type.__annotations__);
  collect(type.decorators);
  return annotation;
  function collect(annotations) {
    if (annotations) {
      annotations.forEach(readAnnotation);
    }
  }
  function readAnnotation(decorator) {
    if (!annotation) {
      const proto = Object.getPrototypeOf(decorator);
      if (proto.ngMetadataName == name) {
        annotation = decorator;
      } else if (decorator.type) {
        const proto2 = Object.getPrototypeOf(decorator.type);
        if (proto2.ngMetadataName == name) {
          annotation = decorator.args[0];
        }
      }
    }
  }
}
let ownerNgModule = /* @__PURE__ */ new WeakMap();
let verifiedNgModule = /* @__PURE__ */ new WeakMap();
function resetCompiledComponents() {
  ownerNgModule = /* @__PURE__ */ new WeakMap();
  verifiedNgModule = /* @__PURE__ */ new WeakMap();
  moduleQueue.length = 0;
  GENERATED_COMP_IDS.clear();
}
function computeCombinedExports(type) {
  type = (0, import_root_effect_scheduler.resolveForwardRef)(type);
  const ngModuleDef = (0, import_root_effect_scheduler.getNgModuleDef)(type);
  if (ngModuleDef === null) {
    return [type];
  }
  return (0, import_root_effect_scheduler.flatten)(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {
    const ngModuleDef2 = (0, import_root_effect_scheduler.getNgModuleDef)(type2);
    if (ngModuleDef2) {
      verifySemanticsOfNgModuleDef(type2, false);
      return computeCombinedExports(type2);
    } else {
      return type2;
    }
  }));
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
  const declarations = (0, import_root_effect_scheduler.flatten)(ngModule.declarations || import_root_effect_scheduler.EMPTY_ARRAY);
  const transitiveScopes = transitiveScopesFor(moduleType);
  declarations.forEach((declaration) => {
    declaration = (0, import_root_effect_scheduler.resolveForwardRef)(declaration);
    if (declaration.hasOwnProperty(import_root_effect_scheduler.NG_COMP_DEF)) {
      const component = declaration;
      const componentDef = (0, import_root_effect_scheduler.getComponentDef)(component);
      patchComponentDefWithScope(componentDef, transitiveScopes);
    } else if (!declaration.hasOwnProperty(import_root_effect_scheduler.NG_DIR_DEF) && !declaration.hasOwnProperty(import_root_effect_scheduler.NG_PIPE_DEF)) {
      declaration.ngSelectorScope = moduleType;
    }
  });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(import_root_effect_scheduler.NG_COMP_DEF) ? (0, import_root_effect_scheduler.getComponentDef)(dir) : (0, import_root_effect_scheduler.getDirectiveDef)(dir)).filter((def) => !!def);
  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe) => (0, import_root_effect_scheduler.getPipeDef)(pipe));
  componentDef.schemas = transitiveScopes.schemas;
  componentDef.tView = null;
}
function transitiveScopesFor(type) {
  if (isNgModule(type)) {
    const scope = depsTracker.getNgModuleScope(type);
    const def = (0, import_root_effect_scheduler.getNgModuleDefOrThrow)(type);
    return __spreadValues({
      schemas: def.schemas || null
    }, scope);
  } else if ((0, import_root_effect_scheduler.isStandalone)(type)) {
    const directiveDef = (0, import_root_effect_scheduler.getComponentDef)(type) || (0, import_root_effect_scheduler.getDirectiveDef)(type);
    if (directiveDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set([type]),
          pipes: /* @__PURE__ */ new Set()
        }
      };
    }
    const pipeDef = (0, import_root_effect_scheduler.getPipeDef)(type);
    if (pipeDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set([type])
        }
      };
    }
  }
  throw new Error(`${type.name} does not have a module def (\u0275mod property)`);
}
function expandModuleWithProviders(value) {
  if (isModuleWithProviders(value)) {
    return value.ngModule;
  }
  return value;
}
let compilationDepth = 0;
function compileComponent(type, metadata) {
  (typeof ngDevMode === "undefined" || ngDevMode) && (0, import_root_effect_scheduler.initNgDevMode)();
  let ngComponentDef = null;
  maybeQueueResolutionOfComponentResources(type, metadata);
  addDirectiveFactoryDef(type, metadata);
  Object.defineProperty(type, import_root_effect_scheduler.NG_COMP_DEF, {
    get: () => {
      if (ngComponentDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "component",
          type
        });
        if (componentNeedsResolution(metadata)) {
          const error = [`Component '${type.name}' is not resolved:`];
          if (metadata.templateUrl) {
            error.push(` - templateUrl: ${metadata.templateUrl}`);
          }
          if (metadata.styleUrls && metadata.styleUrls.length) {
            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
          }
          if (metadata.styleUrl) {
            error.push(` - styleUrl: ${metadata.styleUrl}`);
          }
          error.push(`Did you run and wait for 'resolveComponentResources()'?`);
          throw new Error(error.join("\n"));
        }
        const options = getJitOptions();
        let preserveWhitespaces = metadata.preserveWhitespaces;
        if (preserveWhitespaces === void 0) {
          if (options !== null && options.preserveWhitespaces !== void 0) {
            preserveWhitespaces = options.preserveWhitespaces;
          } else {
            preserveWhitespaces = false;
          }
        }
        let encapsulation = metadata.encapsulation;
        if (encapsulation === void 0) {
          if (options !== null && options.defaultEncapsulation !== void 0) {
            encapsulation = options.defaultEncapsulation;
          } else {
            encapsulation = ViewEncapsulation.Emulated;
          }
        }
        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
        const baseMeta = directiveMetadata(type, metadata);
        const meta = __spreadProps(__spreadValues({}, baseMeta), {
          typeSourceSpan: compiler.createParseSourceSpan("Component", type.name, templateUrl),
          template: metadata.template || "",
          preserveWhitespaces,
          styles: typeof metadata.styles === "string" ? [metadata.styles] : metadata.styles || import_root_effect_scheduler.EMPTY_ARRAY,
          animations: metadata.animations,
          // JIT components are always compiled against an empty set of `declarations`. Instead, the
          // `directiveDefs` and `pipeDefs` are updated at a later point:
          //  * for NgModule-based components, they're set when the NgModule which declares the
          //    component resolves in the module scoping queue
          //  * for standalone components, they're set just below, after `compileComponent`.
          declarations: [],
          changeDetection: metadata.changeDetection,
          encapsulation,
          interpolation: metadata.interpolation,
          viewProviders: metadata.viewProviders || null,
          // We can't inspect whether any of the dependencies are actually directives, because they
          // get patched on after compilation. That's why in JIT mode we consider that any
          // dependency might be a directive dependency.
          hasDirectiveDependencies: !baseMeta.isStandalone || metadata.imports != null && metadata.imports.length > 0
        });
        compilationDepth++;
        try {
          if (meta.usesInheritance) {
            addDirectiveDefToUndecoratedParents(type);
          }
          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          if (meta.isStandalone) {
            const imports = (0, import_root_effect_scheduler.flatten)(metadata.imports || import_root_effect_scheduler.EMPTY_ARRAY);
            const { directiveDefs, pipeDefs } = getStandaloneDefFunctions(type, imports);
            ngComponentDef.directiveDefs = directiveDefs;
            ngComponentDef.pipeDefs = pipeDefs;
            ngComponentDef.dependencies = () => imports.map(import_root_effect_scheduler.resolveForwardRef);
          }
        } finally {
          compilationDepth--;
        }
        if (compilationDepth === 0) {
          flushModuleScopingQueueAsMuchAsPossible();
        }
        if (hasSelectorScope(type)) {
          const scopes = transitiveScopesFor(type.ngSelectorScope);
          patchComponentDefWithScope(ngComponentDef, scopes);
        }
        if (metadata.schemas) {
          if (meta.isStandalone) {
            ngComponentDef.schemas = metadata.schemas;
          } else {
            throw new Error(`The 'schemas' was specified for the ${(0, import_root_effect_scheduler.stringifyForError)(type)} but is only valid on a component that is standalone.`);
          }
        } else if (meta.isStandalone) {
          ngComponentDef.schemas = [];
        }
      }
      return ngComponentDef;
    },
    set: (def) => {
      ngComponentDef = def;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getStandaloneDefFunctions(type, imports) {
  const directiveDefs = () => {
    if (ngDevMode) {
      for (const rawDep of imports) {
        verifyStandaloneImport(rawDep, type);
      }
    }
    if (!isComponent(type)) {
      return [];
    }
    const scope = depsTracker.getStandaloneComponentScope(type, imports);
    return [...scope.compilation.directives].map((p) => (0, import_root_effect_scheduler.getComponentDef)(p) || (0, import_root_effect_scheduler.getDirectiveDef)(p)).filter((d) => d !== null);
  };
  const pipeDefs = () => {
    if (ngDevMode) {
      for (const rawDep of imports) {
        verifyStandaloneImport(rawDep, type);
      }
    }
    if (!isComponent(type)) {
      return [];
    }
    const scope = depsTracker.getStandaloneComponentScope(type, imports);
    return [...scope.compilation.pipes].map((p) => (0, import_root_effect_scheduler.getPipeDef)(p)).filter((d) => d !== null);
  };
  return {
    directiveDefs,
    pipeDefs
  };
}
function hasSelectorScope(component) {
  return component.ngSelectorScope !== void 0;
}
function compileDirective(type, directive) {
  let ngDirectiveDef = null;
  addDirectiveFactoryDef(type, directive || {});
  Object.defineProperty(type, import_root_effect_scheduler.NG_DIR_DEF, {
    get: () => {
      if (ngDirectiveDef === null) {
        const meta = getDirectiveMetadata(type, directive || {});
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
      }
      return ngDirectiveDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getDirectiveMetadata(type, metadata) {
  const name = type && type.name;
  const sourceMapUrl = `ng:///${name}/\u0275dir.js`;
  const compiler = getCompilerFacade({ usage: 0, kind: "directive", type });
  const facade = directiveMetadata(type, metadata);
  facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
  if (facade.usesInheritance) {
    addDirectiveDefToUndecoratedParents(type);
  }
  return { metadata: facade, sourceMapUrl };
}
function addDirectiveFactoryDef(type, metadata) {
  let ngFactoryDef = null;
  Object.defineProperty(type, import_root_effect_scheduler.NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const meta = getDirectiveMetadata(type, metadata);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/\u0275fac.js`, {
          name: meta.metadata.name,
          type: meta.metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Directive
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function extendsDirectlyFromObject(type) {
  return Object.getPrototypeOf(type.prototype) === Object.prototype;
}
function directiveMetadata(type, metadata) {
  var _a2;
  const reflect = getReflect();
  const propMetadata = reflect.ownPropMetadata(type);
  return {
    name: type.name,
    type,
    selector: metadata.selector !== void 0 ? metadata.selector : null,
    host: metadata.host || import_root_effect_scheduler.EMPTY_OBJ,
    propMetadata,
    inputs: metadata.inputs || import_root_effect_scheduler.EMPTY_ARRAY,
    outputs: metadata.outputs || import_root_effect_scheduler.EMPTY_ARRAY,
    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
    lifecycle: { usesOnChanges: reflect.hasLifecycleHook(type, "ngOnChanges") },
    typeSourceSpan: null,
    usesInheritance: !extendsDirectlyFromObject(type),
    exportAs: extractExportAs(metadata.exportAs),
    providers: metadata.providers || null,
    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
    isStandalone: metadata.standalone === void 0 ? true : !!metadata.standalone,
    isSignal: !!metadata.signals,
    hostDirectives: ((_a2 = metadata.hostDirectives) == null ? void 0 : _a2.map((directive) => typeof directive === "function" ? { directive } : directive)) || null
  };
}
function addDirectiveDefToUndecoratedParents(type) {
  const objPrototype = Object.prototype;
  let parent = Object.getPrototypeOf(type.prototype).constructor;
  while (parent && parent !== objPrototype) {
    if (!(0, import_root_effect_scheduler.getDirectiveDef)(parent) && !(0, import_root_effect_scheduler.getComponentDef)(parent) && shouldAddAbstractDirective(parent)) {
      compileDirective(parent, null);
    }
    parent = Object.getPrototypeOf(parent);
  }
}
function convertToR3QueryPredicate(selector) {
  return typeof selector === "string" ? splitByComma(selector) : (0, import_root_effect_scheduler.resolveForwardRef)(selector);
}
function convertToR3QueryMetadata(propertyName, ann) {
  return {
    propertyName,
    predicate: convertToR3QueryPredicate(ann.selector),
    descendants: ann.descendants,
    first: ann.first,
    read: ann.read ? ann.read : null,
    static: !!ann.static,
    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,
    isSignal: !!ann.isSignal
  };
}
function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
  const queriesMeta = [];
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      const annotations = propMetadata[field];
      annotations.forEach((ann) => {
        if (isQueryAnn(ann)) {
          if (!ann.selector) {
            throw new Error(`Can't construct a query for the property "${field}" of "${(0, import_root_effect_scheduler.stringifyForError)(type)}" since the query selector wasn't defined.`);
          }
          if (annotations.some(isInputAnnotation)) {
            throw new Error(`Cannot combine @Input decorators with query decorators`);
          }
          queriesMeta.push(convertToR3QueryMetadata(field, ann));
        }
      });
    }
  }
  return queriesMeta;
}
function extractExportAs(exportAs) {
  return exportAs === void 0 ? null : splitByComma(exportAs);
}
function isContentQuery(value) {
  const name = value.ngMetadataName;
  return name === "ContentChild" || name === "ContentChildren";
}
function isViewQuery(value) {
  const name = value.ngMetadataName;
  return name === "ViewChild" || name === "ViewChildren";
}
function isInputAnnotation(value) {
  return value.ngMetadataName === "Input";
}
function splitByComma(value) {
  return value.split(",").map((piece) => piece.trim());
}
const LIFECYCLE_HOOKS = [
  "ngOnChanges",
  "ngOnInit",
  "ngOnDestroy",
  "ngDoCheck",
  "ngAfterViewInit",
  "ngAfterViewChecked",
  "ngAfterContentInit",
  "ngAfterContentChecked"
];
function shouldAddAbstractDirective(type) {
  const reflect = getReflect();
  if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {
    return true;
  }
  const propMetadata = reflect.propMetadata(type);
  for (const field in propMetadata) {
    const annotations = propMetadata[field];
    for (let i = 0; i < annotations.length; i++) {
      const current = annotations[i];
      const metadataName = current.ngMetadataName;
      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
        return true;
      }
    }
  }
  return false;
}
function compilePipe(type, meta) {
  let ngPipeDef = null;
  let ngFactoryDef = null;
  Object.defineProperty(type, import_root_effect_scheduler.NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/\u0275fac.js`, {
          name: metadata.name,
          type: metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Pipe
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  Object.defineProperty(type, import_root_effect_scheduler.NG_PIPE_DEF, {
    get: () => {
      if (ngPipeDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/\u0275pipe.js`, metadata);
      }
      return ngPipeDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getPipeMetadata(type, meta) {
  return {
    type,
    name: type.name,
    pipeName: meta.name,
    pure: meta.pure !== void 0 ? meta.pure : true,
    isStandalone: meta.standalone === void 0 ? true : !!meta.standalone
  };
}
const Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type, meta) => compileDirective(type, meta));
const Component = makeDecorator("Component", (c = {}) => __spreadValues({ changeDetection: ChangeDetectionStrategy.Default }, c), Directive, void 0, (type, meta) => compileComponent(type, meta));
const Pipe = makeDecorator("Pipe", (p) => __spreadValues({ pure: true }, p), void 0, void 0, (type, meta) => compilePipe(type, meta));
const Input = makePropDecorator("Input", (arg) => {
  if (!arg) {
    return {};
  }
  return typeof arg === "string" ? { alias: arg } : arg;
});
const Output = makePropDecorator("Output", (alias) => ({ alias }));
const HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({ hostPropertyName }));
const HostListener = makePropDecorator("HostListener", (eventName, args) => ({ eventName, args }));
const NgModule = makeDecorator(
  "NgModule",
  (ngModule) => ngModule,
  void 0,
  void 0,
  /**
   * Decorator that marks the following class as an NgModule, and supplies
   * configuration metadata for it.
   *
   * * The `declarations` option configures the compiler
   * with information about what belongs to the NgModule.
   * * The `providers` options configures the NgModule's injector to provide
   * dependencies the NgModule members.
   * * The `imports` and `exports` options bring in members from other modules, and make
   * this module's members available to others.
   */
  (type, meta) => compileNgModule(type, meta)
);
class ModuleWithComponentFactories {
  constructor(ngModuleFactory, componentFactories) {
    __publicField(this, "ngModuleFactory");
    __publicField(this, "componentFactories");
    this.ngModuleFactory = ngModuleFactory;
    this.componentFactories = componentFactories;
  }
}
const _Compiler = class _Compiler {
  /**
   * Compiles the given NgModule and all of its components. All templates of the components
   * have to be inlined.
   */
  compileModuleSync(moduleType) {
    return new NgModuleFactory2(moduleType);
  }
  /**
   * Compiles the given NgModule and all of its components
   */
  compileModuleAsync(moduleType) {
    return Promise.resolve(this.compileModuleSync(moduleType));
  }
  /**
   * Same as {@link Compiler#compileModuleSync compileModuleSync} but also creates ComponentFactories for all components.
   */
  compileModuleAndAllComponentsSync(moduleType) {
    const ngModuleFactory = this.compileModuleSync(moduleType);
    const moduleDef = (0, import_root_effect_scheduler.getNgModuleDef)(moduleType);
    const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
      const componentDef = (0, import_root_effect_scheduler.getComponentDef)(declaration);
      componentDef && factories.push(new ComponentFactory2(componentDef));
      return factories;
    }, []);
    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
  }
  /**
   * Same as {@link Compiler#compileModuleAsync compileModuleAsync} but also creates ComponentFactories for all components.
   */
  compileModuleAndAllComponentsAsync(moduleType) {
    return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
  }
  /**
   * Clears all caches.
   */
  clearCache() {
  }
  /**
   * Clears the cache for the given component/ngModule.
   */
  clearCacheFor(type) {
  }
  /**
   * Returns the id for a given NgModule, if one is defined and known to the compiler.
   */
  getModuleId(moduleType) {
    return void 0;
  }
};
__publicField(_Compiler, "\u0275fac", function Compiler_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _Compiler)();
});
__publicField(_Compiler, "\u0275prov", /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({ token: _Compiler, factory: _Compiler.\u0275fac, providedIn: "root" }));
let Compiler = _Compiler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();
const COMPILER_OPTIONS = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "compilerOptions" : "");
class CompilerFactory {
}
const _NgZoneChangeDetectionScheduler = class _NgZoneChangeDetectionScheduler {
  constructor() {
    __publicField(this, "zone", (0, import_root_effect_scheduler.inject)(NgZone));
    __publicField(this, "changeDetectionScheduler", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.ChangeDetectionScheduler));
    __publicField(this, "applicationRef", (0, import_root_effect_scheduler.inject)(ApplicationRef));
    __publicField(this, "applicationErrorHandler", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.INTERNAL_APPLICATION_ERROR_HANDLER));
    __publicField(this, "_onMicrotaskEmptySubscription");
  }
  initialize() {
    if (this._onMicrotaskEmptySubscription) {
      return;
    }
    this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
      next: () => {
        if (this.changeDetectionScheduler.runningTick) {
          return;
        }
        this.zone.run(() => {
          try {
            this.applicationRef.dirtyFlags |= 1;
            this.applicationRef._tick();
          } catch (e) {
            this.applicationErrorHandler(e);
          }
        });
      }
    });
  }
  ngOnDestroy() {
    var _a2;
    (_a2 = this._onMicrotaskEmptySubscription) == null ? void 0 : _a2.unsubscribe();
  }
};
__publicField(_NgZoneChangeDetectionScheduler, "\u0275fac", function NgZoneChangeDetectionScheduler_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NgZoneChangeDetectionScheduler)();
});
__publicField(_NgZoneChangeDetectionScheduler, "\u0275prov", /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({ token: _NgZoneChangeDetectionScheduler, factory: _NgZoneChangeDetectionScheduler.\u0275fac, providedIn: "root" }));
let NgZoneChangeDetectionScheduler = _NgZoneChangeDetectionScheduler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgZoneChangeDetectionScheduler, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();
const PROVIDED_NG_ZONE = new import_root_effect_scheduler.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "provideZoneChangeDetection token" : "", { factory: () => false });
function internalProvideZoneChangeDetection({ ngZoneFactory, ignoreChangesOutsideZone, scheduleInRootZone }) {
  ngZoneFactory != null ? ngZoneFactory : ngZoneFactory = () => new NgZone(__spreadProps(__spreadValues({}, getNgZoneOptions()), { scheduleInRootZone }));
  return [
    { provide: NgZone, useFactory: ngZoneFactory },
    {
      provide: import_root_effect_scheduler.ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const ngZoneChangeDetectionScheduler = (0, import_root_effect_scheduler.inject)(NgZoneChangeDetectionScheduler, {
          optional: true
        });
        if ((typeof ngDevMode === "undefined" || ngDevMode) && ngZoneChangeDetectionScheduler === null) {
          throw new import_root_effect_scheduler.RuntimeError(402, `A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the \`BrowserModule\` is imported.`);
        }
        return () => ngZoneChangeDetectionScheduler.initialize();
      }
    },
    {
      provide: import_root_effect_scheduler.ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const service = (0, import_root_effect_scheduler.inject)(ZoneStablePendingTask);
        return () => {
          service.initialize();
        };
      }
    },
    // Always disable scheduler whenever explicitly disabled, even if another place called
    // `provideZoneChangeDetection` without the 'ignore' option.
    ignoreChangesOutsideZone === true ? { provide: import_root_effect_scheduler.ZONELESS_SCHEDULER_DISABLED, useValue: true } : [],
    {
      provide: import_root_effect_scheduler.SCHEDULE_IN_ROOT_ZONE,
      useValue: scheduleInRootZone != null ? scheduleInRootZone : SCHEDULE_IN_ROOT_ZONE_DEFAULT
    },
    {
      provide: import_root_effect_scheduler.INTERNAL_APPLICATION_ERROR_HANDLER,
      useFactory: () => {
        const zone = (0, import_root_effect_scheduler.inject)(NgZone);
        const injector = (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.EnvironmentInjector);
        let userErrorHandler;
        return (e) => {
          zone.runOutsideAngular(() => {
            if (injector.destroyed && !userErrorHandler) {
              setTimeout(() => {
                throw e;
              });
            } else {
              userErrorHandler != null ? userErrorHandler : userErrorHandler = injector.get(import_root_effect_scheduler.ErrorHandler);
              userErrorHandler.handleError(e);
            }
          });
        };
      }
    }
  ];
}
function provideZoneChangeDetection(options) {
  const ignoreChangesOutsideZone = options == null ? void 0 : options.ignoreChangesOutsideZone;
  const scheduleInRootZone = options == null ? void 0 : options.scheduleInRootZone;
  const zoneProviders = internalProvideZoneChangeDetection({
    ngZoneFactory: () => {
      const ngZoneOptions = getNgZoneOptions(options);
      ngZoneOptions.scheduleInRootZone = scheduleInRootZone;
      if (ngZoneOptions.shouldCoalesceEventChangeDetection) {
        performanceMarkFeature("NgZone_CoalesceEvent");
      }
      return new NgZone(ngZoneOptions);
    },
    ignoreChangesOutsideZone,
    scheduleInRootZone
  });
  return (0, import_root_effect_scheduler.makeEnvironmentProviders)([
    { provide: PROVIDED_NG_ZONE, useValue: true },
    { provide: import_root_effect_scheduler.ZONELESS_ENABLED, useValue: false },
    zoneProviders
  ]);
}
function getNgZoneOptions(options) {
  var _a2, _b2;
  return {
    enableLongStackTrace: typeof ngDevMode === "undefined" ? false : !!ngDevMode,
    shouldCoalesceEventChangeDetection: (_a2 = options == null ? void 0 : options.eventCoalescing) != null ? _a2 : false,
    shouldCoalesceRunChangeDetection: (_b2 = options == null ? void 0 : options.runCoalescing) != null ? _b2 : false
  };
}
const _ZoneStablePendingTask = class _ZoneStablePendingTask {
  constructor() {
    __publicField(this, "subscription", new import_rxjs.Subscription());
    __publicField(this, "initialized", false);
    __publicField(this, "zone", (0, import_root_effect_scheduler.inject)(NgZone));
    __publicField(this, "pendingTasks", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.PendingTasksInternal));
  }
  initialize() {
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    let task = null;
    if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
      task = this.pendingTasks.add();
    }
    this.zone.runOutsideAngular(() => {
      this.subscription.add(this.zone.onStable.subscribe(() => {
        NgZone.assertNotInAngularZone();
        queueMicrotask(() => {
          if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
            this.pendingTasks.remove(task);
            task = null;
          }
        });
      }));
    });
    this.subscription.add(this.zone.onUnstable.subscribe(() => {
      NgZone.assertInAngularZone();
      task != null ? task : task = this.pendingTasks.add();
    }));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
__publicField(_ZoneStablePendingTask, "\u0275fac", function ZoneStablePendingTask_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ZoneStablePendingTask)();
});
__publicField(_ZoneStablePendingTask, "\u0275prov", /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({ token: _ZoneStablePendingTask, factory: _ZoneStablePendingTask.\u0275fac, providedIn: "root" }));
let ZoneStablePendingTask = _ZoneStablePendingTask;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoneStablePendingTask, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();
const CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;
let consecutiveMicrotaskNotifications = 0;
let stackFromLastFewNotifications = [];
function trackMicrotaskNotificationForDebugging() {
  consecutiveMicrotaskNotifications++;
  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {
    const stack = new Error().stack;
    if (stack) {
      stackFromLastFewNotifications.push(stack);
    }
  }
  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {
    throw new import_root_effect_scheduler.RuntimeError(103, "Angular could not stabilize because there were endless change notifications within the browser event loop. The stack from the last several notifications: \n" + stackFromLastFewNotifications.join("\n"));
  }
}
const _ChangeDetectionSchedulerImpl = class _ChangeDetectionSchedulerImpl {
  constructor() {
    __publicField(this, "applicationErrorHandler", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.INTERNAL_APPLICATION_ERROR_HANDLER));
    __publicField(this, "appRef", (0, import_root_effect_scheduler.inject)(ApplicationRef));
    __publicField(this, "taskService", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.PendingTasksInternal));
    __publicField(this, "ngZone", (0, import_root_effect_scheduler.inject)(NgZone));
    __publicField(this, "zonelessEnabled", (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.ZONELESS_ENABLED));
    __publicField(this, "tracing", (0, import_root_effect_scheduler.inject)(TracingService, { optional: true }));
    __publicField(this, "disableScheduling", (_e = (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.ZONELESS_SCHEDULER_DISABLED, { optional: true })) != null ? _e : false);
    __publicField(this, "zoneIsDefined", typeof Zone !== "undefined" && !!Zone.root.run);
    __publicField(this, "schedulerTickApplyArgs", [{ data: { "__scheduler_tick__": true } }]);
    __publicField(this, "subscriptions", new import_rxjs.Subscription());
    __publicField(this, "angularZoneId", this.zoneIsDefined ? (_f = this.ngZone._inner) == null ? void 0 : _f.get(angularZoneInstanceIdProperty) : null);
    __publicField(this, "scheduleInRootZone", !this.zonelessEnabled && this.zoneIsDefined && ((_g = (0, import_root_effect_scheduler.inject)(import_root_effect_scheduler.SCHEDULE_IN_ROOT_ZONE, { optional: true })) != null ? _g : false));
    __publicField(this, "cancelScheduledCallback", null);
    __publicField(this, "useMicrotaskScheduler", false);
    __publicField(this, "runningTick", false);
    __publicField(this, "pendingRenderTaskId", null);
    this.subscriptions.add(this.appRef.afterTick.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.disableScheduling || (this.disableScheduling = !this.zonelessEnabled && // NoopNgZone without enabling zoneless means no scheduling whatsoever
    (this.ngZone instanceof NoopNgZone || // The same goes for the lack of Zone without enabling zoneless scheduling
    !this.zoneIsDefined));
  }
  notify(source) {
    var _a2, _b2;
    if (!this.zonelessEnabled && source === 5) {
      return;
    }
    let force = false;
    switch (source) {
      case 0: {
        this.appRef.dirtyFlags |= 2;
        break;
      }
      case 3:
      case 2:
      case 4:
      case 5:
      case 1: {
        this.appRef.dirtyFlags |= 4;
        break;
      }
      case 6: {
        this.appRef.dirtyFlags |= 2;
        force = true;
        break;
      }
      case 12: {
        this.appRef.dirtyFlags |= 16;
        force = true;
        break;
      }
      case 13: {
        this.appRef.dirtyFlags |= 2;
        force = true;
        break;
      }
      case 11: {
        force = true;
        break;
      }
      case 9:
      case 8:
      case 7:
      case 10:
      default: {
        this.appRef.dirtyFlags |= 8;
      }
    }
    this.appRef.tracingSnapshot = (_b2 = (_a2 = this.tracing) == null ? void 0 : _a2.snapshot(this.appRef.tracingSnapshot)) != null ? _b2 : null;
    if (!this.shouldScheduleTick(force)) {
      return;
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (this.useMicrotaskScheduler) {
        trackMicrotaskNotificationForDebugging();
      } else {
        consecutiveMicrotaskNotifications = 0;
        stackFromLastFewNotifications.length = 0;
      }
    }
    const scheduleCallback = this.useMicrotaskScheduler ? scheduleCallbackWithMicrotask : scheduleCallbackWithRafRace;
    this.pendingRenderTaskId = this.taskService.add();
    if (this.scheduleInRootZone) {
      this.cancelScheduledCallback = Zone.root.run(() => scheduleCallback(() => this.tick()));
    } else {
      this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => scheduleCallback(() => this.tick()));
    }
  }
  shouldScheduleTick(force) {
    if (this.disableScheduling && !force || this.appRef.destroyed) {
      return false;
    }
    if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {
      return false;
    }
    if (!this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(angularZoneInstanceIdProperty + this.angularZoneId)) {
      return false;
    }
    return true;
  }
  /**
   * Calls ApplicationRef._tick inside the `NgZone`.
   *
   * Calling `tick` directly runs change detection and cancels any change detection that had been
   * scheduled previously.
   *
   * @param shouldRefreshViews Passed directly to `ApplicationRef._tick` and skips straight to
   *     render hooks when `false`.
   */
  tick() {
    if (this.runningTick || this.appRef.destroyed) {
      return;
    }
    if (this.appRef.dirtyFlags === 0) {
      this.cleanup();
      return;
    }
    if (!this.zonelessEnabled && this.appRef.dirtyFlags & 7) {
      this.appRef.dirtyFlags |= 1;
    }
    const task = this.taskService.add();
    try {
      this.ngZone.run(() => {
        this.runningTick = true;
        this.appRef._tick();
      }, void 0, this.schedulerTickApplyArgs);
    } catch (e) {
      this.taskService.remove(task);
      this.applicationErrorHandler(e);
    } finally {
      this.cleanup();
    }
    this.useMicrotaskScheduler = true;
    scheduleCallbackWithMicrotask(() => {
      this.useMicrotaskScheduler = false;
      this.taskService.remove(task);
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.cleanup();
  }
  cleanup() {
    var _a2;
    this.runningTick = false;
    (_a2 = this.cancelScheduledCallback) == null ? void 0 : _a2.call(this);
    this.cancelScheduledCallback = null;
    if (this.pendingRenderTaskId !== null) {
      const taskId = this.pendingRenderTaskId;
      this.pendingRenderTaskId = null;
      this.taskService.remove(taskId);
    }
  }
};
__publicField(_ChangeDetectionSchedulerImpl, "\u0275fac", function ChangeDetectionSchedulerImpl_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ChangeDetectionSchedulerImpl)();
});
__publicField(_ChangeDetectionSchedulerImpl, "\u0275prov", /* @__PURE__ */ (0, import_root_effect_scheduler.\u0275\u0275defineInjectable)({ token: _ChangeDetectionSchedulerImpl, factory: _ChangeDetectionSchedulerImpl.\u0275fac, providedIn: "root" }));
let ChangeDetectionSchedulerImpl = _ChangeDetectionSchedulerImpl;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], () => [], null);
})();
function provideZonelessChangeDetection() {
  performanceMarkFeature("NgZoneless");
  if ((typeof ngDevMode === "undefined" || ngDevMode) && typeof Zone !== "undefined" && Zone) {
    const message = (0, import_root_effect_scheduler.formatRuntimeError)(914, `The application is using zoneless change detection, but is still loading Zone.js. Consider removing Zone.js to get the full benefits of zoneless. In applications using the Angular CLI, Zone.js is typically included in the "polyfills" section of the angular.json file.`);
    console.warn(message);
  }
  return (0, import_root_effect_scheduler.makeEnvironmentProviders)([
    { provide: import_root_effect_scheduler.ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl },
    { provide: NgZone, useClass: NoopNgZone },
    { provide: import_root_effect_scheduler.ZONELESS_ENABLED, useValue: true },
    { provide: import_root_effect_scheduler.SCHEDULE_IN_ROOT_ZONE, useValue: false },
    typeof ngDevMode === "undefined" || ngDevMode ? [{ provide: import_root_effect_scheduler.PROVIDED_ZONELESS, useValue: true }] : []
  ]);
}
function getGlobalLocale() {
  if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode && typeof goog !== "undefined" && goog.LOCALE !== "en") {
    return goog.LOCALE;
  } else {
    return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
  }
}
const LOCALE_ID = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "LocaleId" : "", {
  providedIn: "root",
  factory: () => (0, import_root_effect_scheduler.inject)(LOCALE_ID, { optional: true, skipSelf: true }) || getGlobalLocale()
});
const DEFAULT_CURRENCY_CODE = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "DefaultCurrencyCode" : "", {
  providedIn: "root",
  factory: () => USD_CURRENCY_CODE
});
const TRANSLATIONS = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "Translations" : "");
const TRANSLATIONS_FORMAT = new import_root_effect_scheduler.InjectionToken(ngDevMode ? "TranslationsFormat" : "");
var MissingTranslationStrategy;
(function(MissingTranslationStrategy2) {
  MissingTranslationStrategy2[MissingTranslationStrategy2["Error"] = 0] = "Error";
  MissingTranslationStrategy2[MissingTranslationStrategy2["Warning"] = 1] = "Warning";
  MissingTranslationStrategy2[MissingTranslationStrategy2["Ignore"] = 2] = "Ignore";
})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
class DebugEventListener {
  constructor(name, callback) {
    __publicField(this, "name");
    __publicField(this, "callback");
    this.name = name;
    this.callback = callback;
  }
}
function asNativeElements(debugEls) {
  return debugEls.map((el) => el.nativeElement);
}
class DebugNode {
  constructor(nativeNode) {
    /**
     * The underlying DOM node.
     */
    __publicField(this, "nativeNode");
    this.nativeNode = nativeNode;
  }
  /**
   * The `DebugElement` parent. Will be `null` if this is the root element.
   */
  get parent() {
    const parent = this.nativeNode.parentNode;
    return parent ? new DebugElement(parent) : null;
  }
  /**
   * The host dependency injector. For example, the root element's component instance injector.
   */
  get injector() {
    return getInjector(this.nativeNode);
  }
  /**
   * The element's own component instance, if it has one.
   */
  get componentInstance() {
    const nativeElement = this.nativeNode;
    return nativeElement && (getComponent(nativeElement) || getOwningComponent(nativeElement));
  }
  /**
   * An object that provides parent context for this element. Often an ancestor component instance
   * that governs this element.
   *
   * When an element is repeated within *ngFor, the context is an `NgForOf` whose `$implicit`
   * property is the value of the row instance value. For example, the `hero` in `*ngFor="let hero
   * of heroes"`.
   */
  get context() {
    return getComponent(this.nativeNode) || getContext(this.nativeNode);
  }
  /**
   * The callbacks attached to the component's @Output properties and/or the element's event
   * properties.
   */
  get listeners() {
    return getListeners(this.nativeNode).filter((listener) => listener.type === "dom");
  }
  /**
   * Dictionary of objects associated with template local variables (e.g. #foo), keyed by the local
   * variable name.
   */
  get references() {
    return getLocalRefs(this.nativeNode);
  }
  /**
   * This component's injector lookup tokens. Includes the component itself plus the tokens that the
   * component lists in its providers metadata.
   */
  get providerTokens() {
    return getInjectionTokens(this.nativeNode);
  }
}
class DebugElement extends DebugNode {
  constructor(nativeNode) {
    ngDevMode && (0, import_root_effect_scheduler.assertDomNode)(nativeNode);
    super(nativeNode);
  }
  /**
   * The underlying DOM element at the root of the component.
   */
  get nativeElement() {
    return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
  }
  /**
   * The element tag name, if it is an element.
   */
  get name() {
    const context = getLContext(this.nativeNode);
    const lView = context ? context.lView : null;
    if (lView !== null) {
      const tData = lView[import_root_effect_scheduler.TVIEW].data;
      const tNode = tData[context.nodeIndex];
      return tNode.value;
    } else {
      return this.nativeNode.nodeName;
    }
  }
  /**
   *  Gets a map of property names to property values for an element.
   *
   *  This map includes:
   *  - Regular property bindings (e.g. `[id]="id"`)
   *  - Host property bindings (e.g. `host: { '[id]': "id" }`)
   *  - Interpolated property bindings (e.g. `id="{{ value }}")
   *
   *  It does not include:
   *  - input property bindings (e.g. `[myCustomInput]="value"`)
   *  - attribute bindings (e.g. `[attr.role]="menu"`)
   */
  get properties() {
    const context = getLContext(this.nativeNode);
    const lView = context ? context.lView : null;
    if (lView === null) {
      return {};
    }
    const tData = lView[import_root_effect_scheduler.TVIEW].data;
    const tNode = tData[context.nodeIndex];
    const properties = {};
    copyDomProperties(this.nativeElement, properties);
    collectPropertyBindings(properties, tNode, lView, tData);
    return properties;
  }
  /**
   *  A map of attribute names to attribute values for an element.
   */
  // TODO: replace null by undefined in the return type
  get attributes() {
    const attributes = {};
    const element = this.nativeElement;
    if (!element) {
      return attributes;
    }
    const context = getLContext(element);
    const lView = context ? context.lView : null;
    if (lView === null) {
      return {};
    }
    const tNodeAttrs = lView[import_root_effect_scheduler.TVIEW].data[context.nodeIndex].attrs;
    const lowercaseTNodeAttrs = [];
    if (tNodeAttrs) {
      let i = 0;
      while (i < tNodeAttrs.length) {
        const attrName = tNodeAttrs[i];
        if (typeof attrName !== "string")
          break;
        const attrValue = tNodeAttrs[i + 1];
        attributes[attrName] = attrValue;
        lowercaseTNodeAttrs.push(attrName.toLowerCase());
        i += 2;
      }
    }
    for (const attr of element.attributes) {
      if (!lowercaseTNodeAttrs.includes(attr.name)) {
        attributes[attr.name] = attr.value;
      }
    }
    return attributes;
  }
  /**
   * The inline styles of the DOM element.
   */
  // TODO: replace null by undefined in the return type
  get styles() {
    var _a2;
    const element = this.nativeElement;
    return (_a2 = element == null ? void 0 : element.style) != null ? _a2 : {};
  }
  /**
   * A map containing the class names on the element as keys.
   *
   * This map is derived from the `className` property of the DOM element.
   *
   * Note: The values of this object will always be `true`. The class key will not appear in the KV
   * object if it does not exist on the element.
   *
   * @see [Element.className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className)
   */
  get classes() {
    const result = {};
    const element = this.nativeElement;
    const className = element.className;
    const classes = typeof className !== "string" ? className.baseVal.split(" ") : className.split(" ");
    classes.forEach((value) => result[value] = true);
    return result;
  }
  /**
   * The `childNodes` of the DOM element as a `DebugNode` array.
   *
   * @see [Node.childNodes](https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes)
   */
  get childNodes() {
    const childNodes = this.nativeNode.childNodes;
    const children = [];
    for (let i = 0; i < childNodes.length; i++) {
      const element = childNodes[i];
      children.push(getDebugNode(element));
    }
    return children;
  }
  /**
   * The immediate `DebugElement` children. Walk the tree by descending through `children`.
   */
  get children() {
    const nativeElement = this.nativeElement;
    if (!nativeElement)
      return [];
    const childNodes = nativeElement.children;
    const children = [];
    for (let i = 0; i < childNodes.length; i++) {
      const element = childNodes[i];
      children.push(getDebugNode(element));
    }
    return children;
  }
  /**
   * @returns the first `DebugElement` that matches the predicate at any depth in the subtree.
   */
  query(predicate) {
    const results = this.queryAll(predicate);
    return results[0] || null;
  }
  /**
   * @returns All `DebugElement` matches for the predicate at any depth in the subtree.
   */
  queryAll(predicate) {
    const matches = [];
    _queryAll(this, predicate, matches, true);
    return matches;
  }
  /**
   * @returns All `DebugNode` matches for the predicate at any depth in the subtree.
   */
  queryAllNodes(predicate) {
    const matches = [];
    _queryAll(this, predicate, matches, false);
    return matches;
  }
  /**
   * Triggers the event by its name if there is a corresponding listener in the element's
   * `listeners` collection.
   *
   * If the event lacks a listener or there's some other problem, consider
   * calling `nativeElement.dispatchEvent(eventObject)`.
   *
   * @param eventName The name of the event to trigger
   * @param eventObj The _event object_ expected by the handler
   *
   * @see [Testing components scenarios](guide/testing/components-scenarios#trigger-event-handler)
   */
  triggerEventHandler(eventName, eventObj) {
    const node = this.nativeNode;
    const invokedListeners = [];
    this.listeners.forEach((listener) => {
      if (listener.name === eventName) {
        const callback = listener.callback;
        callback.call(node, eventObj);
        invokedListeners.push(callback);
      }
    });
    if (typeof node.eventListeners === "function") {
      node.eventListeners(eventName).forEach((listener) => {
        if (listener.toString().indexOf("__ngUnwrap__") !== -1) {
          const unwrappedListener = listener("__ngUnwrap__");
          return invokedListeners.indexOf(unwrappedListener) === -1 && unwrappedListener.call(node, eventObj);
        }
      });
    }
  }
}
function copyDomProperties(element, properties) {
  if (element) {
    let obj = Object.getPrototypeOf(element);
    const NodePrototype = Node.prototype;
    while (obj !== null && obj !== NodePrototype) {
      const descriptors = Object.getOwnPropertyDescriptors(obj);
      for (let key in descriptors) {
        if (!key.startsWith("__") && !key.startsWith("on")) {
          const value = element[key];
          if (isPrimitiveValue(value)) {
            properties[key] = value;
          }
        }
      }
      obj = Object.getPrototypeOf(obj);
    }
  }
}
function isPrimitiveValue(value) {
  return typeof value === "string" || typeof value === "boolean" || typeof value === "number" || value === null;
}
function _queryAll(parentElement, predicate, matches, elementsOnly) {
  const context = getLContext(parentElement.nativeNode);
  const lView = context ? context.lView : null;
  if (lView !== null) {
    const parentTNode = lView[import_root_effect_scheduler.TVIEW].data[context.nodeIndex];
    _queryNodeChildren(parentTNode, lView, predicate, matches, elementsOnly, parentElement.nativeNode);
  } else {
    _queryNativeNodeDescendants(parentElement.nativeNode, predicate, matches, elementsOnly);
  }
}
function _queryNodeChildren(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
  ngDevMode && (0, import_root_effect_scheduler.assertTNodeForLView)(tNode, lView);
  const nativeNode = (0, import_root_effect_scheduler.getNativeByTNodeOrNull)(tNode, lView);
  if (tNode.type & (3 | 8)) {
    _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
    if ((0, import_root_effect_scheduler.isComponentHost)(tNode)) {
      const componentView = (0, import_root_effect_scheduler.getComponentLViewByIndex)(tNode.index, lView);
      if (componentView && componentView[import_root_effect_scheduler.TVIEW].firstChild) {
        _queryNodeChildren(componentView[import_root_effect_scheduler.TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else {
      if (tNode.child) {
        _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
      }
      nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);
    }
    const nodeOrContainer = lView[tNode.index];
    if ((0, import_root_effect_scheduler.isLContainer)(nodeOrContainer)) {
      _queryNodeChildrenInContainer(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
    }
  } else if (tNode.type & 4) {
    const lContainer = lView[tNode.index];
    _addQueryMatch(lContainer[import_root_effect_scheduler.NATIVE], predicate, matches, elementsOnly, rootNativeNode);
    _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode);
  } else if (tNode.type & 16) {
    const componentView = lView[import_root_effect_scheduler.DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[import_root_effect_scheduler.T_HOST];
    const head = componentHost.projection[tNode.projection];
    if (Array.isArray(head)) {
      for (let nativeNode2 of head) {
        _addQueryMatch(nativeNode2, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else if (head) {
      const nextLView = componentView[import_root_effect_scheduler.PARENT];
      const nextTNode = nextLView[import_root_effect_scheduler.TVIEW].data[head.index];
      _queryNodeChildren(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);
    }
  } else if (tNode.child) {
    _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
  }
  if (rootNativeNode !== nativeNode) {
    const nextTNode = tNode.flags & 2 ? tNode.projectionNext : tNode.next;
    if (nextTNode) {
      _queryNodeChildren(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
    }
  }
}
function _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
  for (let i = import_root_effect_scheduler.CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const childView = lContainer[i];
    const firstChild = childView[import_root_effect_scheduler.TVIEW].firstChild;
    if (firstChild) {
      _queryNodeChildren(firstChild, childView, predicate, matches, elementsOnly, rootNativeNode);
    }
  }
}
function _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
  if (rootNativeNode !== nativeNode) {
    const debugNode = getDebugNode(nativeNode);
    if (!debugNode) {
      return;
    }
    if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
      matches.push(debugNode);
    } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
      matches.push(debugNode);
    }
  }
}
function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
  const nodes = parentNode.childNodes;
  const length = nodes.length;
  for (let i = 0; i < length; i++) {
    const node = nodes[i];
    const debugNode = getDebugNode(node);
    if (debugNode) {
      if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      }
      _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);
    }
  }
}
function collectPropertyBindings(properties, tNode, lView, tData) {
  let bindingIndexes = tNode.propertyBindings;
  if (bindingIndexes !== null) {
    for (let i = 0; i < bindingIndexes.length; i++) {
      const bindingIndex = bindingIndexes[i];
      const propMetadata = tData[bindingIndex];
      const metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);
      const propertyName = metadataParts[0];
      if (metadataParts.length > 1) {
        let value = metadataParts[1];
        for (let j = 1; j < metadataParts.length - 1; j++) {
          value += (0, import_root_effect_scheduler.renderStringify)(lView[bindingIndex + j - 1]) + metadataParts[j + 1];
        }
        properties[propertyName] = value;
      } else {
        properties[propertyName] = lView[bindingIndex];
      }
    }
  }
}
const NG_DEBUG_PROPERTY = "__ng_debug__";
function getDebugNode(nativeNode) {
  if (nativeNode instanceof Node) {
    if (!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)) {
      nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement(nativeNode) : new DebugNode(nativeNode);
    }
    return nativeNode[NG_DEBUG_PROPERTY];
  }
  return null;
}
