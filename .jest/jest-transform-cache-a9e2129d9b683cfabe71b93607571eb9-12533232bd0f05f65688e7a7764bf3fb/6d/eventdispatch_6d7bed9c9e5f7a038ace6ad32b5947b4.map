{
  "version": 3,
  "sources": ["/Users/cmackey/Documents/midwest.mackey/midwest-mackey-website/node_modules/@angular/core/fesm2022/primitives/event-dispatch.mjs"],
  "sourcesContent": ["/**\n * @license Angular v20.3.16\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { Attribute } from '../attribute.mjs';\n\n/** All properties that are used by jsaction. */\nconst Property = {\n    /**\n     * The parsed value of the jsaction attribute is stored in this\n     * property on the DOM node. The parsed value is an Object. The\n     * property names of the object are the events; the values are the\n     * names of the actions. This property is attached even on nodes\n     * that don't have a jsaction attribute as an optimization, because\n     * property lookup is faster than attribute access.\n     */\n    JSACTION: '__jsaction',\n    /**\n     * The owner property references an a logical owner for a DOM node. JSAction\n     * will follow this reference instead of parentNode when traversing the DOM\n     * to find jsaction attributes. This allows overlaying a logical structure\n     * over a document where the DOM structure can't reflect that structure.\n     */\n    OWNER: '__owner',\n};\n\n/**\n * Map from jsaction annotation to a parsed map from event name to action name.\n */\nconst parseCache = {};\n/**\n * Reads the jsaction parser cache from the given DOM Element.\n */\nfunction get(element) {\n    return element[Property.JSACTION];\n}\n/**\n * Reads the jsaction parser cache for the given DOM element. If no cache is yet present,\n * creates an empty one.\n */\nfunction getDefaulted(element) {\n    const cache = get(element) ?? {};\n    set(element, cache);\n    return cache;\n}\n/**\n * Writes the jsaction parser cache to the given DOM Element.\n */\nfunction set(element, actionMap) {\n    element[Property.JSACTION] = actionMap;\n}\n/**\n * Looks up the parsed action map from the source jsaction attribute value.\n *\n * @param text Unparsed jsaction attribute value.\n * @return Parsed jsaction attribute value, if already present in the cache.\n */\nfunction getParsed(text) {\n    return parseCache[text];\n}\n/**\n * Inserts the parse result for the given source jsaction value into the cache.\n *\n * @param text Unparsed jsaction attribute value.\n * @param parsed Attribute value parsed into the action map.\n */\nfunction setParsed(text, parsed) {\n    parseCache[text] = parsed;\n}\n\n/*\n * Names of events that are special to jsaction. These are not all\n * event types that are legal to use in either HTML or the addEvent()\n * API, but these are the ones that are treated specially. All other\n * DOM events can be used in either addEvent() or in the value of the\n * jsaction attribute. Beware of browser specific events or events\n * that don't bubble though: If they are not mentioned here, then\n * event contract doesn't work around their peculiarities.\n */\nconst EventType = {\n    /**\n     * Mouse middle click, introduced in Chrome 55 and not yet supported on\n     * other browsers.\n     */\n    AUXCLICK: 'auxclick',\n    /**\n     * The change event fired by browsers when the `value` attribute of input,\n     * select, and textarea elements are changed.\n     */\n    CHANGE: 'change',\n    /**\n     * The click event. In addEvent() refers to all click events, in the\n     * jsaction attribute it refers to the unmodified click and Enter/Space\n     * keypress events.  In the latter case, a jsaction click will be triggered,\n     * for accessibility reasons.  See clickmod and clickonly, below.\n     */\n    CLICK: 'click',\n    /**\n     * Specifies the jsaction for a modified click event (i.e. a mouse\n     * click with the modifier key Cmd/Ctrl pressed). This event isn't\n     * separately enabled in addEvent(), because in the DOM, it's just a\n     * click event.\n     */\n    CLICKMOD: 'clickmod',\n    /**\n     * Specifies the jsaction for a click-only event.  Click-only doesn't take\n     * into account the case where an element with focus receives an Enter/Space\n     * keypress.  This event isn't separately enabled in addEvent().\n     */\n    CLICKONLY: 'clickonly',\n    /**\n     * The dblclick event.\n     */\n    DBLCLICK: 'dblclick',\n    /**\n     * Focus doesn't bubble, but you can use it in addEvent() and\n     * jsaction anyway. EventContract does the right thing under the\n     * hood.\n     */\n    FOCUS: 'focus',\n    /**\n     * This event only exists in IE. For addEvent() and jsaction, use\n     * focus instead; EventContract does the right thing even though\n     * focus doesn't bubble.\n     */\n    FOCUSIN: 'focusin',\n    /**\n     * Analog to focus.\n     */\n    BLUR: 'blur',\n    /**\n     * Analog to focusin.\n     */\n    FOCUSOUT: 'focusout',\n    /**\n     * Submit doesn't bubble, so it cannot be used with event\n     * contract. However, the browser helpfully fires a click event on\n     * the submit button of a form (even if the form is not submitted by\n     * a click on the submit button). So you should handle click on the\n     * submit button instead.\n     */\n    SUBMIT: 'submit',\n    /**\n     * The keydown event. In addEvent() and non-click jsaction it represents the\n     * regular DOM keydown event. It represents click actions in non-Gecko\n     * browsers.\n     */\n    KEYDOWN: 'keydown',\n    /**\n     * The keypress event. In addEvent() and non-click jsaction it represents the\n     * regular DOM keypress event. It represents click actions in Gecko browsers.\n     */\n    KEYPRESS: 'keypress',\n    /**\n     * The keyup event. In addEvent() and non-click jsaction it represents the\n     * regular DOM keyup event. It represents click actions in non-Gecko\n     * browsers.\n     */\n    KEYUP: 'keyup',\n    /**\n     * The mouseup event. Can either be used directly or used implicitly to\n     * capture mouseup events. In addEvent(), it represents a regular DOM\n     * mouseup event.\n     */\n    MOUSEUP: 'mouseup',\n    /**\n     * The mousedown event. Can either be used directly or used implicitly to\n     * capture mouseenter events. In addEvent(), it represents a regular DOM\n     * mouseover event.\n     */\n    MOUSEDOWN: 'mousedown',\n    /**\n     * The mouseover event. Can either be used directly or used implicitly to\n     * capture mouseenter events. In addEvent(), it represents a regular DOM\n     * mouseover event.\n     */\n    MOUSEOVER: 'mouseover',\n    /**\n     * The mouseout event. Can either be used directly or used implicitly to\n     * capture mouseover events. In addEvent(), it represents a regular DOM\n     * mouseout event.\n     */\n    MOUSEOUT: 'mouseout',\n    /**\n     * The mouseenter event. Does not bubble and fires individually on each\n     * element being entered within a DOM tree.\n     */\n    MOUSEENTER: 'mouseenter',\n    /**\n     * The mouseleave event. Does not bubble and fires individually on each\n     * element being entered within a DOM tree.\n     */\n    MOUSELEAVE: 'mouseleave',\n    /**\n     * The mousemove event.\n     */\n    MOUSEMOVE: 'mousemove',\n    /**\n     * The pointerup event. Can either be used directly or used implicitly to\n     * capture pointerup events. In addEvent(), it represents a regular DOM\n     * pointerup event.\n     */\n    POINTERUP: 'pointerup',\n    /**\n     * The pointerdown event. Can either be used directly or used implicitly to\n     * capture pointerenter events. In addEvent(), it represents a regular DOM\n     * mouseover event.\n     */\n    POINTERDOWN: 'pointerdown',\n    /**\n     * The pointerover event. Can either be used directly or used implicitly to\n     * capture pointerenter events. In addEvent(), it represents a regular DOM\n     * pointerover event.\n     */\n    POINTEROVER: 'pointerover',\n    /**\n     * The pointerout event. Can either be used directly or used implicitly to\n     * capture pointerover events. In addEvent(), it represents a regular DOM\n     * pointerout event.\n     */\n    POINTEROUT: 'pointerout',\n    /**\n     * The pointerenter event. Does not bubble and fires individually on each\n     * element being entered within a DOM tree.\n     */\n    POINTERENTER: 'pointerenter',\n    /**\n     * The pointerleave event. Does not bubble and fires individually on each\n     * element being entered within a DOM tree.\n     */\n    POINTERLEAVE: 'pointerleave',\n    /**\n     * The pointermove event.\n     */\n    POINTERMOVE: 'pointermove',\n    /**\n     * The pointercancel event.\n     */\n    POINTERCANCEL: 'pointercancel',\n    /**\n     * The gotpointercapture event is fired when\n     * Element.setPointerCapture(pointerId) is called on a mouse input, or\n     * implicitly when a touch input begins.\n     */\n    GOTPOINTERCAPTURE: 'gotpointercapture',\n    /**\n     * The lostpointercapture event is fired when\n     * Element.releasePointerCapture(pointerId) is called, or implicitly after a\n     * touch input ends.\n     */\n    LOSTPOINTERCAPTURE: 'lostpointercapture',\n    /**\n     * The error event. The error event doesn't bubble, but you can use it in\n     * addEvent() and jsaction anyway. EventContract does the right thing under\n     * the hood (except in IE8 which does not use error events).\n     */\n    ERROR: 'error',\n    /**\n     * The load event. The load event doesn't bubble, but you can use it in\n     * addEvent() and jsaction anyway. EventContract does the right thing\n     * under the hood.\n     */\n    LOAD: 'load',\n    /**\n     * The unload event.\n     */\n    UNLOAD: 'unload',\n    /**\n     * The touchstart event. Bubbles, will only ever fire in browsers with\n     * touch support.\n     */\n    TOUCHSTART: 'touchstart',\n    /**\n     * The touchend event. Bubbles, will only ever fire in browsers with\n     * touch support.\n     */\n    TOUCHEND: 'touchend',\n    /**\n     * The touchmove event. Bubbles, will only ever fire in browsers with\n     * touch support.\n     */\n    TOUCHMOVE: 'touchmove',\n    /**\n     * The input event.\n     */\n    INPUT: 'input',\n    /**\n     * The scroll event.\n     */\n    SCROLL: 'scroll',\n    /**\n     * The toggle event. The toggle event doesn't bubble, but you can use it in\n     * addEvent() and jsaction anyway. EventContract does the right thing\n     * under the hood.\n     */\n    TOGGLE: 'toggle',\n    /**\n     * A custom event. The actual custom event type is declared as the 'type'\n     * field in the event details. Supported in Firefox 6+, IE 9+, and all Chrome\n     * versions.\n     *\n     * This is an internal name. Users should use jsaction's fireCustomEvent to\n     * fire custom events instead of relying on this type to create them.\n     */\n    CUSTOM: '_custom',\n};\n/** All event types that do not bubble or capture and need a polyfill. */\nconst MOUSE_SPECIAL_EVENT_TYPES = [\n    EventType.MOUSEENTER,\n    EventType.MOUSELEAVE,\n    'pointerenter',\n    'pointerleave',\n];\n/** All event types that are registered in the bubble phase. */\nconst BUBBLE_EVENT_TYPES = [\n    EventType.CLICK,\n    EventType.DBLCLICK,\n    EventType.FOCUSIN,\n    EventType.FOCUSOUT,\n    EventType.KEYDOWN,\n    EventType.KEYUP,\n    EventType.KEYPRESS,\n    EventType.MOUSEOVER,\n    EventType.MOUSEOUT,\n    EventType.SUBMIT,\n    EventType.TOUCHSTART,\n    EventType.TOUCHEND,\n    EventType.TOUCHMOVE,\n    'touchcancel',\n    'auxclick',\n    'change',\n    'compositionstart',\n    'compositionupdate',\n    'compositionend',\n    'beforeinput',\n    'input',\n    'select',\n    'copy',\n    'cut',\n    'paste',\n    'mousedown',\n    'mouseup',\n    'wheel',\n    'contextmenu',\n    'dragover',\n    'dragenter',\n    'dragleave',\n    'drop',\n    'dragstart',\n    'dragend',\n    'pointerdown',\n    'pointermove',\n    'pointerup',\n    'pointercancel',\n    'pointerover',\n    'pointerout',\n    'gotpointercapture',\n    'lostpointercapture',\n    // Video events.\n    'ended',\n    'loadedmetadata',\n    // Page visibility events.\n    'pagehide',\n    'pageshow',\n    'visibilitychange',\n    // Content visibility events.\n    'beforematch',\n];\n/** All event types that are registered in the capture phase. */\nconst CAPTURE_EVENT_TYPES = [\n    EventType.FOCUS,\n    EventType.BLUR,\n    EventType.ERROR,\n    EventType.LOAD,\n    EventType.TOGGLE,\n];\n/**\n * Whether or not an event type should be registered in the capture phase.\n * @param eventType\n * @returns bool\n */\nconst isCaptureEventType = (eventType) => CAPTURE_EVENT_TYPES.indexOf(eventType) >= 0;\n/** All event types that are registered early.  */\nconst EARLY_EVENT_TYPES = BUBBLE_EVENT_TYPES.concat(CAPTURE_EVENT_TYPES);\n/**\n * Whether or not an event type is registered in the early contract.\n */\nconst isEarlyEventType = (eventType) => EARLY_EVENT_TYPES.indexOf(eventType) >= 0;\n\n/**\n * Gets a browser event type, if it would differ from the JSAction event type.\n */\nfunction getBrowserEventType(eventType) {\n    // Mouseenter and mouseleave events are not handled directly because they\n    // are not available everywhere. In browsers where they are available, they\n    // don't bubble and aren't visible at the container boundary. Instead, we\n    // synthesize the mouseenter and mouseleave events from mouseover and\n    // mouseout events, respectively. Cf. eventcontract.js.\n    if (eventType === EventType.MOUSEENTER) {\n        return EventType.MOUSEOVER;\n    }\n    else if (eventType === EventType.MOUSELEAVE) {\n        return EventType.MOUSEOUT;\n    }\n    else if (eventType === EventType.POINTERENTER) {\n        return EventType.POINTEROVER;\n    }\n    else if (eventType === EventType.POINTERLEAVE) {\n        return EventType.POINTEROUT;\n    }\n    return eventType;\n}\n/**\n * Registers the event handler function with the given DOM element for\n * the given event type.\n *\n * @param element The element.\n * @param eventType The event type.\n * @param handler The handler function to install.\n * @param passive A boolean value that, if `true`, indicates that the function\n *     specified by `handler` will never call `preventDefault()`.\n * @return Information needed to uninstall the event handler eventually.\n */\nfunction addEventListener(element, eventType, handler, passive) {\n    // All event handlers are registered in the bubbling\n    // phase.\n    //\n    // All browsers support focus and blur, but these events only are propagated\n    // in the capture phase. Very legacy browsers do not support focusin or\n    // focusout.\n    //\n    // It would be a bad idea to register all event handlers in the\n    // capture phase because then regular onclick handlers would not be\n    // executed at all on events that trigger a jsaction. That's not\n    // entirely what we want, at least for now.\n    //\n    // Error and load events (i.e. on images) do not bubble so they are also\n    // handled in the capture phase.\n    let capture = false;\n    if (isCaptureEventType(eventType)) {\n        capture = true;\n    }\n    const options = typeof passive === 'boolean' ? { capture, passive } : capture;\n    element.addEventListener(eventType, handler, options);\n    return { eventType, handler, capture, passive };\n}\n/**\n * Removes the event handler for the given event from the element.\n * the given event type.\n *\n * @param element The element.\n * @param info The information needed to deregister the handler, as returned by\n *     addEventListener(), above.\n */\nfunction removeEventListener(element, info) {\n    if (element.removeEventListener) {\n        // It's worth noting that some browser releases have been inconsistent on this, and unless\n        // you have specific reasons otherwise, it's probably wise to use the same values used for\n        // the call to addEventListener() when calling removeEventListener().\n        const options = typeof info.passive === 'boolean' ? { capture: info.capture } : info.capture;\n        element.removeEventListener(info.eventType, info.handler, options);\n        // `detachEvent` is an old DOM API.\n    }\n    else if (element.detachEvent) {\n        // `detachEvent` is an old DOM API.\n        element.detachEvent(`on${info.eventType}`, info.handler);\n    }\n}\n/**\n * Prevents the default action of an event.\n * @param e The event to prevent the default action for.\n */\nfunction preventDefault(e) {\n    e.preventDefault ? e.preventDefault() : (e.returnValue = false);\n}\n/**\n * Whether we are on a Mac. Not pulling in useragent just for this.\n */\nlet isMac = typeof navigator !== 'undefined' && /Macintosh/.test(navigator.userAgent);\n/**\n * Determines and returns whether the given event (which is assumed to be a\n * click event) is a middle click.\n * NOTE: There is not a consistent way to identify middle click\n * http://www.unixpapa.com/js/mouse.html\n */\nfunction isMiddleClick(e) {\n    return (\n    // `which` is an old DOM API.\n    e.which === 2 ||\n        // `which` is an old DOM API.\n        (e.which == null &&\n            // `button` is an old DOM API.\n            e.button === 4) // middle click for IE\n    );\n}\n/**\n * Determines and returns whether the given event (which is assumed\n * to be a click event) is modified. A middle click is considered a modified\n * click to retain the default browser action, which opens a link in a new tab.\n * @param e The event.\n * @return Whether the given event is modified.\n */\nfunction isModifiedClickEvent(e) {\n    return (\n    // `metaKey` is an old DOM API.\n    (isMac && e.metaKey) ||\n        // `ctrlKey` is an old DOM API.\n        (!isMac && e.ctrlKey) ||\n        isMiddleClick(e) ||\n        // `shiftKey` is an old DOM API.\n        e.shiftKey);\n}\n/**\n * Determines whether the event corresponds to a non-bubbling mouse\n * event type (mouseenter, mouseleave, pointerenter, and pointerleave).\n *\n * During mouseover (mouseenter) and pointerover (pointerenter), the\n * relatedTarget is the element being entered from. During mouseout (mouseleave)\n * and pointerout (pointerleave), the relatedTarget is the element being exited\n * to.\n *\n * In both cases, if relatedTarget is outside target, then the corresponding\n * special event has occurred, otherwise it hasn't.\n *\n * @param e The mouseover/mouseout event.\n * @param type The type of the mouse special event.\n * @param element The element on which the jsaction for the\n *     mouseenter/mouseleave event is defined.\n * @return True if the event is a mouseenter/mouseleave event.\n */\nfunction isMouseSpecialEvent(e, type, element) {\n    // `relatedTarget` is an old DOM API.\n    const related = e.relatedTarget;\n    return (((e.type === EventType.MOUSEOVER && type === EventType.MOUSEENTER) ||\n        (e.type === EventType.MOUSEOUT && type === EventType.MOUSELEAVE) ||\n        (e.type === EventType.POINTEROVER && type === EventType.POINTERENTER) ||\n        (e.type === EventType.POINTEROUT && type === EventType.POINTERLEAVE)) &&\n        (!related || (related !== element && !element.contains(related))));\n}\n/**\n * Creates a new EventLike object for a mouseenter/mouseleave event that's\n * derived from the original corresponding mouseover/mouseout event.\n * @param e The event.\n * @param target The element on which the jsaction for the mouseenter/mouseleave\n *     event is defined.\n * @return A modified event-like object copied from the event object passed into\n *     this function.\n */\nfunction createMouseSpecialEvent(e, target) {\n    // We have to create a copy of the event object because we need to mutate\n    // its fields. We do this for the special mouse events because the event\n    // target needs to be retargeted to the action element rather than the real\n    // element (since we are simulating the special mouse events with mouseover/\n    // mouseout).\n    //\n    // Since we're making a copy anyways, we might as well attempt to convert\n    // this event into a pseudo-real mouseenter/mouseleave event by adjusting\n    // its type.\n    //\n    const copy = {};\n    for (const property in e) {\n        if (property === 'srcElement' || property === 'target') {\n            continue;\n        }\n        const key = property;\n        // Making a copy requires iterating through all properties of `Event`.\n        const value = e[key];\n        if (typeof value === 'function') {\n            continue;\n        }\n        // Value should be the expected type, but the value of `key` is not known\n        // statically.\n        copy[key] = value;\n    }\n    if (e.type === EventType.MOUSEOVER) {\n        copy['type'] = EventType.MOUSEENTER;\n    }\n    else if (e.type === EventType.MOUSEOUT) {\n        copy['type'] = EventType.MOUSELEAVE;\n    }\n    else if (e.type === EventType.POINTEROVER) {\n        copy['type'] = EventType.POINTERENTER;\n    }\n    else {\n        copy['type'] = EventType.POINTERLEAVE;\n    }\n    copy['target'] = copy['srcElement'] = target;\n    copy['bubbles'] = false;\n    copy['_originalEvent'] = e;\n    return copy;\n}\n\n/**\n * Whether the user agent is running on iOS.\n */\nconst isIos = typeof navigator !== 'undefined' && /iPhone|iPad|iPod/.test(navigator.userAgent);\n/**\n * A class representing a container node and all the event handlers\n * installed on it. Used so that handlers can be cleaned up if the\n * container is removed from the contract.\n */\nclass EventContractContainer {\n    element;\n    /**\n     * Array of event handlers and their corresponding event types that are\n     * installed on this container.\n     *\n     */\n    handlerInfos = [];\n    /**\n     * @param element The container Element.\n     */\n    constructor(element) {\n        this.element = element;\n    }\n    /**\n     * Installs the provided installer on the element owned by this container,\n     * and maintains a reference to resulting handler in order to remove it\n     * later if desired.\n     */\n    addEventListener(eventType, getHandler, passive) {\n        // In iOS, event bubbling doesn't happen automatically in any DOM element,\n        // unless it has an onclick attribute or DOM event handler attached to it.\n        // This breaks JsAction in some cases. See \"Making Elements Clickable\"\n        // section at http://goo.gl/2VoGnB.\n        //\n        // A workaround for this issue is to change the CSS cursor style to 'pointer'\n        // for the container element, which magically turns on event bubbling. This\n        // solution is described in the comments section at http://goo.gl/6pEO1z.\n        //\n        // We use a navigator.userAgent check here as this problem is present both\n        // on Mobile Safari and thin WebKit wrappers, such as Chrome for iOS.\n        if (isIos) {\n            this.element.style.cursor = 'pointer';\n        }\n        this.handlerInfos.push(addEventListener(this.element, eventType, getHandler(this.element), passive));\n    }\n    /**\n     * Removes all the handlers installed on this container.\n     */\n    cleanUp() {\n        for (let i = 0; i < this.handlerInfos.length; i++) {\n            removeEventListener(this.element, this.handlerInfos[i]);\n        }\n        this.handlerInfos = [];\n    }\n}\n\nconst Char = {\n    /**\n     * The separator between the namespace and the action name in the\n     * jsaction attribute value.\n     */\n    NAMESPACE_ACTION_SEPARATOR: '.',\n    /**\n     * The separator between the event name and action in the jsaction\n     * attribute value.\n     */\n    EVENT_ACTION_SEPARATOR: ':',\n};\n\n/** Added for readability when accessing stable property names. */\nfunction getEventType(eventInfo) {\n    return eventInfo.eventType;\n}\n/** Added for readability when accessing stable property names. */\nfunction setEventType(eventInfo, eventType) {\n    eventInfo.eventType = eventType;\n}\n/** Added for readability when accessing stable property names. */\nfunction getEvent(eventInfo) {\n    return eventInfo.event;\n}\n/** Added for readability when accessing stable property names. */\nfunction setEvent(eventInfo, event) {\n    eventInfo.event = event;\n}\n/** Added for readability when accessing stable property names. */\nfunction getTargetElement(eventInfo) {\n    return eventInfo.targetElement;\n}\n/** Added for readability when accessing stable property names. */\nfunction setTargetElement(eventInfo, targetElement) {\n    eventInfo.targetElement = targetElement;\n}\n/** Added for readability when accessing stable property names. */\nfunction getContainer(eventInfo) {\n    return eventInfo.eic;\n}\n/** Added for readability when accessing stable property names. */\nfunction setContainer(eventInfo, container) {\n    eventInfo.eic = container;\n}\n/** Added for readability when accessing stable property names. */\nfunction getTimestamp(eventInfo) {\n    return eventInfo.timeStamp;\n}\n/** Added for readability when accessing stable property names. */\nfunction setTimestamp(eventInfo, timestamp) {\n    eventInfo.timeStamp = timestamp;\n}\n/** Added for readability when accessing stable property names. */\nfunction getAction(eventInfo) {\n    return eventInfo.eia;\n}\n/** Added for readability when accessing stable property names. */\nfunction setAction(eventInfo, actionName, actionElement) {\n    eventInfo.eia = [actionName, actionElement];\n}\n/** Added for readability when accessing stable property names. */\nfunction unsetAction(eventInfo) {\n    eventInfo.eia = undefined;\n}\n/** Added for readability when accessing stable property names. */\nfunction getActionElement(actionInfo) {\n    return actionInfo[1];\n}\n/** Added for readability when accessing stable property names. */\nfunction getIsReplay(eventInfo) {\n    return eventInfo.eirp;\n}\n/** Added for readability when accessing stable property names. */\nfunction setIsReplay(eventInfo, replay) {\n    eventInfo.eirp = replay;\n}\n/** Added for readability when accessing stable property names. */\nfunction getResolved(eventInfo) {\n    return eventInfo.eir;\n}\n/** Added for readability when accessing stable property names. */\nfunction setResolved(eventInfo, resolved) {\n    eventInfo.eir = resolved;\n}\n/** Clones an `EventInfo` */\nfunction cloneEventInfo(eventInfo) {\n    return {\n        eventType: eventInfo.eventType,\n        event: eventInfo.event,\n        targetElement: eventInfo.targetElement,\n        eic: eventInfo.eic,\n        eia: eventInfo.eia,\n        timeStamp: eventInfo.timeStamp,\n        eirp: eventInfo.eirp,\n        eiack: eventInfo.eiack,\n        eir: eventInfo.eir,\n    };\n}\n/**\n * Utility function for creating an `EventInfo`.\n *\n * This can be used from code-size sensitive compilation units, as taking\n * parameters vs. an `Object` literal reduces code size.\n */\nfunction createEventInfoFromParameters(eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey) {\n    return {\n        eventType,\n        event,\n        targetElement,\n        eic: container,\n        timeStamp: timestamp,\n        eia: action,\n        eirp: isReplay,\n        eiack: a11yClickKey,\n    };\n}\n/**\n * Utility class around an `EventInfo`.\n *\n * This should be used in compilation units that are less sensitive to code\n * size.\n */\nclass EventInfoWrapper {\n    eventInfo;\n    constructor(eventInfo) {\n        this.eventInfo = eventInfo;\n    }\n    getEventType() {\n        return getEventType(this.eventInfo);\n    }\n    setEventType(eventType) {\n        setEventType(this.eventInfo, eventType);\n    }\n    getEvent() {\n        return getEvent(this.eventInfo);\n    }\n    setEvent(event) {\n        setEvent(this.eventInfo, event);\n    }\n    getTargetElement() {\n        return getTargetElement(this.eventInfo);\n    }\n    setTargetElement(targetElement) {\n        setTargetElement(this.eventInfo, targetElement);\n    }\n    getContainer() {\n        return getContainer(this.eventInfo);\n    }\n    setContainer(container) {\n        setContainer(this.eventInfo, container);\n    }\n    getTimestamp() {\n        return getTimestamp(this.eventInfo);\n    }\n    setTimestamp(timestamp) {\n        setTimestamp(this.eventInfo, timestamp);\n    }\n    getAction() {\n        const action = getAction(this.eventInfo);\n        if (!action)\n            return undefined;\n        return {\n            name: action[0],\n            element: action[1],\n        };\n    }\n    setAction(action) {\n        if (!action) {\n            unsetAction(this.eventInfo);\n            return;\n        }\n        setAction(this.eventInfo, action.name, action.element);\n    }\n    getIsReplay() {\n        return getIsReplay(this.eventInfo);\n    }\n    setIsReplay(replay) {\n        setIsReplay(this.eventInfo, replay);\n    }\n    getResolved() {\n        return getResolved(this.eventInfo);\n    }\n    setResolved(resolved) {\n        setResolved(this.eventInfo, resolved);\n    }\n    clone() {\n        return new EventInfoWrapper(cloneEventInfo(this.eventInfo));\n    }\n}\n\n/**\n * Since maps from event to action are immutable we can use a single map\n * to represent the empty map.\n */\nconst EMPTY_ACTION_MAP = {};\n/**\n * This regular expression matches a semicolon.\n */\nconst REGEXP_SEMICOLON = /\\s*;\\s*/;\n/** If no event type is defined, defaults to `click`. */\nconst DEFAULT_EVENT_TYPE = EventType.CLICK;\n/** Resolves actions for Events. */\nclass ActionResolver {\n    a11yClickSupport = false;\n    clickModSupport = true;\n    syntheticMouseEventSupport;\n    updateEventInfoForA11yClick = undefined;\n    preventDefaultForA11yClick = undefined;\n    populateClickOnlyAction = undefined;\n    constructor({ syntheticMouseEventSupport = false, clickModSupport = true, } = {}) {\n        this.syntheticMouseEventSupport = syntheticMouseEventSupport;\n        this.clickModSupport = clickModSupport;\n    }\n    resolveEventType(eventInfo) {\n        // We distinguish modified and plain clicks in order to support the\n        // default browser behavior of modified clicks on links; usually to\n        // open the URL of the link in new tab or new window on ctrl/cmd\n        // click. A DOM 'click' event is mapped to the jsaction 'click'\n        // event iff there is no modifier present on the event. If there is\n        // a modifier, it's mapped to 'clickmod' instead.\n        //\n        // It's allowed to omit the event in the jsaction attribute. In that\n        // case, 'click' is assumed. Thus the following two are equivalent:\n        //\n        //   <a href=\"someurl\" jsaction=\"gna.fu\">\n        //   <a href=\"someurl\" jsaction=\"click:gna.fu\">\n        //\n        // For unmodified clicks, EventContract invokes the jsaction\n        // 'gna.fu'. For modified clicks, EventContract won't find a\n        // suitable action and leave the event to be handled by the\n        // browser.\n        //\n        // In order to also invoke a jsaction handler for a modifier click,\n        // 'clickmod' needs to be used:\n        //\n        //   <a href=\"someurl\" jsaction=\"clickmod:gna.fu\">\n        //\n        // EventContract invokes the jsaction 'gna.fu' for modified\n        // clicks. Unmodified clicks are left to the browser.\n        //\n        // In order to set up the event contract to handle both clickonly and\n        // clickmod, only addEvent(EventType.CLICK) is necessary.\n        //\n        // In order to set up the event contract to handle click,\n        // addEvent() is necessary for CLICK, KEYDOWN, and KEYPRESS event types.  If\n        // a11y click support is enabled, addEvent() will set up the appropriate key\n        // event handler automatically.\n        if (this.clickModSupport &&\n            getEventType(eventInfo) === EventType.CLICK &&\n            isModifiedClickEvent(getEvent(eventInfo))) {\n            setEventType(eventInfo, EventType.CLICKMOD);\n        }\n        else if (this.a11yClickSupport) {\n            this.updateEventInfoForA11yClick(eventInfo);\n        }\n    }\n    resolveAction(eventInfo) {\n        if (getResolved(eventInfo)) {\n            return;\n        }\n        this.populateAction(eventInfo, getTargetElement(eventInfo));\n        setResolved(eventInfo, true);\n    }\n    resolveParentAction(eventInfo) {\n        const action = getAction(eventInfo);\n        const actionElement = action && getActionElement(action);\n        unsetAction(eventInfo);\n        const parentNode = actionElement && this.getParentNode(actionElement);\n        if (!parentNode) {\n            return;\n        }\n        this.populateAction(eventInfo, parentNode);\n    }\n    /**\n     * Searches for a jsaction that the DOM event maps to and creates an\n     * object containing event information used for dispatching by\n     * jsaction.Dispatcher. This method populates the `action` and `actionElement`\n     * fields of the EventInfo object passed in by finding the first\n     * jsaction attribute above the target Node of the event, and below\n     * the container Node, that specifies a jsaction for the event\n     * type. If no such jsaction is found, then action is undefined.\n     *\n     * @param eventInfo `EventInfo` to set `action` and `actionElement` if an\n     *    action is found on any `Element` in the path of the `Event`.\n     */\n    populateAction(eventInfo, currentTarget) {\n        let actionElement = currentTarget;\n        while (actionElement && actionElement !== getContainer(eventInfo)) {\n            if (actionElement.nodeType === Node.ELEMENT_NODE) {\n                this.populateActionOnElement(actionElement, eventInfo);\n            }\n            if (getAction(eventInfo)) {\n                // An event is handled by at most one jsaction. Thus we stop at the\n                // first matching jsaction specified in a jsaction attribute up the\n                // ancestor chain of the event target node.\n                break;\n            }\n            actionElement = this.getParentNode(actionElement);\n        }\n        const action = getAction(eventInfo);\n        if (!action) {\n            // No action found.\n            return;\n        }\n        if (this.a11yClickSupport) {\n            this.preventDefaultForA11yClick(eventInfo);\n        }\n        // We attempt to handle the mouseenter/mouseleave events here by\n        // detecting whether the mouseover/mouseout events correspond to\n        // entering/leaving an element.\n        if (this.syntheticMouseEventSupport) {\n            if (getEventType(eventInfo) === EventType.MOUSEENTER ||\n                getEventType(eventInfo) === EventType.MOUSELEAVE ||\n                getEventType(eventInfo) === EventType.POINTERENTER ||\n                getEventType(eventInfo) === EventType.POINTERLEAVE) {\n                // We attempt to handle the mouseenter/mouseleave events here by\n                // detecting whether the mouseover/mouseout events correspond to\n                // entering/leaving an element.\n                if (isMouseSpecialEvent(getEvent(eventInfo), getEventType(eventInfo), getActionElement(action))) {\n                    // If both mouseover/mouseout and mouseenter/mouseleave events are\n                    // enabled, two separate handlers for mouseover/mouseout are\n                    // registered. Both handlers will see the same event instance\n                    // so we create a copy to avoid interfering with the dispatching of\n                    // the mouseover/mouseout event.\n                    const copiedEvent = createMouseSpecialEvent(getEvent(eventInfo), getActionElement(action));\n                    setEvent(eventInfo, copiedEvent);\n                    // Since the mouseenter/mouseleave events do not bubble, the target\n                    // of the event is technically the `actionElement` (the node with the\n                    // `jsaction` attribute)\n                    setTargetElement(eventInfo, getActionElement(action));\n                }\n                else {\n                    unsetAction(eventInfo);\n                }\n            }\n        }\n    }\n    /**\n     * Walk to the parent node, unless the node has a different owner in\n     * which case we walk to the owner. Attempt to walk to host of a\n     * shadow root if needed.\n     */\n    getParentNode(element) {\n        const owner = element[Property.OWNER];\n        if (owner) {\n            return owner;\n        }\n        const parentNode = element.parentNode;\n        if (parentNode?.nodeName === '#document-fragment') {\n            return parentNode?.host ?? null;\n        }\n        return parentNode;\n    }\n    /**\n     * Accesses the jsaction map on a node and retrieves the name of the\n     * action the given event is mapped to, if any. It parses the\n     * attribute value and stores it in a property on the node for\n     * subsequent retrieval without re-parsing and re-accessing the\n     * attribute.\n     *\n     * @param actionElement The DOM node to retrieve the jsaction map from.\n     * @param eventInfo `EventInfo` to set `action` and `actionElement` if an\n     *    action is found on the `actionElement`.\n     */\n    populateActionOnElement(actionElement, eventInfo) {\n        const actionMap = this.parseActions(actionElement);\n        const actionName = actionMap[getEventType(eventInfo)];\n        if (actionName !== undefined) {\n            setAction(eventInfo, actionName, actionElement);\n        }\n        if (this.a11yClickSupport) {\n            this.populateClickOnlyAction(actionElement, eventInfo, actionMap);\n        }\n    }\n    /**\n     * Parses and caches an element's jsaction element into a map.\n     *\n     * This is primarily for internal use.\n     *\n     * @param actionElement The DOM node to retrieve the jsaction map from.\n     * @return Map from event to qualified name of the jsaction bound to it.\n     */\n    parseActions(actionElement) {\n        let actionMap = get(actionElement);\n        if (!actionMap) {\n            const jsactionAttribute = actionElement.getAttribute(Attribute.JSACTION);\n            if (!jsactionAttribute) {\n                actionMap = EMPTY_ACTION_MAP;\n                set(actionElement, actionMap);\n            }\n            else {\n                actionMap = getParsed(jsactionAttribute);\n                if (!actionMap) {\n                    actionMap = {};\n                    const values = jsactionAttribute.split(REGEXP_SEMICOLON);\n                    for (let idx = 0; idx < values.length; idx++) {\n                        const value = values[idx];\n                        if (!value) {\n                            continue;\n                        }\n                        const colon = value.indexOf(Char.EVENT_ACTION_SEPARATOR);\n                        const hasColon = colon !== -1;\n                        const type = hasColon ? value.substr(0, colon).trim() : DEFAULT_EVENT_TYPE;\n                        const action = hasColon ? value.substr(colon + 1).trim() : value;\n                        actionMap[type] = action;\n                    }\n                    setParsed(jsactionAttribute, actionMap);\n                }\n                set(actionElement, actionMap);\n            }\n        }\n        return actionMap;\n    }\n    addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {\n        this.a11yClickSupport = true;\n        this.updateEventInfoForA11yClick = updateEventInfoForA11yClick;\n        this.preventDefaultForA11yClick = preventDefaultForA11yClick;\n        this.populateClickOnlyAction = populateClickOnlyAction;\n    }\n}\n\n/**\n * @fileoverview An enum to control who can call certain jsaction APIs.\n */\nvar Restriction;\n(function (Restriction) {\n    Restriction[Restriction[\"I_AM_THE_JSACTION_FRAMEWORK\"] = 0] = \"I_AM_THE_JSACTION_FRAMEWORK\";\n})(Restriction || (Restriction = {}));\n\n/**\n * Receives a DOM event, determines the jsaction associated with the source\n * element of the DOM event, and invokes the handler associated with the\n * jsaction.\n */\nclass Dispatcher {\n    dispatchDelegate;\n    // The ActionResolver to use to resolve actions.\n    actionResolver;\n    /** The replayer function to be called when there are queued events. */\n    eventReplayer;\n    /** Whether the event replay is scheduled. */\n    eventReplayScheduled = false;\n    /** The queue of events. */\n    replayEventInfoWrappers = [];\n    /**\n     * Options are:\n     *   - `eventReplayer`: When the event contract dispatches replay events\n     *      to the Dispatcher, the Dispatcher collects them and in the next tick\n     *      dispatches them to the `eventReplayer`. Defaults to dispatching to `dispatchDelegate`.\n     * @param dispatchDelegate A function that should handle dispatching an `EventInfoWrapper` to handlers.\n     */\n    constructor(dispatchDelegate, { actionResolver, eventReplayer, } = {}) {\n        this.dispatchDelegate = dispatchDelegate;\n        this.actionResolver = actionResolver;\n        this.eventReplayer = eventReplayer;\n    }\n    /**\n     * Receives an event or the event queue from the EventContract. The event\n     * queue is copied and it attempts to replay.\n     * If event info is passed in it looks for an action handler that can handle\n     * the given event.  If there is no handler registered queues the event and\n     * checks if a loader is registered for the given namespace. If so, calls it.\n     *\n     * Alternatively, if in global dispatch mode, calls all registered global\n     * handlers for the appropriate event type.\n     *\n     * The three functionalities of this call are deliberately not split into\n     * three methods (and then declared as an abstract interface), because the\n     * interface is used by EventContract, which lives in a different jsbinary.\n     * Therefore the interface between the three is defined entirely in terms that\n     * are invariant under jscompiler processing (Function and Array, as opposed\n     * to a custom type with method names).\n     *\n     * @param eventInfo The info for the event that triggered this call or the\n     *     queue of events from EventContract.\n     */\n    dispatch(eventInfo) {\n        const eventInfoWrapper = new EventInfoWrapper(eventInfo);\n        this.actionResolver?.resolveEventType(eventInfo);\n        this.actionResolver?.resolveAction(eventInfo);\n        const action = eventInfoWrapper.getAction();\n        if (action && shouldPreventDefaultBeforeDispatching(action.element, eventInfoWrapper)) {\n            preventDefault(eventInfoWrapper.getEvent());\n        }\n        if (this.eventReplayer && eventInfoWrapper.getIsReplay()) {\n            this.scheduleEventInfoWrapperReplay(eventInfoWrapper);\n            return;\n        }\n        this.dispatchDelegate(eventInfoWrapper);\n    }\n    /**\n     * Schedules an `EventInfoWrapper` for replay. The replaying will happen in its own\n     * stack once the current flow cedes control. This is done to mimic\n     * browser event handling.\n     */\n    scheduleEventInfoWrapperReplay(eventInfoWrapper) {\n        this.replayEventInfoWrappers.push(eventInfoWrapper);\n        if (this.eventReplayScheduled) {\n            return;\n        }\n        this.eventReplayScheduled = true;\n        Promise.resolve().then(() => {\n            this.eventReplayScheduled = false;\n            this.eventReplayer(this.replayEventInfoWrappers);\n        });\n    }\n}\n/**\n * Returns true if the default action of this event should be prevented before\n * this event is dispatched.\n */\nfunction shouldPreventDefaultBeforeDispatching(actionElement, eventInfoWrapper) {\n    // Prevent browser from following <a> node links if a jsaction is present\n    // and we are dispatching the action now. Note that the targetElement may be\n    // a child of an anchor that has a jsaction attached. For that reason, we\n    // need to check the actionElement rather than the targetElement.\n    return (actionElement.tagName === 'A' &&\n        (eventInfoWrapper.getEventType() === EventType.CLICK ||\n            eventInfoWrapper.getEventType() === EventType.CLICKMOD));\n}\n\n/** An internal symbol used to indicate whether propagation should be stopped or not. */\nconst PROPAGATION_STOPPED_SYMBOL = \n/* @__PURE__ */ Symbol.for('propagationStopped');\n/** Extra event phases beyond what the browser provides. */\nconst EventPhase = {\n    REPLAY: 101,\n};\nconst PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser dispatch, `preventDefault` would have no ' +\n    'effect. You can check whether an event is being replayed by accessing the event phase: ' +\n    '`event.eventPhase === EventPhase.REPLAY`.';\nconst PREVENT_DEFAULT_ERROR_MESSAGE = `\\`preventDefault\\` called during event replay.`;\nconst COMPOSED_PATH_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser ' +\n    'dispatch, `composedPath()` will be empty. Iterate parent nodes from `event.target` or ' +\n    '`event.currentTarget` if you need to check elements in the event path.';\nconst COMPOSED_PATH_ERROR_MESSAGE = `\\`composedPath\\` called during event replay.`;\n/**\n * A dispatcher that uses browser-based `Event` semantics, for example bubbling, `stopPropagation`,\n * `currentTarget`, etc.\n */\nclass EventDispatcher {\n    dispatchDelegate;\n    clickModSupport;\n    actionResolver;\n    dispatcher;\n    constructor(dispatchDelegate, clickModSupport = true) {\n        this.dispatchDelegate = dispatchDelegate;\n        this.clickModSupport = clickModSupport;\n        this.actionResolver = new ActionResolver({ clickModSupport });\n        this.dispatcher = new Dispatcher((eventInfoWrapper) => {\n            this.dispatchToDelegate(eventInfoWrapper);\n        }, {\n            actionResolver: this.actionResolver,\n        });\n    }\n    /**\n     * The entrypoint for the `EventContract` dispatch.\n     */\n    dispatch(eventInfo) {\n        this.dispatcher.dispatch(eventInfo);\n    }\n    /** Internal method that does basic disaptching. */\n    dispatchToDelegate(eventInfoWrapper) {\n        if (eventInfoWrapper.getIsReplay()) {\n            prepareEventForReplay(eventInfoWrapper);\n        }\n        prepareEventForBubbling(eventInfoWrapper);\n        while (eventInfoWrapper.getAction()) {\n            prepareEventForDispatch(eventInfoWrapper);\n            // If this is a capture event, ONLY dispatch if the action element is the target.\n            if (isCaptureEventType(eventInfoWrapper.getEventType()) &&\n                eventInfoWrapper.getAction().element !== eventInfoWrapper.getTargetElement()) {\n                return;\n            }\n            this.dispatchDelegate(eventInfoWrapper.getEvent(), eventInfoWrapper.getAction().name);\n            if (propagationStopped(eventInfoWrapper)) {\n                return;\n            }\n            this.actionResolver.resolveParentAction(eventInfoWrapper.eventInfo);\n        }\n    }\n}\nfunction prepareEventForBubbling(eventInfoWrapper) {\n    const event = eventInfoWrapper.getEvent();\n    const originalStopPropagation = eventInfoWrapper.getEvent().stopPropagation.bind(event);\n    const stopPropagation = () => {\n        event[PROPAGATION_STOPPED_SYMBOL] = true;\n        originalStopPropagation();\n    };\n    patchEventInstance(event, 'stopPropagation', stopPropagation);\n    patchEventInstance(event, 'stopImmediatePropagation', stopPropagation);\n}\nfunction propagationStopped(eventInfoWrapper) {\n    const event = eventInfoWrapper.getEvent();\n    return !!event[PROPAGATION_STOPPED_SYMBOL];\n}\nfunction prepareEventForReplay(eventInfoWrapper) {\n    const event = eventInfoWrapper.getEvent();\n    const target = eventInfoWrapper.getTargetElement();\n    const originalPreventDefault = event.preventDefault.bind(event);\n    patchEventInstance(event, 'target', target);\n    patchEventInstance(event, 'eventPhase', EventPhase.REPLAY);\n    patchEventInstance(event, 'preventDefault', () => {\n        originalPreventDefault();\n        throw new Error(PREVENT_DEFAULT_ERROR_MESSAGE + (ngDevMode ? PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS : ''));\n    });\n    patchEventInstance(event, 'composedPath', () => {\n        throw new Error(COMPOSED_PATH_ERROR_MESSAGE + (ngDevMode ? COMPOSED_PATH_ERROR_MESSAGE_DETAILS : ''));\n    });\n}\nfunction prepareEventForDispatch(eventInfoWrapper) {\n    const event = eventInfoWrapper.getEvent();\n    const currentTarget = eventInfoWrapper.getAction()?.element;\n    if (currentTarget) {\n        patchEventInstance(event, 'currentTarget', currentTarget, {\n            // `currentTarget` is going to get reassigned every dispatch.\n            configurable: true,\n        });\n    }\n}\n/**\n * Patch `Event` instance during non-standard `Event` dispatch. This patches just the `Event`\n * instance that the browser created, it does not patch global properties or methods.\n *\n * This is necessary because dispatching an `Event` outside of browser dispatch results in\n * incorrect properties and methods that need to be polyfilled or do not work.\n *\n * JSAction dispatch adds two extra \"phases\" to event dispatch:\n * 1. Event delegation - the event is being dispatched by a delegating event handler on a container\n *    (typically `window.document.documentElement`), to a delegated event handler on some child\n *    element. Certain `Event` properties will be unintuitive, such as `currentTarget`, which would\n *    be the container rather than the child element. Bubbling would also not work. In order to\n *    emulate the browser, these properties and methods on the `Event` are patched.\n * 2. Event replay - the event is being dispatched by the framework once the handlers have been\n *    loaded (during hydration, or late-loaded). Certain `Event` properties can be unset by the\n *    browser because the `Event` is no longer actively being dispatched, such as `target`. Other\n *    methods have no effect because the `Event` has already been dispatched, such as\n *    `preventDefault`. Bubbling would also not work. These properties and methods are patched,\n *    either to fill in information that the browser may have removed, or to throw errors in methods\n *    that no longer behave as expected.\n */\nfunction patchEventInstance(event, property, value, { configurable = false } = {}) {\n    Object.defineProperty(event, property, { value, configurable });\n}\n/**\n * Registers deferred functionality for an EventContract and a Jsaction\n * Dispatcher.\n */\nfunction registerDispatcher$1(eventContract, dispatcher) {\n    eventContract.ecrd((eventInfo) => {\n        dispatcher.dispatch(eventInfo);\n    }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);\n}\n\n/** Creates an `EarlyJsactionData` object. */\nfunction createEarlyJsactionData(container) {\n    const q = [];\n    const d = (eventInfo) => {\n        q.push(eventInfo);\n    };\n    const h = (event) => {\n        d(createEventInfoFromParameters(event.type, event, event.target, container, Date.now()));\n    };\n    return {\n        c: container,\n        q,\n        et: [],\n        etc: [],\n        d,\n        h,\n    };\n}\n/** Add all the events to the container stored in the `EarlyJsactionData`. */\nfunction addEvents(earlyJsactionData, types, capture) {\n    for (let i = 0; i < types.length; i++) {\n        const eventType = types[i];\n        const eventTypes = capture ? earlyJsactionData.etc : earlyJsactionData.et;\n        eventTypes.push(eventType);\n        earlyJsactionData.c.addEventListener(eventType, earlyJsactionData.h, capture);\n    }\n}\n/** Get the queued `EventInfo` objects that were dispatched before a dispatcher was registered. */\nfunction getQueuedEventInfos(earlyJsactionData) {\n    return earlyJsactionData?.q ?? [];\n}\n/** Register a different dispatcher function on the `EarlyJsactionData`. */\nfunction registerDispatcher(earlyJsactionData, dispatcher) {\n    if (!earlyJsactionData) {\n        return;\n    }\n    earlyJsactionData.d = dispatcher;\n}\n/** Removes all event listener handlers. */\nfunction removeAllEventListeners(earlyJsactionData) {\n    if (!earlyJsactionData) {\n        return;\n    }\n    removeEventListeners(earlyJsactionData.c, earlyJsactionData.et, earlyJsactionData.h);\n    removeEventListeners(earlyJsactionData.c, earlyJsactionData.etc, earlyJsactionData.h, true);\n}\nfunction removeEventListeners(container, eventTypes, earlyEventHandler, capture) {\n    for (let i = 0; i < eventTypes.length; i++) {\n        container.removeEventListener(eventTypes[i], earlyEventHandler, /* useCapture */ capture);\n    }\n}\n\n/**\n * @define Support for the non-bubbling mouseenter and mouseleave events.  This\n * flag can be overridden in a build rule.\n */\nconst MOUSE_SPECIAL_SUPPORT = false;\n\n/**\n * @fileoverview Implements the local event handling contract. This\n * allows DOM objects in a container that enters into this contract to\n * define event handlers which are executed in a local context.\n *\n * One EventContract instance can manage the contract for multiple\n * containers, which are added using the addContainer() method.\n *\n * Events can be registered using the addEvent() method.\n *\n * A Dispatcher is added using the registerDispatcher() method. Until there is\n * a dispatcher, events are queued. The idea is that the EventContract\n * class is inlined in the HTML of the top level page and instantiated\n * right after the start of <body>. The Dispatcher class is contained\n * in the external deferred js, and instantiated and registered with\n * EventContract when the external javascript in the page loads. The\n * external javascript will also register the jsaction handlers, which\n * then pick up the queued events at the time of registration.\n *\n * Since this class is meant to be inlined in the main page HTML, the\n * size of the binary compiled from this file MUST be kept as small as\n * possible and thus its dependencies to a minimum.\n */\n/**\n * EventContract intercepts events in the bubbling phase at the\n * boundary of a container element, and maps them to generic actions\n * which are specified using the custom jsaction attribute in\n * HTML. Behavior of the application is then specified in terms of\n * handler for such actions, cf. jsaction.Dispatcher in dispatcher.js.\n *\n * This has several benefits: (1) No DOM event handlers need to be\n * registered on the specific elements in the UI. (2) The set of\n * events that the application has to handle can be specified in terms\n * of the semantics of the application, rather than in terms of DOM\n * events. (3) Invocation of handlers can be delayed and handlers can\n * be delay loaded in a generic way.\n */\nclass EventContract {\n    static MOUSE_SPECIAL_SUPPORT = MOUSE_SPECIAL_SUPPORT;\n    containerManager;\n    /**\n     * The DOM events which this contract covers. Used to prevent double\n     * registration of event types. The value of the map is the\n     * internally created DOM event handler function that handles the\n     * DOM events. See addEvent().\n     *\n     */\n    eventHandlers = {};\n    browserEventTypeToExtraEventTypes = {};\n    /**\n     * The dispatcher function. Events are passed to this function for\n     * handling once it was set using the registerDispatcher() method. This is\n     * done because the function is passed from another jsbinary, so passing the\n     * instance and invoking the method here would require to leave the method\n     * unobfuscated.\n     */\n    dispatcher = null;\n    /**\n     * The list of suspended `EventInfo` that will be dispatched\n     * as soon as the `Dispatcher` is registered.\n     */\n    queuedEventInfos = [];\n    constructor(containerManager) {\n        this.containerManager = containerManager;\n    }\n    handleEvent(eventType, event, container) {\n        const eventInfo = createEventInfoFromParameters(\n        /* eventType= */ eventType, \n        /* event= */ event, \n        /* targetElement= */ event.target, \n        /* container= */ container, \n        /* timestamp= */ Date.now());\n        this.handleEventInfo(eventInfo);\n    }\n    /**\n     * Handle an `EventInfo`.\n     */\n    handleEventInfo(eventInfo) {\n        if (!this.dispatcher) {\n            // All events are queued when the dispatcher isn't yet loaded.\n            setIsReplay(eventInfo, true);\n            this.queuedEventInfos?.push(eventInfo);\n            return;\n        }\n        this.dispatcher(eventInfo);\n    }\n    /**\n     * Enables jsaction handlers to be called for the event type given by\n     * name.\n     *\n     * If the event is already registered, this does nothing.\n     *\n     * @param prefixedEventType If supplied, this event is used in\n     *     the actual browser event registration instead of the name that is\n     *     exposed to jsaction. Use this if you e.g. want users to be able\n     *     to subscribe to jsaction=\"transitionEnd:foo\" while the underlying\n     *     event is webkitTransitionEnd in one browser and mozTransitionEnd\n     *     in another.\n     *\n     * @param passive A boolean value that, if `true`, indicates that the event\n     *     handler will never call `preventDefault()`.\n     */\n    addEvent(eventType, prefixedEventType, passive) {\n        if (eventType in this.eventHandlers || !this.containerManager) {\n            return;\n        }\n        if (!EventContract.MOUSE_SPECIAL_SUPPORT && MOUSE_SPECIAL_EVENT_TYPES.indexOf(eventType) >= 0) {\n            return;\n        }\n        const eventHandler = (eventType, event, container) => {\n            this.handleEvent(eventType, event, container);\n        };\n        // Store the callback to allow us to replay events.\n        this.eventHandlers[eventType] = eventHandler;\n        const browserEventType = getBrowserEventType(prefixedEventType || eventType);\n        if (browserEventType !== eventType) {\n            const eventTypes = this.browserEventTypeToExtraEventTypes[browserEventType] || [];\n            eventTypes.push(eventType);\n            this.browserEventTypeToExtraEventTypes[browserEventType] = eventTypes;\n        }\n        this.containerManager.addEventListener(browserEventType, (element) => {\n            return (event) => {\n                eventHandler(eventType, event, element);\n            };\n        }, passive);\n    }\n    /**\n     * Gets the queued early events and replay them using the appropriate handler\n     * in the provided event contract. Once all the events are replayed, it cleans\n     * up the early contract.\n     */\n    replayEarlyEvents(earlyJsactionData = window._ejsa) {\n        // Check if the early contract is present and prevent calling this function\n        // more than once.\n        if (!earlyJsactionData) {\n            return;\n        }\n        // Replay the early contract events.\n        this.replayEarlyEventInfos(earlyJsactionData.q);\n        // Clean up the early contract.\n        removeAllEventListeners(earlyJsactionData);\n        delete window._ejsa;\n    }\n    /**\n     * Replays all the early `EventInfo` objects, dispatching them through the normal\n     * `EventContract` flow.\n     */\n    replayEarlyEventInfos(earlyEventInfos) {\n        for (let i = 0; i < earlyEventInfos.length; i++) {\n            const earlyEventInfo = earlyEventInfos[i];\n            const eventTypes = this.getEventTypesForBrowserEventType(earlyEventInfo.eventType);\n            for (let j = 0; j < eventTypes.length; j++) {\n                const eventInfo = cloneEventInfo(earlyEventInfo);\n                // EventInfo eventType maps to JSAction's internal event type,\n                // rather than the browser event type.\n                setEventType(eventInfo, eventTypes[j]);\n                this.handleEventInfo(eventInfo);\n            }\n        }\n    }\n    /**\n     * Returns all JSAction event types that have been registered for a given\n     * browser event type.\n     */\n    getEventTypesForBrowserEventType(browserEventType) {\n        const eventTypes = [];\n        if (this.eventHandlers[browserEventType]) {\n            eventTypes.push(browserEventType);\n        }\n        if (this.browserEventTypeToExtraEventTypes[browserEventType]) {\n            eventTypes.push(...this.browserEventTypeToExtraEventTypes[browserEventType]);\n        }\n        return eventTypes;\n    }\n    /**\n     * Returns the event handler function for a given event type.\n     */\n    handler(eventType) {\n        return this.eventHandlers[eventType];\n    }\n    /**\n     * Cleans up the event contract. This resets all of the `EventContract`'s\n     * internal state. Users are responsible for not using this `EventContract`\n     * after it has been cleaned up.\n     */\n    cleanUp() {\n        this.containerManager?.cleanUp();\n        this.containerManager = null;\n        this.eventHandlers = {};\n        this.browserEventTypeToExtraEventTypes = {};\n        this.dispatcher = null;\n        this.queuedEventInfos = [];\n    }\n    /**\n     * Register a dispatcher function. Event info of each event mapped to\n     * a jsaction is passed for handling to this callback. The queued\n     * events are passed as well to the dispatcher for later replaying\n     * once the dispatcher is registered. Clears the event queue to null.\n     *\n     * @param dispatcher The dispatcher function.\n     * @param restriction\n     */\n    registerDispatcher(dispatcher, restriction) {\n        this.ecrd(dispatcher, restriction);\n    }\n    /**\n     * Unrenamed alias for registerDispatcher. Necessary for any codebases that\n     * split the `EventContract` and `Dispatcher` code into different compilation\n     * units.\n     */\n    ecrd(dispatcher, restriction) {\n        this.dispatcher = dispatcher;\n        if (this.queuedEventInfos?.length) {\n            for (let i = 0; i < this.queuedEventInfos.length; i++) {\n                this.handleEventInfo(this.queuedEventInfos[i]);\n            }\n            this.queuedEventInfos = null;\n        }\n    }\n}\n\n/**\n * Creates an `EarlyJsactionData`, adds events to it, and populates it on a nested object on\n * the window.\n */\nfunction bootstrapAppScopedEarlyEventContract(container, appId, bubbleEventTypes, captureEventTypes, dataContainer = window) {\n    const earlyJsactionData = createEarlyJsactionData(container);\n    if (!dataContainer._ejsas) {\n        dataContainer._ejsas = {};\n    }\n    dataContainer._ejsas[appId] = earlyJsactionData;\n    addEvents(earlyJsactionData, bubbleEventTypes);\n    addEvents(earlyJsactionData, captureEventTypes, /* capture= */ true);\n}\n/** Get the queued `EventInfo` objects that were dispatched before a dispatcher was registered. */\nfunction getAppScopedQueuedEventInfos(appId, dataContainer = window) {\n    return getQueuedEventInfos(dataContainer._ejsas?.[appId]);\n}\n/**\n * Registers a dispatcher function on the `EarlyJsactionData` present on the nested object on the\n * window.\n */\nfunction registerAppScopedDispatcher(restriction, appId, dispatcher, dataContainer = window) {\n    registerDispatcher(dataContainer._ejsas?.[appId], dispatcher);\n}\n/** Removes all event listener handlers. */\nfunction removeAllAppScopedEventListeners(appId, dataContainer = window) {\n    removeAllEventListeners(dataContainer._ejsas?.[appId]);\n}\n/** Clear the early event contract. */\nfunction clearAppScopedEarlyEventContract(appId, dataContainer = window) {\n    if (!dataContainer._ejsas) {\n        return;\n    }\n    dataContainer._ejsas[appId] = undefined;\n}\n\nexport { Attribute, EventContract, EventContractContainer, EventDispatcher, EventInfoWrapper, EventPhase, bootstrapAppScopedEarlyEventContract, clearAppScopedEarlyEventContract, getDefaulted as getActionCache, getAppScopedQueuedEventInfos, isCaptureEventType, isEarlyEventType, registerAppScopedDispatcher, registerDispatcher$1 as registerDispatcher, removeAllAppScopedEventListeners };\n//# sourceMappingURL=event-dispatch.mjs.map\n"],
  "mappings": "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",
  "names": ["Restriction", "eventType"]
}
