{
  "version": 3,
  "sources": ["/Users/cmackey/Documents/midwest.mackey/midwest-mackey-website/node_modules/@angular/core/fesm2022/testing.mjs"],
  "sourcesContent": ["/**\n * @license Angular v20.3.16\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { NgZone, Injectable, DeferBlockState, triggerResourceLoading, renderDeferBlockState, getDeferBlocks, DeferBlockBehavior, NoopNgZone, ApplicationRef, getDebugNode, RendererFactory2, Directive, Component, Pipe, NgModule, ReflectionCapabilities, depsTracker, isComponentDefPendingResolution, resolveComponentResources, NgModuleRef, ApplicationInitStatus, LOCALE_ID, DEFAULT_LOCALE_ID, setLocaleId, ComponentFactory, getAsyncClassMetadataFn, compileComponent, compileDirective, compilePipe, patchComponentDefWithScope, compileNgModuleDefs, clearResolutionOfComponentResourcesQueue, restoreComponentResolutionQueue, internalProvideZoneChangeDetection, ChangeDetectionSchedulerImpl, COMPILER_OPTIONS, generateStandaloneInDeclarationsError, transitiveScopesFor, Compiler, DEFER_BLOCK_CONFIG, ANIMATIONS_DISABLED, NgModuleFactory, ModuleWithComponentFactories, resetCompiledComponents, \u0275setUnknownElementStrictMode as _setUnknownElementStrictMode, \u0275setUnknownPropertyStrictMode as _setUnknownPropertyStrictMode, \u0275getUnknownElementStrictMode as _getUnknownElementStrictMode, \u0275getUnknownPropertyStrictMode as _getUnknownPropertyStrictMode, inferTagNameFromDefinition, flushModuleScopingQueueAsMuchAsPossible, setAllowDuplicateNgModuleIdsForTest } from './debug_node.mjs';\nimport { Subscription } from 'rxjs';\nimport { inject as inject$1, EnvironmentInjector, ErrorHandler, CONTAINER_HEADER_OFFSET, InjectionToken, PendingTasksInternal, ZONELESS_ENABLED, ChangeDetectionScheduler, EffectScheduler, stringify, getInjectableDef, resolveForwardRef, NG_COMP_DEF, NG_DIR_DEF, NG_PIPE_DEF, NG_INJ_DEF, NG_MOD_DEF, ENVIRONMENT_INITIALIZER, Injector, isEnvironmentProviders, INTERNAL_APPLICATION_ERROR_HANDLER, runInInjectionContext, getComponentDef as getComponentDef$1 } from './root_effect_scheduler.mjs';\nimport { ResourceLoader } from '@angular/compiler';\nimport './signal.mjs';\nimport '@angular/core/primitives/signals';\nimport 'rxjs/operators';\nimport './attribute.mjs';\nimport './not_found.mjs';\nimport '@angular/core/primitives/di';\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```ts\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * })));\n * ```\n *\n * @publicApi\n */\nfunction waitForAsync(fn) {\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return function () {\n            return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js');\n        };\n    }\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    return function () {\n        return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/testing');\n    };\n}\n\nconst RETHROW_APPLICATION_ERRORS_DEFAULT = true;\nclass TestBedApplicationErrorHandler {\n    zone = inject$1(NgZone);\n    injector = inject$1(EnvironmentInjector);\n    userErrorHandler;\n    whenStableRejectFunctions = new Set();\n    handleError(e) {\n        try {\n            this.zone.runOutsideAngular(() => {\n                this.userErrorHandler ??= this.injector.get(ErrorHandler);\n                this.userErrorHandler.handleError(e);\n            });\n        }\n        catch (userError) {\n            e = userError;\n        }\n        // Instead of throwing the error when there are outstanding `fixture.whenStable` promises,\n        // reject those promises with the error. This allows developers to write\n        // expectAsync(fix.whenStable()).toBeRejected();\n        if (this.whenStableRejectFunctions.size > 0) {\n            for (const fn of this.whenStableRejectFunctions.values()) {\n                fn(e);\n            }\n            this.whenStableRejectFunctions.clear();\n        }\n        else {\n            throw e;\n        }\n    }\n    static \u0275fac = function TestBedApplicationErrorHandler_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || TestBedApplicationErrorHandler)(); };\n    static \u0275prov = /*@__PURE__*/ i0.\u0275\u0275defineInjectable({ token: TestBedApplicationErrorHandler, factory: TestBedApplicationErrorHandler.\u0275fac });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.\u0275setClassMetadata(TestBedApplicationErrorHandler, [{\n        type: Injectable\n    }], null, null); })();\n\n/**\n * Represents an individual defer block for testing purposes.\n *\n * @publicApi\n */\nclass DeferBlockFixture {\n    block;\n    componentFixture;\n    /** @docs-private */\n    constructor(block, componentFixture) {\n        this.block = block;\n        this.componentFixture = componentFixture;\n    }\n    /**\n     * Renders the specified state of the defer fixture.\n     * @param state the defer state to render\n     */\n    async render(state) {\n        if (!hasStateTemplate(state, this.block)) {\n            const stateAsString = getDeferBlockStateNameFromEnum(state);\n            throw new Error(`Tried to render this defer block in the \\`${stateAsString}\\` state, ` +\n                `but there was no @${stateAsString.toLowerCase()} block defined in a template.`);\n        }\n        if (state === DeferBlockState.Complete) {\n            await triggerResourceLoading(this.block.tDetails, this.block.lView, this.block.tNode);\n        }\n        // If the `render` method is used explicitly - skip timer-based scheduling for\n        // `@placeholder` and `@loading` blocks and render them immediately.\n        const skipTimerScheduling = true;\n        renderDeferBlockState(state, this.block.tNode, this.block.lContainer, skipTimerScheduling);\n        this.componentFixture.detectChanges();\n    }\n    /**\n     * Retrieves all nested child defer block fixtures\n     * in a given defer block.\n     */\n    getDeferBlocks() {\n        const deferBlocks = [];\n        // An LContainer that represents a defer block has at most 1 view, which is\n        // located right after an LContainer header. Get a hold of that view and inspect\n        // it for nested defer blocks.\n        const deferBlockFixtures = [];\n        if (this.block.lContainer.length >= CONTAINER_HEADER_OFFSET) {\n            const lView = this.block.lContainer[CONTAINER_HEADER_OFFSET];\n            getDeferBlocks(lView, deferBlocks);\n            for (const block of deferBlocks) {\n                deferBlockFixtures.push(new DeferBlockFixture(block, this.componentFixture));\n            }\n        }\n        return Promise.resolve(deferBlockFixtures);\n    }\n}\nfunction hasStateTemplate(state, block) {\n    switch (state) {\n        case DeferBlockState.Placeholder:\n            return block.tDetails.placeholderTmplIndex !== null;\n        case DeferBlockState.Loading:\n            return block.tDetails.loadingTmplIndex !== null;\n        case DeferBlockState.Error:\n            return block.tDetails.errorTmplIndex !== null;\n        case DeferBlockState.Complete:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getDeferBlockStateNameFromEnum(state) {\n    switch (state) {\n        case DeferBlockState.Placeholder:\n            return 'Placeholder';\n        case DeferBlockState.Loading:\n            return 'Loading';\n        case DeferBlockState.Error:\n            return 'Error';\n        default:\n            return 'Main';\n    }\n}\n\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/** Whether defer blocks should use manual triggering or play through normally. */\nconst DEFER_BLOCK_DEFAULT_BEHAVIOR = DeferBlockBehavior.Playthrough;\n/** Whether animations are enabled or disabled. */\nconst ANIMATIONS_ENABLED_DEFAULT = false;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n    insertRootElement(rootElementId, tagName) { }\n    removeAllRootElements() { }\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n    componentRef;\n    /**\n     * The DebugElement associated with the root element of this component.\n     */\n    debugElement;\n    /**\n     * The instance of the root component class.\n     */\n    componentInstance;\n    /**\n     * The native element at the root of the component.\n     */\n    nativeElement;\n    /**\n     * The ElementRef for the element at the root of the component.\n     */\n    elementRef;\n    /**\n     * The ChangeDetectorRef for the component\n     */\n    changeDetectorRef;\n    _renderer;\n    _isDestroyed = false;\n    /** @internal */\n    _noZoneOptionIsSet = inject$1(ComponentFixtureNoNgZone, { optional: true });\n    /** @internal */\n    _ngZone = this._noZoneOptionIsSet ? new NoopNgZone() : inject$1(NgZone);\n    // Inject ApplicationRef to ensure NgZone stableness causes after render hooks to run\n    // This will likely happen as a result of fixture.detectChanges because it calls ngZone.run\n    // This is a crazy way of doing things but hey, it's the world we live in.\n    // The zoneless scheduler should instead do this more imperatively by attaching\n    // the `ComponentRef` to `ApplicationRef` and calling `appRef.tick` as the `detectChanges`\n    // behavior.\n    /** @internal */\n    _appRef = inject$1(ApplicationRef);\n    _testAppRef = this._appRef;\n    pendingTasks = inject$1(PendingTasksInternal);\n    appErrorHandler = inject$1(TestBedApplicationErrorHandler);\n    zonelessEnabled = inject$1(ZONELESS_ENABLED);\n    scheduler = inject$1(ChangeDetectionScheduler);\n    rootEffectScheduler = inject$1(EffectScheduler);\n    autoDetectDefault = this.zonelessEnabled ? true : false;\n    autoDetect = inject$1(ComponentFixtureAutoDetect, { optional: true }) ?? this.autoDetectDefault;\n    subscriptions = new Subscription();\n    // TODO(atscott): Remove this from public API\n    ngZone = this._noZoneOptionIsSet ? null : this._ngZone;\n    /** @docs-private */\n    constructor(componentRef) {\n        this.componentRef = componentRef;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = getDebugNode(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        this._testAppRef.allTestViews.add(this.componentRef.hostView);\n        if (this.autoDetect) {\n            this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView);\n            this.scheduler?.notify(8 /* \u0275NotificationSource.ViewAttached */);\n            this.scheduler?.notify(0 /* \u0275NotificationSource.MarkAncestorsForTraversal */);\n        }\n        this.componentRef.hostView.onDestroy(() => {\n            this._testAppRef.allTestViews.delete(this.componentRef.hostView);\n            this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n        });\n        // Create subscriptions outside the NgZone so that the callbacks run outside\n        // of NgZone.\n        this._ngZone.runOutsideAngular(() => {\n            this.subscriptions.add(this._ngZone.onError.subscribe({\n                next: (error) => {\n                    // The rethrow here is to ensure that errors don't go unreported. Since `NgZone.onHandleError` returns `false`,\n                    // ZoneJS will not throw the error coming out of a task. Instead, the handling is defined by\n                    // the chain of parent delegates and whether they indicate the error is handled in some way (by returning `false`).\n                    // Unfortunately, 'onError' does not forward the information about whether the error was handled by a parent zone\n                    // so cannot know here whether throwing is appropriate. As a half-solution, we can check to see if we're inside\n                    // a fakeAsync context, which we know has its own error handling.\n                    // https://github.com/angular/angular/blob/db2f2d99c82aae52d8a0ae46616c6411d070b35e/packages/zone.js/lib/zone-spec/fake-async-test.ts#L783-L784\n                    // https://github.com/angular/angular/blob/db2f2d99c82aae52d8a0ae46616c6411d070b35e/packages/zone.js/lib/zone-spec/fake-async-test.ts#L473-L478\n                    if (typeof Zone === 'undefined' || Zone.current.get('FakeAsyncTestZoneSpec')) {\n                        return;\n                    }\n                    throw error;\n                },\n            }));\n        });\n    }\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    detectChanges(checkNoChanges = true) {\n        const originalCheckNoChanges = this.componentRef.changeDetectorRef.checkNoChanges;\n        try {\n            if (!checkNoChanges) {\n                this.componentRef.changeDetectorRef.checkNoChanges = () => { };\n            }\n            if (this.zonelessEnabled) {\n                try {\n                    this._testAppRef.includeAllTestViews = true;\n                    this._appRef.tick();\n                }\n                finally {\n                    this._testAppRef.includeAllTestViews = false;\n                }\n            }\n            else {\n                // Run the change detection inside the NgZone so that any async tasks as part of the change\n                // detection are captured by the zone and can be waited for in isStable.\n                this._ngZone.run(() => {\n                    // Flush root effects before `detectChanges()`, to emulate the sequencing of `tick()`.\n                    this.rootEffectScheduler.flush();\n                    this.changeDetectorRef.detectChanges();\n                    this.checkNoChanges();\n                });\n            }\n        }\n        finally {\n            this.componentRef.changeDetectorRef.checkNoChanges = originalCheckNoChanges;\n        }\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges() {\n        this.changeDetectorRef.checkNoChanges();\n    }\n    autoDetectChanges(autoDetect = true) {\n        if (!autoDetect && this.zonelessEnabled) {\n            throw new Error('Cannot set autoDetect to false with zoneless change detection.');\n        }\n        if (this._noZoneOptionIsSet && !this.zonelessEnabled) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.');\n        }\n        if (autoDetect) {\n            this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView);\n        }\n        else {\n            this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n        }\n        this.autoDetect = autoDetect;\n        this.detectChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable() {\n        return !this.pendingTasks.hasPendingTasks;\n    }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable() {\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        return new Promise((resolve, reject) => {\n            this.appErrorHandler.whenStableRejectFunctions.add(reject);\n            this._appRef.whenStable().then(() => {\n                this.appErrorHandler.whenStableRejectFunctions.delete(reject);\n                resolve(true);\n            });\n        });\n    }\n    /**\n     * Retrieves all defer block fixtures in the component fixture.\n     */\n    getDeferBlocks() {\n        const deferBlocks = [];\n        const lView = this.componentRef.hostView['_lView'];\n        getDeferBlocks(lView, deferBlocks);\n        const deferBlockFixtures = [];\n        for (const block of deferBlocks) {\n            deferBlockFixtures.push(new DeferBlockFixture(block, this));\n        }\n        return Promise.resolve(deferBlockFixtures);\n    }\n    _getRenderer() {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n        }\n        return this._renderer;\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n    whenRenderingDone() {\n        const renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     */\n    destroy() {\n        this.subscriptions.unsubscribe();\n        this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView);\n        this._testAppRef.allTestViews.delete(this.componentRef.hostView);\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            this._isDestroyed = true;\n        }\n    }\n}\n\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nfunction getFakeAsyncTestModule() {\n    return _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n}\nfunction withFakeAsyncTestModule(fn) {\n    const fakeAsyncTestModule = getFakeAsyncTestModule();\n    if (!fakeAsyncTestModule) {\n        throw new Error(`zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`);\n    }\n    return fn(fakeAsyncTestModule);\n}\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n    withFakeAsyncTestModule((v) => v.resetFakeAsyncZone());\n}\nfunction resetFakeAsyncZoneIfExists() {\n    if (getFakeAsyncTestModule() && Zone['ProxyZoneSpec']?.isLoaded()) {\n        getFakeAsyncTestModule().resetFakeAsyncZone();\n    }\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAsync` zone.\n * @param options\n *   - flush: When true, will drain the macrotask queue after the test function completes.\n *     When false, will throw an exception at the end of the function if there are pending timers.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn, options) {\n    return withFakeAsyncTestModule((v) => v.fakeAsync(fn, options));\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```ts\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```ts\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick(millis = 0, tickOptions = {\n    processNewMacroTasksSynchronously: true,\n}) {\n    return withFakeAsyncTestModule((m) => m.tick(millis, tickOptions));\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n    return withFakeAsyncTestModule((m) => m.flush(maxTurns));\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n    return withFakeAsyncTestModule((m) => m.discardPeriodicTasks());\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n    return withFakeAsyncTestModule((m) => m.flushMicrotasks());\n}\n\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n    _references = new Map();\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata(metadataClass, oldMetadata, override) {\n        const props = {};\n        if (oldMetadata) {\n            _valueProps(oldMetadata).forEach((prop) => (props[prop] = oldMetadata[prop]));\n        }\n        if (override.set) {\n            if (override.remove || override.add) {\n                throw new Error(`Cannot set and add/remove ${stringify(metadataClass)} at the same time!`);\n            }\n            setMetadata(props, override.set);\n        }\n        if (override.remove) {\n            removeMetadata(props, override.remove, this._references);\n        }\n        if (override.add) {\n            addMetadata(props, override.add);\n        }\n        return new metadataClass(props);\n    }\n}\nfunction removeMetadata(metadata, remove, references) {\n    const removeObjects = new Set();\n    for (const prop in remove) {\n        const removeValue = remove[prop];\n        if (Array.isArray(removeValue)) {\n            removeValue.forEach((value) => {\n                removeObjects.add(_propHashKey(prop, value, references));\n            });\n        }\n        else {\n            removeObjects.add(_propHashKey(prop, removeValue, references));\n        }\n    }\n    for (const prop in metadata) {\n        const propValue = metadata[prop];\n        if (Array.isArray(propValue)) {\n            metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));\n        }\n        else {\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n                metadata[prop] = undefined;\n            }\n        }\n    }\n}\nfunction addMetadata(metadata, add) {\n    for (const prop in add) {\n        const addValue = add[prop];\n        const propValue = metadata[prop];\n        if (propValue != null && Array.isArray(propValue)) {\n            metadata[prop] = propValue.concat(addValue);\n        }\n        else {\n            metadata[prop] = addValue;\n        }\n    }\n}\nfunction setMetadata(metadata, set) {\n    for (const prop in set) {\n        metadata[prop] = set[prop];\n    }\n}\nfunction _propHashKey(propName, propValue, references) {\n    let nextObjectId = 0;\n    const objectIds = new Map();\n    const replacer = (key, value) => {\n        if (value !== null && typeof value === 'object') {\n            if (objectIds.has(value)) {\n                return objectIds.get(value);\n            }\n            // Record an id for this object such that any later references use the object's id instead\n            // of the object itself, in order to break cyclic pointers in objects.\n            objectIds.set(value, `\u0275obj#${nextObjectId++}`);\n            // The first time an object is seen the object itself is serialized.\n            return value;\n        }\n        else if (typeof value === 'function') {\n            value = _serializeReference(value, references);\n        }\n        return value;\n    };\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n    let id = references.get(ref);\n    if (!id) {\n        id = `${stringify(ref)}${_nextReferenceId++}`;\n        references.set(ref, id);\n    }\n    return id;\n}\nfunction _valueProps(obj) {\n    const props = [];\n    // regular public props\n    Object.keys(obj).forEach((prop) => {\n        if (!prop.startsWith('_')) {\n            props.push(prop);\n        }\n    });\n    // getters\n    let proto = obj;\n    while ((proto = Object.getPrototypeOf(proto))) {\n        Object.keys(proto).forEach((protoProp) => {\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n                props.push(protoProp);\n            }\n        });\n    }\n    return props;\n}\n\nconst reflection = new ReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n    overrides = new Map();\n    resolved = new Map();\n    addOverride(type, override) {\n        const overrides = this.overrides.get(type) || [];\n        overrides.push(override);\n        this.overrides.set(type, overrides);\n        this.resolved.delete(type);\n    }\n    setOverrides(overrides) {\n        this.overrides.clear();\n        overrides.forEach(([type, override]) => {\n            this.addOverride(type, override);\n        });\n    }\n    getAnnotation(type) {\n        const annotations = reflection.annotations(type);\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\n        // both Directive and Component annotations would be present), so we always check if the known\n        // annotation has the right type.\n        for (let i = annotations.length - 1; i >= 0; i--) {\n            const annotation = annotations[i];\n            const isKnownType = annotation instanceof Directive ||\n                annotation instanceof Component ||\n                annotation instanceof Pipe ||\n                annotation instanceof NgModule;\n            if (isKnownType) {\n                return annotation instanceof this.type ? annotation : null;\n            }\n        }\n        return null;\n    }\n    resolve(type) {\n        let resolved = this.resolved.get(type) || null;\n        if (!resolved) {\n            resolved = this.getAnnotation(type);\n            if (resolved) {\n                const overrides = this.overrides.get(type);\n                if (overrides) {\n                    const overrider = new MetadataOverrider();\n                    overrides.forEach((override) => {\n                        resolved = overrider.overrideMetadata(this.type, resolved, override);\n                    });\n                }\n            }\n            this.resolved.set(type, resolved);\n        }\n        return resolved;\n    }\n}\nclass DirectiveResolver extends OverrideResolver {\n    get type() {\n        return Directive;\n    }\n}\nclass ComponentResolver extends OverrideResolver {\n    get type() {\n        return Component;\n    }\n}\nclass PipeResolver extends OverrideResolver {\n    get type() {\n        return Pipe;\n    }\n}\nclass NgModuleResolver extends OverrideResolver {\n    get type() {\n        return NgModule;\n    }\n}\n\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n    TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n    TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n    return (value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE);\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n    types.forEach((type) => {\n        if (!getAsyncClassMetadataFn(type)) {\n            const component = resolver.resolve(type);\n            if (component && (component.standalone == null || component.standalone)) {\n                throw new Error(generateStandaloneInDeclarationsError(type, location));\n            }\n        }\n    });\n}\nclass TestBedCompiler {\n    platform;\n    additionalModuleTypes;\n    originalComponentResolutionQueue = null;\n    // Testing module configuration\n    declarations = [];\n    imports = [];\n    providers = [];\n    schemas = [];\n    // Queues of components/directives/pipes that should be recompiled.\n    pendingComponents = new Set();\n    pendingDirectives = new Set();\n    pendingPipes = new Set();\n    // Set of components with async metadata, i.e. components with `@defer` blocks\n    // in their templates.\n    componentsWithAsyncMetadata = new Set();\n    // Keep track of all components and directives, so we can patch Providers onto defs later.\n    seenComponents = new Set();\n    seenDirectives = new Set();\n    // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n    overriddenModules = new Set();\n    // Store resolved styles for Components that have template overrides present and `styleUrls`\n    // defined at the same time.\n    existingComponentStyles = new Map();\n    resolvers = initResolvers();\n    // Map of component type to an NgModule that declares it.\n    //\n    // There are a couple special cases:\n    // - for standalone components, the module scope value is `null`\n    // - when a component is declared in `TestBed.configureTestingModule()` call or\n    //   a component's template is overridden via `TestBed.overrideTemplateUsingTestingModule()`.\n    //   we use a special value from the `TestingModuleOverride` enum.\n    componentToModuleScope = new Map();\n    // Map that keeps initial version of component/directive/pipe defs in case\n    // we compile a Type again, thus overriding respective static fields. This is\n    // required to make sure we restore defs to their initial states between test runs.\n    // Note: one class may have multiple defs (for example: \u0275mod and \u0275inj in case of an\n    // NgModule), store all of them in a map.\n    initialNgDefs = new Map();\n    // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n    // defs in case TestBed makes changes to the originals.\n    defCleanupOps = [];\n    _injector = null;\n    compilerProviders = null;\n    providerOverrides = [];\n    rootProviderOverrides = [];\n    // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n    // module's provider list.\n    providerOverridesByModule = new Map();\n    providerOverridesByToken = new Map();\n    scopesWithOverriddenProviders = new Set();\n    testModuleType;\n    testModuleRef = null;\n    animationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n    deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    rethrowApplicationTickErrors = RETHROW_APPLICATION_ERRORS_DEFAULT;\n    constructor(platform, additionalModuleTypes) {\n        this.platform = platform;\n        this.additionalModuleTypes = additionalModuleTypes;\n        class DynamicTestModule {\n        }\n        this.testModuleType = DynamicTestModule;\n    }\n    setCompilerProviders(providers) {\n        this.compilerProviders = providers;\n        this._injector = null;\n    }\n    configureTestingModule(moduleDef) {\n        // Enqueue any compilation tasks for the directly declared component.\n        if (moduleDef.declarations !== undefined) {\n            // Verify that there are no standalone components\n            assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n            this.declarations.push(...moduleDef.declarations);\n        }\n        // Enqueue any compilation tasks for imported modules.\n        if (moduleDef.imports !== undefined) {\n            this.queueTypesFromModulesArray(moduleDef.imports);\n            this.imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.providers !== undefined) {\n            this.providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.schemas !== undefined) {\n            this.schemas.push(...moduleDef.schemas);\n        }\n        this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n        this.animationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n        this.rethrowApplicationTickErrors =\n            moduleDef.rethrowApplicationErrors ?? RETHROW_APPLICATION_ERRORS_DEFAULT;\n    }\n    overrideModule(ngModule, override) {\n        depsTracker.clearScopeCacheFor(ngModule);\n        this.overriddenModules.add(ngModule);\n        // Compile the module right away.\n        this.resolvers.module.addOverride(ngModule, override);\n        const metadata = this.resolvers.module.resolve(ngModule);\n        if (metadata === null) {\n            throw invalidTypeError(ngModule.name, 'NgModule');\n        }\n        this.recompileNgModule(ngModule, metadata);\n        // At this point, the module has a valid module def (\u0275mod), but the override may have introduced\n        // new declarations or imported modules. Ingest any possible new types and add them to the\n        // current queue.\n        this.queueTypesFromModulesArray([ngModule]);\n    }\n    overrideComponent(component, override) {\n        this.verifyNoStandaloneFlagOverrides(component, override);\n        this.resolvers.component.addOverride(component, override);\n        this.pendingComponents.add(component);\n        // If this is a component with async metadata (i.e. a component with a `@defer` block\n        // in a template) - store it for future processing.\n        this.maybeRegisterComponentWithAsyncMetadata(component);\n    }\n    overrideDirective(directive, override) {\n        this.verifyNoStandaloneFlagOverrides(directive, override);\n        this.resolvers.directive.addOverride(directive, override);\n        this.pendingDirectives.add(directive);\n    }\n    overridePipe(pipe, override) {\n        this.verifyNoStandaloneFlagOverrides(pipe, override);\n        this.resolvers.pipe.addOverride(pipe, override);\n        this.pendingPipes.add(pipe);\n    }\n    verifyNoStandaloneFlagOverrides(type, override) {\n        if (override.add?.hasOwnProperty('standalone') ||\n            override.set?.hasOwnProperty('standalone') ||\n            override.remove?.hasOwnProperty('standalone')) {\n            throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` +\n                `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n        }\n    }\n    overrideProvider(token, provider) {\n        let providerDef;\n        if (provider.useFactory !== undefined) {\n            providerDef = {\n                provide: token,\n                useFactory: provider.useFactory,\n                deps: provider.deps || [],\n                multi: provider.multi,\n            };\n        }\n        else if (provider.useValue !== undefined) {\n            providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };\n        }\n        else {\n            providerDef = { provide: token };\n        }\n        const injectableDef = typeof token !== 'string' ? getInjectableDef(token) : null;\n        const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n        const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n        overridesBucket.push(providerDef);\n        // Keep overrides grouped by token as well for fast lookups using token\n        this.providerOverridesByToken.set(token, providerDef);\n        if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n            const existingOverrides = this.providerOverridesByModule.get(providedIn);\n            if (existingOverrides !== undefined) {\n                existingOverrides.push(providerDef);\n            }\n            else {\n                this.providerOverridesByModule.set(providedIn, [providerDef]);\n            }\n        }\n    }\n    overrideTemplateUsingTestingModule(type, template) {\n        const def = type[NG_COMP_DEF];\n        const hasStyleUrls = () => {\n            const metadata = this.resolvers.component.resolve(type);\n            return !!metadata.styleUrl || !!metadata.styleUrls?.length;\n        };\n        const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n        // In Ivy, compiling a component does not require knowing the module providing the\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\n        // which may fail in case styleUrls are also present (thus Component is considered as required\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n        // preserve current styles available on Component def and restore styles back once compilation\n        // is complete.\n        const override = overrideStyleUrls\n            ? { template, styles: [], styleUrls: [], styleUrl: undefined }\n            : { template };\n        this.overrideComponent(type, { set: override });\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n            this.existingComponentStyles.set(type, def.styles);\n        }\n        // Set the component's scope to be the testing module.\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n    async resolvePendingComponentsWithAsyncMetadata() {\n        if (this.componentsWithAsyncMetadata.size === 0)\n            return;\n        const promises = [];\n        for (const component of this.componentsWithAsyncMetadata) {\n            const asyncMetadataFn = getAsyncClassMetadataFn(component);\n            if (asyncMetadataFn) {\n                promises.push(asyncMetadataFn());\n            }\n        }\n        this.componentsWithAsyncMetadata.clear();\n        const resolvedDeps = await Promise.all(promises);\n        const flatResolvedDeps = resolvedDeps.flat(2);\n        this.queueTypesFromModulesArray(flatResolvedDeps);\n        // Loaded standalone components might contain imports of NgModules\n        // with providers, make sure we override providers there too.\n        for (const component of flatResolvedDeps) {\n            this.applyProviderOverridesInScope(component);\n        }\n    }\n    async compileComponents() {\n        this.clearComponentResolutionQueue();\n        // Wait for all async metadata for components that were\n        // overridden, we need resolved metadata to perform an override\n        // and re-compile a component.\n        await this.resolvePendingComponentsWithAsyncMetadata();\n        // Verify that there were no standalone components present in the `declarations` field\n        // during the `TestBed.configureTestingModule` call. We perform this check here in addition\n        // to the logic in the `configureTestingModule` function, since at this point we have\n        // all async metadata resolved.\n        assertNoStandaloneComponents(this.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n        // Run compilers for all queued types.\n        let needsAsyncResources = this.compileTypesSync();\n        // compileComponents() should not be async unless it needs to be.\n        if (needsAsyncResources) {\n            let resourceLoader;\n            let resolver = (url) => {\n                if (!resourceLoader) {\n                    resourceLoader = this.injector.get(ResourceLoader);\n                }\n                return Promise.resolve(resourceLoader.get(url));\n            };\n            await resolveComponentResources(resolver);\n        }\n    }\n    finalize() {\n        // One last compile\n        this.compileTypesSync();\n        // Create the testing module itself.\n        this.compileTestModule();\n        this.applyTransitiveScopes();\n        this.applyProviderOverrides();\n        // Patch previously stored `styles` Component values (taken from \u0275cmp), in case these\n        // Components have `styleUrls` fields defined and template override was requested.\n        this.patchComponentsWithExistingStyles();\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n        // every component.\n        this.componentToModuleScope.clear();\n        const parentInjector = this.platform.injector;\n        this.testModuleRef = new NgModuleRef(this.testModuleType, parentInjector, []);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\n        // Cast it to any before accessing it.\n        this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n        // Set locale ID after running app initializers, since locale information might be updated while\n        // running initializers. This is also consistent with the execution order while bootstrapping an\n        // app (see `packages/core/src/application_ref.ts` file).\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n        setLocaleId(localeId);\n        return this.testModuleRef;\n    }\n    /**\n     * @internal\n     */\n    _compileNgModuleSync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        this.compileTypesSync();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    async _compileNgModuleAsync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        await this.compileComponents();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    _getModuleResolver() {\n        return this.resolvers.module;\n    }\n    /**\n     * @internal\n     */\n    _getComponentFactories(moduleType) {\n        return maybeUnwrapFn(moduleType.\u0275mod.declarations).reduce((factories, declaration) => {\n            const componentDef = declaration.\u0275cmp;\n            componentDef && factories.push(new ComponentFactory(componentDef, this.testModuleRef));\n            return factories;\n        }, []);\n    }\n    compileTypesSync() {\n        // Compile all queued components, directives, pipes.\n        let needsAsyncResources = false;\n        this.pendingComponents.forEach((declaration) => {\n            if (getAsyncClassMetadataFn(declaration)) {\n                throw new Error(`Component '${declaration.name}' has unresolved metadata. ` +\n                    `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n            }\n            needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n            const metadata = this.resolvers.component.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Component');\n            }\n            this.maybeStoreNgDef(NG_COMP_DEF, declaration);\n            depsTracker.clearScopeCacheFor(declaration);\n            compileComponent(declaration, metadata);\n        });\n        this.pendingComponents.clear();\n        this.pendingDirectives.forEach((declaration) => {\n            const metadata = this.resolvers.directive.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Directive');\n            }\n            this.maybeStoreNgDef(NG_DIR_DEF, declaration);\n            compileDirective(declaration, metadata);\n        });\n        this.pendingDirectives.clear();\n        this.pendingPipes.forEach((declaration) => {\n            const metadata = this.resolvers.pipe.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Pipe');\n            }\n            this.maybeStoreNgDef(NG_PIPE_DEF, declaration);\n            compilePipe(declaration, metadata);\n        });\n        this.pendingPipes.clear();\n        return needsAsyncResources;\n    }\n    applyTransitiveScopes() {\n        if (this.overriddenModules.size > 0) {\n            // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n            // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n            // collect all affected modules and reset scopes to force their re-calculation.\n            const testingModuleDef = this.testModuleType[NG_MOD_DEF];\n            const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n            if (affectedModules.size > 0) {\n                affectedModules.forEach((moduleType) => {\n                    depsTracker.clearScopeCacheFor(moduleType);\n                });\n            }\n        }\n        const moduleToScope = new Map();\n        const getScopeOfModule = (moduleType) => {\n            if (!moduleToScope.has(moduleType)) {\n                const isTestingModule = isTestingModuleOverride(moduleType);\n                const realType = isTestingModule ? this.testModuleType : moduleType;\n                moduleToScope.set(moduleType, transitiveScopesFor(realType));\n            }\n            return moduleToScope.get(moduleType);\n        };\n        this.componentToModuleScope.forEach((moduleType, componentType) => {\n            if (moduleType !== null) {\n                const moduleScope = getScopeOfModule(moduleType);\n                this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'directiveDefs');\n                this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'pipeDefs');\n                patchComponentDefWithScope(getComponentDef(componentType), moduleScope);\n            }\n            // `tView` that is stored on component def contains information about directives and pipes\n            // that are in the scope of this component. Patching component scope will cause `tView` to be\n            // changed. Store original `tView` before patching scope, so the `tView` (including scope\n            // information) is restored back to its previous/original state before running next test.\n            // Resetting `tView` is also needed for cases when we apply provider overrides and those\n            // providers are defined on component's level, in which case they may end up included into\n            // `tView.blueprint`.\n            this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, 'tView');\n        });\n        this.componentToModuleScope.clear();\n    }\n    applyProviderOverrides() {\n        const maybeApplyOverrides = (field) => (type) => {\n            const resolver = field === NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n            const metadata = resolver.resolve(type);\n            if (this.hasProviderOverrides(metadata.providers)) {\n                this.patchDefWithProviderOverrides(type, field);\n            }\n        };\n        this.seenComponents.forEach(maybeApplyOverrides(NG_COMP_DEF));\n        this.seenDirectives.forEach(maybeApplyOverrides(NG_DIR_DEF));\n        this.seenComponents.clear();\n        this.seenDirectives.clear();\n    }\n    /**\n     * Applies provider overrides to a given type (either an NgModule or a standalone component)\n     * and all imported NgModules and standalone components recursively.\n     */\n    applyProviderOverridesInScope(type) {\n        const hasScope = isStandaloneComponent(type) || isNgModule(type);\n        // The function can be re-entered recursively while inspecting dependencies\n        // of an NgModule or a standalone component. Exit early if we come across a\n        // type that can not have a scope (directive or pipe) or the type is already\n        // processed earlier.\n        if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n            return;\n        }\n        this.scopesWithOverriddenProviders.add(type);\n        // NOTE: the line below triggers JIT compilation of the module injector,\n        // which also invokes verification of the NgModule semantics, which produces\n        // detailed error messages. The fact that the code relies on this line being\n        // present here is suspicious and should be refactored in a way that the line\n        // below can be moved (for ex. after an early exit check below).\n        const injectorDef = type[NG_INJ_DEF];\n        // No provider overrides, exit early.\n        if (this.providerOverridesByToken.size === 0)\n            return;\n        if (isStandaloneComponent(type)) {\n            // Visit all component dependencies and override providers there.\n            const def = getComponentDef(type);\n            const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n            for (const dependency of dependencies) {\n                this.applyProviderOverridesInScope(dependency);\n            }\n        }\n        else {\n            const providers = [\n                ...injectorDef.providers,\n                ...(this.providerOverridesByModule.get(type) || []),\n            ];\n            if (this.hasProviderOverrides(providers)) {\n                this.maybeStoreNgDef(NG_INJ_DEF, type);\n                this.storeFieldOfDefOnType(type, NG_INJ_DEF, 'providers');\n                injectorDef.providers = this.getOverriddenProviders(providers);\n            }\n            // Apply provider overrides to imported modules recursively\n            const moduleDef = type[NG_MOD_DEF];\n            const imports = maybeUnwrapFn(moduleDef.imports);\n            for (const importedModule of imports) {\n                this.applyProviderOverridesInScope(importedModule);\n            }\n            // Also override the providers on any ModuleWithProviders imports since those don't appear in\n            // the moduleDef.\n            for (const importedModule of flatten(injectorDef.imports)) {\n                if (isModuleWithProviders(importedModule)) {\n                    this.defCleanupOps.push({\n                        object: importedModule,\n                        fieldName: 'providers',\n                        originalValue: importedModule.providers,\n                    });\n                    importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n                }\n            }\n        }\n    }\n    patchComponentsWithExistingStyles() {\n        this.existingComponentStyles.forEach((styles, type) => (type[NG_COMP_DEF].styles = styles));\n        this.existingComponentStyles.clear();\n    }\n    queueTypeArray(arr, moduleType) {\n        for (const value of arr) {\n            if (Array.isArray(value)) {\n                this.queueTypeArray(value, moduleType);\n            }\n            else {\n                this.queueType(value, moduleType);\n            }\n        }\n    }\n    recompileNgModule(ngModule, metadata) {\n        // Cache the initial ngModuleDef as it will be overwritten.\n        this.maybeStoreNgDef(NG_MOD_DEF, ngModule);\n        this.maybeStoreNgDef(NG_INJ_DEF, ngModule);\n        compileNgModuleDefs(ngModule, metadata);\n    }\n    maybeRegisterComponentWithAsyncMetadata(type) {\n        const asyncMetadataFn = getAsyncClassMetadataFn(type);\n        if (asyncMetadataFn) {\n            this.componentsWithAsyncMetadata.add(type);\n        }\n    }\n    queueType(type, moduleType) {\n        // If this is a component with async metadata (i.e. a component with a `@defer` block\n        // in a template) - store it for future processing.\n        this.maybeRegisterComponentWithAsyncMetadata(type);\n        const component = this.resolvers.component.resolve(type);\n        if (component) {\n            // Check whether a give Type has respective NG def (\u0275cmp) and compile if def is\n            // missing. That might happen in case a class without any Angular decorators extends another\n            // class where Component/Directive/Pipe decorator is defined.\n            if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(NG_COMP_DEF)) {\n                this.pendingComponents.add(type);\n            }\n            this.seenComponents.add(type);\n            // Keep track of the module which declares this component, so later the component's scope\n            // can be set correctly. If the component has already been recorded here, then one of several\n            // cases is true:\n            // * the module containing the component was imported multiple times (common).\n            // * the component is declared in multiple modules (which is an error).\n            // * the component was in 'declarations' of the testing module, and also in an imported module\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n            //\n            // If the component was previously in the testing module's 'declarations' (meaning the\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n            // real module, which was imported. This pattern is understood to mean that the component\n            // should use its original scope, but that the testing module should also contain the\n            // component in its scope.\n            if (!this.componentToModuleScope.has(type) ||\n                this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n                this.componentToModuleScope.set(type, moduleType);\n            }\n            return;\n        }\n        const directive = this.resolvers.directive.resolve(type);\n        if (directive) {\n            if (!type.hasOwnProperty(NG_DIR_DEF)) {\n                this.pendingDirectives.add(type);\n            }\n            this.seenDirectives.add(type);\n            return;\n        }\n        const pipe = this.resolvers.pipe.resolve(type);\n        if (pipe && !type.hasOwnProperty(NG_PIPE_DEF)) {\n            this.pendingPipes.add(type);\n            return;\n        }\n    }\n    queueTypesFromModulesArray(arr) {\n        // Because we may encounter the same NgModule or a standalone Component while processing\n        // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\n        // can skip ones that have already been seen encountered. In some test setups, this caching\n        // resulted in 10X runtime improvement.\n        const processedDefs = new Set();\n        const queueTypesFromModulesArrayRecur = (arr) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    queueTypesFromModulesArrayRecur(value);\n                }\n                else if (hasNgModuleDef(value)) {\n                    const def = value.\u0275mod;\n                    if (processedDefs.has(def)) {\n                        continue;\n                    }\n                    processedDefs.add(def);\n                    // Look through declarations, imports, and exports, and queue\n                    // everything found there.\n                    this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n                }\n                else if (isModuleWithProviders(value)) {\n                    queueTypesFromModulesArrayRecur([value.ngModule]);\n                }\n                else if (isStandaloneComponent(value)) {\n                    this.queueType(value, null);\n                    const def = getComponentDef(value);\n                    if (processedDefs.has(def)) {\n                        continue;\n                    }\n                    processedDefs.add(def);\n                    const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n                    dependencies.forEach((dependency) => {\n                        // Note: in AOT, the `dependencies` might also contain regular\n                        // (NgModule-based) Component, Directive and Pipes, so we handle\n                        // them separately and proceed with recursive process for standalone\n                        // Components and NgModules only.\n                        if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n                            queueTypesFromModulesArrayRecur([dependency]);\n                        }\n                        else {\n                            this.queueType(dependency, null);\n                        }\n                    });\n                }\n            }\n        };\n        queueTypesFromModulesArrayRecur(arr);\n    }\n    // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n    // that import (even transitively) an overridden one. For all affected modules we need to\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n    // of this function is to collect all affected modules in a set for further processing. Example:\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n    // invalidated with the override.\n    collectModulesAffectedByOverrides(arr) {\n        const seenModules = new Set();\n        const affectedModules = new Set();\n        const calcAffectedModulesRecur = (arr, path) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    // If the value is an array, just flatten it (by invoking this function recursively),\n                    // keeping \"path\" the same.\n                    calcAffectedModulesRecur(value, path);\n                }\n                else if (hasNgModuleDef(value)) {\n                    if (seenModules.has(value)) {\n                        // If we've seen this module before and it's included into \"affected modules\" list, mark\n                        // the whole path that leads to that module as affected, but do not descend into its\n                        // imports, since we already examined them before.\n                        if (affectedModules.has(value)) {\n                            path.forEach((item) => affectedModules.add(item));\n                        }\n                        continue;\n                    }\n                    seenModules.add(value);\n                    if (this.overriddenModules.has(value)) {\n                        path.forEach((item) => affectedModules.add(item));\n                    }\n                    // Examine module imports recursively to look for overridden modules.\n                    const moduleDef = value[NG_MOD_DEF];\n                    calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n                }\n            }\n        };\n        calcAffectedModulesRecur(arr, []);\n        return affectedModules;\n    }\n    /**\n     * Preserve an original def (such as \u0275mod, \u0275inj, etc) before applying an override.\n     * Note: one class may have multiple defs (for example: \u0275mod and \u0275inj in case of\n     * an NgModule). If there is a def in a set already, don't override it, since\n     * an original one should be restored at the end of a test.\n     */\n    maybeStoreNgDef(prop, type) {\n        if (!this.initialNgDefs.has(type)) {\n            this.initialNgDefs.set(type, new Map());\n        }\n        const currentDefs = this.initialNgDefs.get(type);\n        if (!currentDefs.has(prop)) {\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n            currentDefs.set(prop, currentDef);\n        }\n    }\n    storeFieldOfDefOnType(type, defField, fieldName) {\n        const def = type[defField];\n        const originalValue = def[fieldName];\n        this.defCleanupOps.push({ object: def, fieldName, originalValue });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     */\n    clearComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue === null) {\n            this.originalComponentResolutionQueue = new Map();\n        }\n        clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n    }\n    /*\n     * Restores component resolution queue to the previously saved state. This operation is performed\n     * as a part of restoring the state after completion of the current set of tests (that might\n     * potentially mutate the state).\n     */\n    restoreComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue !== null) {\n            restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n            this.originalComponentResolutionQueue = null;\n        }\n    }\n    restoreOriginalState() {\n        // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n        // case there were multiple overrides for the same field).\n        forEachRight(this.defCleanupOps, (op) => {\n            op.object[op.fieldName] = op.originalValue;\n        });\n        // Restore initial component/directive/pipe defs\n        this.initialNgDefs.forEach((defs, type) => {\n            depsTracker.clearScopeCacheFor(type);\n            defs.forEach((descriptor, prop) => {\n                if (!descriptor) {\n                    // Delete operations are generally undesirable since they have performance\n                    // implications on objects they were applied to. In this particular case, situations\n                    // where this code is invoked should be quite rare to cause any noticeable impact,\n                    // since it's applied only to some test cases (for example when class with no\n                    // annotations extends some @Component) when we need to clear '\u0275cmp' field on a given\n                    // class to restore its original state (before applying overrides and running tests).\n                    delete type[prop];\n                }\n                else {\n                    Object.defineProperty(type, prop, descriptor);\n                }\n            });\n        });\n        this.initialNgDefs.clear();\n        this.scopesWithOverriddenProviders.clear();\n        this.restoreComponentResolutionQueue();\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n        setLocaleId(DEFAULT_LOCALE_ID);\n    }\n    compileTestModule() {\n        class RootScopeModule {\n        }\n        compileNgModuleDefs(RootScopeModule, {\n            providers: [\n                ...this.rootProviderOverrides,\n                internalProvideZoneChangeDetection({}),\n                TestBedApplicationErrorHandler,\n                { provide: ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl },\n                {\n                    provide: ENVIRONMENT_INITIALIZER,\n                    multi: true,\n                    useValue: () => {\n                        inject$1(ErrorHandler);\n                    },\n                },\n            ],\n        });\n        const providers = [\n            { provide: Compiler, useFactory: () => new R3TestCompiler(this) },\n            { provide: DEFER_BLOCK_CONFIG, useValue: { behavior: this.deferBlockBehavior } },\n            {\n                provide: ANIMATIONS_DISABLED,\n                useValue: !this.animationsEnabled,\n            },\n            {\n                provide: INTERNAL_APPLICATION_ERROR_HANDLER,\n                useFactory: () => {\n                    if (this.rethrowApplicationTickErrors) {\n                        const handler = inject$1(TestBedApplicationErrorHandler);\n                        return (e) => {\n                            handler.handleError(e);\n                        };\n                    }\n                    else {\n                        const userErrorHandler = inject$1(ErrorHandler);\n                        const ngZone = inject$1(NgZone);\n                        return (e) => ngZone.runOutsideAngular(() => userErrorHandler.handleError(e));\n                    }\n                },\n            },\n            ...this.providers,\n            ...this.providerOverrides,\n        ];\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n        compileNgModuleDefs(this.testModuleType, {\n            declarations: this.declarations,\n            imports,\n            schemas: this.schemas,\n            providers,\n        }, \n        /* allowDuplicateDeclarationsInRoot */ true);\n        this.applyProviderOverridesInScope(this.testModuleType);\n    }\n    get injector() {\n        if (this._injector !== null) {\n            return this._injector;\n        }\n        const providers = [];\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS, []);\n        compilerOptions.forEach((opts) => {\n            if (opts.providers) {\n                providers.push(opts.providers);\n            }\n        });\n        if (this.compilerProviders !== null) {\n            providers.push(...this.compilerProviders);\n        }\n        this._injector = Injector.create({ providers, parent: this.platform.injector });\n        return this._injector;\n    }\n    // get overrides for a specific provider (if any)\n    getSingleProviderOverrides(provider) {\n        const token = getProviderToken(provider);\n        return this.providerOverridesByToken.get(token) || null;\n    }\n    getProviderOverrides(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        // There are two flattening operations here. The inner flattenProviders() operates on the\n        // metadata's providers and applies a mapping function which retrieves overrides for each\n        // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\n        // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n        // providers array and contaminate any error messages that might be generated.\n        return flatten(flattenProviders(providers, (provider) => this.getSingleProviderOverrides(provider) || []));\n    }\n    getOverriddenProviders(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        const flattenedProviders = flattenProviders(providers);\n        const overrides = this.getProviderOverrides(flattenedProviders);\n        const overriddenProviders = [...flattenedProviders, ...overrides];\n        const final = [];\n        const seenOverriddenProviders = new Set();\n        // We iterate through the list of providers in reverse order to make sure provider overrides\n        // take precedence over the values defined in provider list. We also filter out all providers\n        // that have overrides, keeping overridden values only. This is needed, since presence of a\n        // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n        forEachRight(overriddenProviders, (provider) => {\n            const token = getProviderToken(provider);\n            if (this.providerOverridesByToken.has(token)) {\n                if (!seenOverriddenProviders.has(token)) {\n                    seenOverriddenProviders.add(token);\n                    // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n                    // make sure that provided override takes highest precedence and is not combined with\n                    // other instances of the same multi provider.\n                    final.unshift({ ...provider, multi: false });\n                }\n            }\n            else {\n                final.unshift(provider);\n            }\n        });\n        return final;\n    }\n    hasProviderOverrides(providers) {\n        return this.getProviderOverrides(providers).length > 0;\n    }\n    patchDefWithProviderOverrides(declaration, field) {\n        const def = declaration[field];\n        if (def && def.providersResolver) {\n            this.maybeStoreNgDef(field, declaration);\n            const resolver = def.providersResolver;\n            const processProvidersFn = (providers) => this.getOverriddenProviders(providers);\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n            def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);\n        }\n    }\n}\nfunction initResolvers() {\n    return {\n        module: new NgModuleResolver(),\n        component: new ComponentResolver(),\n        directive: new DirectiveResolver(),\n        pipe: new PipeResolver(),\n    };\n}\nfunction isStandaloneComponent(value) {\n    const def = getComponentDef(value);\n    return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n    return value.\u0275cmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n    return value.hasOwnProperty('\u0275mod');\n}\nfunction isNgModule(value) {\n    return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values) {\n    const out = [];\n    values.forEach((value) => {\n        if (Array.isArray(value)) {\n            out.push(...flatten(value));\n        }\n        else {\n            out.push(value);\n        }\n    });\n    return out;\n}\nfunction identityFn(value) {\n    return value;\n}\nfunction flattenProviders(providers, mapFn = identityFn) {\n    const out = [];\n    for (let provider of providers) {\n        if (isEnvironmentProviders(provider)) {\n            provider = provider.\u0275providers;\n        }\n        if (Array.isArray(provider)) {\n            out.push(...flattenProviders(provider, mapFn));\n        }\n        else {\n            out.push(mapFn(provider));\n        }\n    }\n    return out;\n}\nfunction getProviderField(provider, field) {\n    return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n    return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n    return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n    for (let idx = values.length - 1; idx >= 0; idx--) {\n        fn(values[idx], idx);\n    }\n}\nfunction invalidTypeError(name, expectedType) {\n    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n    testBed;\n    constructor(testBed) {\n        this.testBed = testBed;\n    }\n    compileModuleSync(moduleType) {\n        this.testBed._compileNgModuleSync(moduleType);\n        return new NgModuleFactory(moduleType);\n    }\n    async compileModuleAsync(moduleType) {\n        await this.testBed._compileNgModuleAsync(moduleType);\n        return new NgModuleFactory(moduleType);\n    }\n    compileModuleAndAllComponentsSync(moduleType) {\n        const ngModuleFactory = this.compileModuleSync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    async compileModuleAndAllComponentsAsync(moduleType) {\n        const ngModuleFactory = await this.compileModuleAsync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    clearCache() { }\n    clearCacheFor(type) { }\n    getModuleId(moduleType) {\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\n        return (meta && meta.id) || undefined;\n    }\n}\n\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\n// it on one line, too, which has gotten very hard to read & manage. So disable the formatter for\n// this statement only.\nlet _nextRootElementId = 0;\n/**\n * Returns a singleton of the `TestBed` class.\n *\n * @publicApi\n */\nfunction getTestBed() {\n    return TestBedImpl.INSTANCE;\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n */\nclass TestBedImpl {\n    static _INSTANCE = null;\n    static get INSTANCE() {\n        return (TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl());\n    }\n    /**\n     * Teardown options that have been configured at the environment level.\n     * Used as a fallback if no instance-level options have been provided.\n     */\n    static _environmentTeardownOptions;\n    /**\n     * \"Error on unknown elements\" option that has been configured at the environment level.\n     * Used as a fallback if no instance-level option has been provided.\n     */\n    static _environmentErrorOnUnknownElementsOption;\n    /**\n     * \"Error on unknown properties\" option that has been configured at the environment level.\n     * Used as a fallback if no instance-level option has been provided.\n     */\n    static _environmentErrorOnUnknownPropertiesOption;\n    /**\n     * Teardown options that have been configured at the `TestBed` instance level.\n     * These options take precedence over the environment-level ones.\n     */\n    _instanceTeardownOptions;\n    /**\n     * Defer block behavior option that specifies whether defer blocks will be triggered manually\n     * or set to play through.\n     */\n    _instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    /**\n     * Animations behavior option that specifies whether animations are enabled or disabled.\n     */\n    _instanceAnimationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n    /**\n     * \"Error on unknown elements\" option that has been configured at the `TestBed` instance level.\n     * This option takes precedence over the environment-level one.\n     */\n    _instanceErrorOnUnknownElementsOption;\n    /**\n     * \"Error on unknown properties\" option that has been configured at the `TestBed` instance level.\n     * This option takes precedence over the environment-level one.\n     */\n    _instanceErrorOnUnknownPropertiesOption;\n    /**\n     * Stores the previous \"Error on unknown elements\" option value,\n     * allowing to restore it in the reset testing module logic.\n     */\n    _previousErrorOnUnknownElementsOption;\n    /**\n     * Stores the previous \"Error on unknown properties\" option value,\n     * allowing to restore it in the reset testing module logic.\n     */\n    _previousErrorOnUnknownPropertiesOption;\n    /**\n     * Stores the value for `inferTagName` from the testing module.\n     */\n    _instanceInferTagName;\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule, platform, options) {\n        const testBed = TestBedImpl.INSTANCE;\n        testBed.initTestEnvironment(ngModule, platform, options);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment() {\n        TestBedImpl.INSTANCE.resetTestEnvironment();\n    }\n    static configureCompiler(config) {\n        return TestBedImpl.INSTANCE.configureCompiler(config);\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n        return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n        return TestBedImpl.INSTANCE.compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n        return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n    }\n    static overrideComponent(component, override) {\n        return TestBedImpl.INSTANCE.overrideComponent(component, override);\n    }\n    static overrideDirective(directive, override) {\n        return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n    }\n    static overridePipe(pipe, override) {\n        return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n    }\n    static overrideTemplate(component, template) {\n        return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n    }\n    static overrideProvider(token, provider) {\n        return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n    }\n    static inject(token, notFoundValue, options) {\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, options);\n    }\n    /**\n     * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\n     *\n     * @see {@link https://angular.dev/api/core/EnvironmentInjector#runInContext}\n     */\n    static runInInjectionContext(fn) {\n        return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n    }\n    static createComponent(component, options) {\n        return TestBedImpl.INSTANCE.createComponent(component, options);\n    }\n    static resetTestingModule() {\n        return TestBedImpl.INSTANCE.resetTestingModule();\n    }\n    static execute(tokens, fn, context) {\n        return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n    }\n    static get platform() {\n        return TestBedImpl.INSTANCE.platform;\n    }\n    static get ngModule() {\n        return TestBedImpl.INSTANCE.ngModule;\n    }\n    static flushEffects() {\n        return TestBedImpl.INSTANCE.tick();\n    }\n    static tick() {\n        return TestBedImpl.INSTANCE.tick();\n    }\n    // Properties\n    platform = null;\n    ngModule = null;\n    _compiler = null;\n    _testModuleRef = null;\n    _activeFixtures = [];\n    /**\n     * Internal-only flag to indicate whether a module\n     * scoping queue has been checked and flushed already.\n     * @docs-private\n     */\n    globalCompilationChecked = false;\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule, platform, options) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        TestBedImpl._environmentTeardownOptions = options?.teardown;\n        TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n        TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n        this.platform = platform;\n        this.ngModule = ngModule;\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n        // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n        // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n        // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n        // completely.\n        setAllowDuplicateNgModuleIdsForTest(true);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this._compiler = null;\n        this.platform = null;\n        this.ngModule = null;\n        TestBedImpl._environmentTeardownOptions = undefined;\n        setAllowDuplicateNgModuleIdsForTest(false);\n    }\n    resetTestingModule() {\n        this.checkGlobalCompilationFinished();\n        resetCompiledComponents();\n        if (this._compiler !== null) {\n            this.compiler.restoreOriginalState();\n        }\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n        // Restore the previous value of the \"error on unknown elements\" option\n        _setUnknownElementStrictMode(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n        // Restore the previous value of the \"error on unknown properties\" option\n        _setUnknownPropertyStrictMode(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n        // We have to chain a couple of try/finally blocks, because each step can\n        // throw errors and we don't want it to interrupt the next step and we also\n        // want an error to be thrown at the end.\n        try {\n            this.destroyActiveFixtures();\n        }\n        finally {\n            try {\n                if (this.shouldTearDownTestingModule()) {\n                    this.tearDownTestingModule();\n                }\n            }\n            finally {\n                this._testModuleRef = null;\n                this._instanceTeardownOptions = undefined;\n                this._instanceErrorOnUnknownElementsOption = undefined;\n                this._instanceErrorOnUnknownPropertiesOption = undefined;\n                this._instanceInferTagName = undefined;\n                this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n                this._instanceAnimationsEnabled = ANIMATIONS_ENABLED_DEFAULT;\n            }\n        }\n        return this;\n    }\n    configureCompiler(config) {\n        if (config.useJit != null) {\n            throw new Error('JIT compiler is not configurable via TestBed APIs.');\n        }\n        if (config.providers !== undefined) {\n            this.compiler.setCompilerProviders(config.providers);\n        }\n        return this;\n    }\n    configureTestingModule(moduleDef) {\n        this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n        // Trigger module scoping queue flush before executing other TestBed operations in a test.\n        // This is needed for the first test invocation to ensure that globally declared modules have\n        // their components scoped properly. See the `checkGlobalCompilationFinished` function\n        // description for additional info.\n        this.checkGlobalCompilationFinished();\n        // Always re-assign the options, even if they're undefined.\n        // This ensures that we don't carry them between tests.\n        this._instanceTeardownOptions = moduleDef.teardown;\n        this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n        this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n        this._instanceInferTagName = moduleDef.inferTagName;\n        this._instanceDeferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n        this._instanceAnimationsEnabled = moduleDef.animationsEnabled ?? ANIMATIONS_ENABLED_DEFAULT;\n        // Store the current value of the strict mode option,\n        // so we can restore it later\n        this._previousErrorOnUnknownElementsOption = _getUnknownElementStrictMode();\n        _setUnknownElementStrictMode(this.shouldThrowErrorOnUnknownElements());\n        this._previousErrorOnUnknownPropertiesOption = _getUnknownPropertyStrictMode();\n        _setUnknownPropertyStrictMode(this.shouldThrowErrorOnUnknownProperties());\n        this.compiler.configureTestingModule(moduleDef);\n        return this;\n    }\n    compileComponents() {\n        return this.compiler.compileComponents();\n    }\n    inject(token, notFoundValue, options) {\n        if (token === TestBed) {\n            return this;\n        }\n        const UNDEFINED = {};\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, options);\n        return result === UNDEFINED\n            ? this.compiler.injector.get(token, notFoundValue, options)\n            : result;\n    }\n    runInInjectionContext(fn) {\n        return runInInjectionContext(this.inject(EnvironmentInjector), fn);\n    }\n    execute(tokens, fn, context) {\n        const params = tokens.map((t) => this.inject(t));\n        return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\n        this.compiler.overrideModule(ngModule, override);\n        return this;\n    }\n    overrideComponent(component, override) {\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\n        this.compiler.overrideComponent(component, override);\n        return this;\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n        this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\n        return this;\n    }\n    overrideDirective(directive, override) {\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this.compiler.overrideDirective(directive, override);\n        return this;\n    }\n    overridePipe(pipe, override) {\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this.compiler.overridePipe(pipe, override);\n        return this;\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token, provider) {\n        this.assertNotInstantiated('overrideProvider', 'override provider');\n        this.compiler.overrideProvider(token, provider);\n        return this;\n    }\n    overrideTemplate(component, template) {\n        return this.overrideComponent(component, { set: { template, templateUrl: null } });\n    }\n    createComponent(type, options) {\n        if (getAsyncClassMetadataFn(type)) {\n            throw new Error(`Component '${type.name}' has unresolved metadata. ` +\n                `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n        }\n        // Note: injecting the renderer before accessing the definition appears to be load-bearing.\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        const shouldInferTagName = options?.inferTagName ?? this._instanceInferTagName ?? false;\n        const componentDef = getComponentDef$1(type);\n        const rootElId = `root${_nextRootElementId++}`;\n        if (!componentDef) {\n            throw new Error(`It looks like '${stringify(type)}' has not been compiled.`);\n        }\n        testComponentRenderer.insertRootElement(rootElId, shouldInferTagName ? inferTagNameFromDefinition(componentDef) : undefined);\n        const componentFactory = new ComponentFactory(componentDef);\n        const initComponent = () => {\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef, undefined, options?.bindings);\n            return this.runInInjectionContext(() => new ComponentFixture(componentRef));\n        };\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get compiler() {\n        if (this._compiler === null) {\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n        }\n        return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get testModuleRef() {\n        if (this._testModuleRef === null) {\n            this._testModuleRef = this.compiler.finalize();\n        }\n        return this._testModuleRef;\n    }\n    assertNotInstantiated(methodName, methodDescription) {\n        if (this._testModuleRef !== null) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n    checkGlobalCompilationFinished() {\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n        if (!this.globalCompilationChecked && this._testModuleRef === null) {\n            flushModuleScopingQueueAsMuchAsPossible();\n        }\n        this.globalCompilationChecked = true;\n    }\n    destroyActiveFixtures() {\n        let errorCount = 0;\n        this._activeFixtures.forEach((fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                errorCount++;\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n            throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` +\n                `threw errors during cleanup`);\n        }\n    }\n    shouldRethrowTeardownErrors() {\n        const instanceOptions = this._instanceTeardownOptions;\n        const environmentOptions = TestBedImpl._environmentTeardownOptions;\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\n        if (!instanceOptions && !environmentOptions) {\n            return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n        }\n        // Otherwise use the configured behavior or default to rethrowing.\n        return (instanceOptions?.rethrowErrors ??\n            environmentOptions?.rethrowErrors ??\n            this.shouldTearDownTestingModule());\n    }\n    shouldThrowErrorOnUnknownElements() {\n        // Check if a configuration has been provided to throw when an unknown element is found\n        return (this._instanceErrorOnUnknownElementsOption ??\n            TestBedImpl._environmentErrorOnUnknownElementsOption ??\n            THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n    }\n    shouldThrowErrorOnUnknownProperties() {\n        // Check if a configuration has been provided to throw when an unknown property is found\n        return (this._instanceErrorOnUnknownPropertiesOption ??\n            TestBedImpl._environmentErrorOnUnknownPropertiesOption ??\n            THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n    }\n    shouldTearDownTestingModule() {\n        return (this._instanceTeardownOptions?.destroyAfterEach ??\n            TestBedImpl._environmentTeardownOptions?.destroyAfterEach ??\n            TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT);\n    }\n    getDeferBlockBehavior() {\n        return this._instanceDeferBlockBehavior;\n    }\n    getAnimationsEnabled() {\n        return this._instanceAnimationsEnabled;\n    }\n    tearDownTestingModule() {\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\n        if (this._testModuleRef === null) {\n            return;\n        }\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\n        const testRenderer = this.inject(TestComponentRenderer);\n        try {\n            this._testModuleRef.destroy();\n        }\n        catch (e) {\n            if (this.shouldRethrowTeardownErrors()) {\n                throw e;\n            }\n            else {\n                console.error('Error during cleanup of a testing module', {\n                    component: this._testModuleRef.instance,\n                    stacktrace: e,\n                });\n            }\n        }\n        finally {\n            testRenderer.removeAllRootElements?.();\n        }\n    }\n    /**\n     * Execute any pending effects by executing any pending work required to synchronize model to the UI.\n     *\n     * @deprecated use `TestBed.tick()` instead\n     */\n    flushEffects() {\n        this.tick();\n    }\n    /**\n     * Execute any pending work required to synchronize model to the UI.\n     *\n     * @publicApi\n     */\n    tick() {\n        const appRef = this.inject(ApplicationRef);\n        try {\n            // TODO(atscott): ApplicationRef.tick should set includeAllTestViews to true itself rather than doing this here and in ComponentFixture\n            // The behavior should be that TestBed.tick, ComponentFixture.detectChanges, and ApplicationRef.tick all result in the test fixtures\n            // getting synchronized, regardless of whether they are autoDetect: true.\n            // Automatic scheduling (zone or zoneless) will call _tick which will _not_ include fixtures with autoDetect: false\n            appRef.includeAllTestViews = true;\n            appRef.tick();\n        }\n        finally {\n            appRef.includeAllTestViews = false;\n        }\n    }\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * @publicApi\n */\nconst TestBed = TestBedImpl;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```ts\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n    const testBed = TestBedImpl.INSTANCE;\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        return testBed.execute(tokens, fn, this);\n    };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n    _moduleDef;\n    constructor(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    _addModule() {\n        const moduleDef = this._moduleDef();\n        if (moduleDef) {\n            TestBedImpl.configureTestingModule(moduleDef);\n        }\n    }\n    inject(tokens, fn) {\n        const self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        };\n    }\n}\nfunction withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            const testBed = TestBedImpl.INSTANCE;\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        };\n    }\n    return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * Fake implementation of user agent history and navigation behavior. This is a\n * high-fidelity implementation of browser behavior that attempts to emulate\n * things like traversal delay.\n */\nclass FakeNavigation {\n    /**\n     * The fake implementation of an entries array. Only same-document entries\n     * allowed.\n     */\n    entriesArr = [];\n    /**\n     * The current active entry index into `entriesArr`.\n     */\n    currentEntryIndex = 0;\n    /**\n     * The current navigate event.\n     * @internal\n     */\n    navigateEvent = null;\n    /**\n     * A Map of pending traversals, so that traversals to the same entry can be\n     * re-used.\n     */\n    traversalQueue = new Map();\n    /**\n     * A Promise that resolves when the previous traversals have finished. Used to\n     * simulate the cross-process communication necessary for traversals.\n     */\n    nextTraversal = Promise.resolve();\n    /**\n     * A prospective current active entry index, which includes unresolved\n     * traversals. Used by `go` to determine where navigations are intended to go.\n     */\n    prospectiveEntryIndex = 0;\n    /**\n     * A test-only option to make traversals synchronous, rather than emulate\n     * cross-process communication.\n     */\n    synchronousTraversals = false;\n    /** Whether to allow a call to setInitialEntryForTesting. */\n    canSetInitialEntry = true;\n    /**\n     * `EventTarget` to dispatch events.\n     * @internal\n     */\n    eventTarget;\n    /** The next unique id for created entries. Replace recreates this id. */\n    nextId = 0;\n    /** The next unique key for created entries. Replace inherits this id. */\n    nextKey = 0;\n    /** Whether this fake is disposed. */\n    disposed = false;\n    /** Equivalent to `navigation.currentEntry`. */\n    get currentEntry() {\n        return this.entriesArr[this.currentEntryIndex];\n    }\n    get canGoBack() {\n        return this.currentEntryIndex > 0;\n    }\n    get canGoForward() {\n        return this.currentEntryIndex < this.entriesArr.length - 1;\n    }\n    createEventTarget;\n    _window;\n    get window() {\n        return this._window;\n    }\n    constructor(doc, startURL) {\n        this.createEventTarget = () => {\n            try {\n                // `document.createElement` because NodeJS `EventTarget` is\n                // incompatible with Domino's `Event`. That is, attempting to\n                // dispatch an event created by Domino's patched `Event` will\n                // throw an error since it is not an instance of a real Node\n                // `Event`.\n                return doc.createElement('div');\n            }\n            catch {\n                // Fallback to a basic EventTarget if `document.createElement`\n                // fails. This can happen with tests that pass in a value for document\n                // that is stubbed.\n                return new EventTarget();\n            }\n        };\n        this._window = document.defaultView ?? this.createEventTarget();\n        this.eventTarget = this.createEventTarget();\n        // First entry.\n        this.setInitialEntryForTesting(startURL);\n    }\n    /**\n     * Sets the initial entry.\n     */\n    setInitialEntryForTesting(url, options = { historyState: null }) {\n        if (!this.canSetInitialEntry) {\n            throw new Error('setInitialEntryForTesting can only be called before any ' + 'navigation has occurred');\n        }\n        const currentInitialEntry = this.entriesArr[0];\n        this.entriesArr[0] = new FakeNavigationHistoryEntry(this.eventTarget, new URL(url).toString(), {\n            index: 0,\n            key: currentInitialEntry?.key ?? String(this.nextKey++),\n            id: currentInitialEntry?.id ?? String(this.nextId++),\n            sameDocument: true,\n            historyState: options?.historyState,\n            state: options.state,\n        });\n    }\n    /** Returns whether the initial entry is still eligible to be set. */\n    canSetInitialEntryForTesting() {\n        return this.canSetInitialEntry;\n    }\n    /**\n     * Sets whether to emulate traversals as synchronous rather than\n     * asynchronous.\n     */\n    setSynchronousTraversalsForTesting(synchronousTraversals) {\n        this.synchronousTraversals = synchronousTraversals;\n    }\n    /** Equivalent to `navigation.entries()`. */\n    entries() {\n        return this.entriesArr.slice();\n    }\n    /** Equivalent to `navigation.navigate()`. */\n    navigate(url, options) {\n        const fromUrl = new URL(this.currentEntry.url);\n        const toUrl = new URL(url, this.currentEntry.url);\n        let navigationType;\n        if (!options?.history || options.history === 'auto') {\n            // Auto defaults to push, but if the URLs are the same, is a replace.\n            if (fromUrl.toString() === toUrl.toString()) {\n                navigationType = 'replace';\n            }\n            else {\n                navigationType = 'push';\n            }\n        }\n        else {\n            navigationType = options.history;\n        }\n        const hashChange = isHashChange(fromUrl, toUrl);\n        const destination = new FakeNavigationDestination({\n            url: toUrl.toString(),\n            state: options?.state,\n            sameDocument: hashChange,\n            historyState: null,\n        });\n        const result = new InternalNavigationResult(this);\n        const intercepted = this.userAgentNavigate(destination, result, {\n            navigationType,\n            cancelable: true,\n            canIntercept: true,\n            // Always false for navigate().\n            userInitiated: false,\n            hashChange,\n            info: options?.info,\n        });\n        if (!intercepted) {\n            this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent);\n        }\n        return {\n            committed: result.committed,\n            finished: result.finished,\n        };\n    }\n    /** Equivalent to `history.pushState()`. */\n    pushState(data, title, url) {\n        this.pushOrReplaceState('push', data, title, url);\n    }\n    /** Equivalent to `history.replaceState()`. */\n    replaceState(data, title, url) {\n        this.pushOrReplaceState('replace', data, title, url);\n    }\n    pushOrReplaceState(navigationType, data, _title, url) {\n        const fromUrl = new URL(this.currentEntry.url);\n        const toUrl = url ? new URL(url, this.currentEntry.url) : fromUrl;\n        const hashChange = isHashChange(fromUrl, toUrl);\n        const destination = new FakeNavigationDestination({\n            url: toUrl.toString(),\n            sameDocument: true, // history.pushState/replaceState are always same-document\n            historyState: data,\n            state: undefined, // No Navigation API state directly from history.pushState\n        });\n        const result = new InternalNavigationResult(this);\n        const intercepted = this.userAgentNavigate(destination, result, {\n            navigationType,\n            cancelable: true,\n            canIntercept: true,\n            // Always false for pushState() or replaceState().\n            userInitiated: false,\n            hashChange,\n        });\n        if (intercepted) {\n            return;\n        }\n        this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent);\n    }\n    /** Equivalent to `navigation.traverseTo()`. */\n    traverseTo(key, options) {\n        const fromUrl = new URL(this.currentEntry.url);\n        const entry = this.findEntry(key);\n        if (!entry) {\n            const domException = new DOMException('Invalid key', 'InvalidStateError');\n            const committed = Promise.reject(domException);\n            const finished = Promise.reject(domException);\n            committed.catch(() => { });\n            finished.catch(() => { });\n            return {\n                committed,\n                finished,\n            };\n        }\n        if (entry === this.currentEntry) {\n            return {\n                committed: Promise.resolve(this.currentEntry),\n                finished: Promise.resolve(this.currentEntry),\n            };\n        }\n        if (this.traversalQueue.has(entry.key)) {\n            const existingResult = this.traversalQueue.get(entry.key);\n            return {\n                committed: existingResult.committed,\n                finished: existingResult.finished,\n            };\n        }\n        const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n        const destination = new FakeNavigationDestination({\n            url: entry.url,\n            state: entry.getState(),\n            historyState: entry.getHistoryState(),\n            key: entry.key,\n            id: entry.id,\n            index: entry.index,\n            sameDocument: entry.sameDocument,\n        });\n        this.prospectiveEntryIndex = entry.index;\n        const result = new InternalNavigationResult(this);\n        this.traversalQueue.set(entry.key, result);\n        this.runTraversal(() => {\n            this.traversalQueue.delete(entry.key);\n            const intercepted = this.userAgentNavigate(destination, result, {\n                navigationType: 'traverse',\n                cancelable: true,\n                canIntercept: true,\n                // Always false for traverseTo().\n                userInitiated: false,\n                hashChange,\n                info: options?.info,\n            });\n            if (!intercepted) {\n                this.userAgentTraverse(this.navigateEvent);\n            }\n        });\n        return {\n            committed: result.committed,\n            finished: result.finished,\n        };\n    }\n    /** Equivalent to `navigation.back()`. */\n    back(options) {\n        if (this.currentEntryIndex === 0) {\n            const domException = new DOMException('Cannot go back', 'InvalidStateError');\n            const committed = Promise.reject(domException);\n            const finished = Promise.reject(domException);\n            committed.catch(() => { });\n            finished.catch(() => { });\n            return {\n                committed,\n                finished,\n            };\n        }\n        const entry = this.entriesArr[this.currentEntryIndex - 1];\n        return this.traverseTo(entry.key, options);\n    }\n    /** Equivalent to `navigation.forward()`. */\n    forward(options) {\n        if (this.currentEntryIndex === this.entriesArr.length - 1) {\n            const domException = new DOMException('Cannot go forward', 'InvalidStateError');\n            const committed = Promise.reject(domException);\n            const finished = Promise.reject(domException);\n            committed.catch(() => { });\n            finished.catch(() => { });\n            return {\n                committed,\n                finished,\n            };\n        }\n        const entry = this.entriesArr[this.currentEntryIndex + 1];\n        return this.traverseTo(entry.key, options);\n    }\n    /**\n     * Equivalent to `history.go()`.\n     * Note that this method does not actually work precisely to how Chrome\n     * does, instead choosing a simpler model with less unexpected behavior.\n     * Chrome has a few edge case optimizations, for instance with repeated\n     * `back(); forward()` chains it collapses certain traversals.\n     */\n    go(direction) {\n        const targetIndex = this.prospectiveEntryIndex + direction;\n        if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n            return;\n        }\n        this.prospectiveEntryIndex = targetIndex;\n        this.runTraversal(() => {\n            // Check again that destination is in the entries array.\n            if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n                return;\n            }\n            const fromUrl = new URL(this.currentEntry.url);\n            const entry = this.entriesArr[targetIndex];\n            const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n            const destination = new FakeNavigationDestination({\n                url: entry.url,\n                state: entry.getState(),\n                historyState: entry.getHistoryState(),\n                key: entry.key,\n                id: entry.id,\n                index: entry.index,\n                sameDocument: entry.sameDocument,\n            });\n            const result = new InternalNavigationResult(this);\n            const intercepted = this.userAgentNavigate(destination, result, {\n                navigationType: 'traverse',\n                cancelable: true,\n                canIntercept: true,\n                // Always false for go().\n                userInitiated: false,\n                hashChange,\n            });\n            if (!intercepted) {\n                this.userAgentTraverse(this.navigateEvent);\n            }\n        });\n    }\n    /** Runs a traversal synchronously or asynchronously */\n    runTraversal(traversal) {\n        if (this.synchronousTraversals) {\n            traversal();\n            return;\n        }\n        // Each traversal occupies a single timeout resolution.\n        // This means that Promises added to commit and finish should resolve\n        // before the next traversal.\n        this.nextTraversal = this.nextTraversal.then(() => {\n            return new Promise((resolve) => {\n                setTimeout(() => {\n                    resolve();\n                    traversal();\n                });\n            });\n        });\n    }\n    /** Equivalent to `navigation.addEventListener()`. */\n    addEventListener(type, callback, options) {\n        this.eventTarget.addEventListener(type, callback, options);\n    }\n    /** Equivalent to `navigation.removeEventListener()`. */\n    removeEventListener(type, callback, options) {\n        this.eventTarget.removeEventListener(type, callback, options);\n    }\n    /** Equivalent to `navigation.dispatchEvent()` */\n    dispatchEvent(event) {\n        return this.eventTarget.dispatchEvent(event);\n    }\n    /** Cleans up resources. */\n    dispose() {\n        // Recreate eventTarget to release current listeners.\n        this.eventTarget = this.createEventTarget();\n        this.disposed = true;\n    }\n    /** Returns whether this fake is disposed. */\n    isDisposed() {\n        return this.disposed;\n    }\n    abortOngoingNavigation(eventToAbort, reason) {\n        if (this.navigateEvent !== eventToAbort) {\n            return;\n        }\n        if (this.navigateEvent.abortController.signal.aborted) {\n            return;\n        }\n        const abortReason = reason ?? new DOMException('Navigation aborted', 'AbortError');\n        this.navigateEvent.cancel(abortReason);\n    }\n    /**\n     * Implementation for all navigations and traversals.\n     * @returns true if the event was intercepted, otherwise false\n     */\n    userAgentNavigate(destination, result, options) {\n        // The first navigation should disallow any future calls to set the initial\n        // entry.\n        this.canSetInitialEntry = false;\n        if (this.navigateEvent) {\n            this.abortOngoingNavigation(this.navigateEvent, new DOMException('Navigation superseded by a new navigation.', 'AbortError'));\n        }\n        // TODO(atscott): Disposing doesn't really do much because new requests are still processed\n        // if (this.disposed) {\n        //   return false;\n        // }\n        const dispatchResultIsTrueIfNoInterception = dispatchNavigateEvent({\n            navigationType: options.navigationType,\n            cancelable: options.cancelable,\n            canIntercept: options.canIntercept,\n            userInitiated: options.userInitiated,\n            hashChange: options.hashChange,\n            destination,\n            info: options.info,\n            sameDocument: destination.sameDocument,\n            result,\n        });\n        return !dispatchResultIsTrueIfNoInterception;\n    }\n    /**\n     * Implementation for a push or replace navigation.\n     * https://whatpr.org/html/10919/browsing-the-web.html#url-and-history-update-steps\n     * https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n     * @internal\n     */\n    urlAndHistoryUpdateSteps(navigateEvent) {\n        this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n    }\n    /**\n     * Implementation for a traverse navigation.\n     *\n     * https://whatpr.org/html/10919/browsing-the-web.html#apply-the-traverse-history-step\n     * ...\n     * > Let updateDocument be an algorithm step which performs update document for history step application given targetEntry's document, targetEntry, changingNavigableContinuation's update-only, scriptHistoryLength, scriptHistoryIndex, navigationType, entriesForNavigationAPI, and previousEntry.\n     * > If targetEntry's document is equal to displayedDocument, then perform updateDocument.\n     * https://whatpr.org/html/10919/browsing-the-web.html#update-document-for-history-step-application\n     * which then goes to https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n     * @internal\n     */\n    userAgentTraverse(navigateEvent) {\n        const oldUrl = this.currentEntry.url;\n        this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n        // Happens as part of \"updating the document\" steps https://whatpr.org/html/10919/browsing-the-web.html#updating-the-document\n        const popStateEvent = createPopStateEvent({\n            state: navigateEvent.destination.getHistoryState(),\n        });\n        this._window.dispatchEvent(popStateEvent);\n        if (navigateEvent.hashChange) {\n            const hashchangeEvent = createHashChangeEvent(oldUrl, this.currentEntry.url);\n            this._window.dispatchEvent(hashchangeEvent);\n        }\n    }\n    /**\n     * https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n     * @internal\n     */\n    updateNavigationEntriesForSameDocumentNavigation({ destination, navigationType, result, }) {\n        const oldCurrentNHE = this.currentEntry;\n        const disposedNHEs = [];\n        if (navigationType === 'traverse') {\n            this.currentEntryIndex = destination.index;\n            if (this.currentEntryIndex === -1) {\n                throw new Error('unexpected current entry index');\n            }\n        }\n        else if (navigationType === 'push') {\n            this.currentEntryIndex++;\n            this.prospectiveEntryIndex = this.currentEntryIndex; // prospectiveEntryIndex isn't in the spec but is an implementation detail\n            disposedNHEs.push(...this.entriesArr.splice(this.currentEntryIndex));\n        }\n        else if (navigationType === 'replace') {\n            disposedNHEs.push(oldCurrentNHE);\n        }\n        if (navigationType === 'push' || navigationType === 'replace') {\n            const index = this.currentEntryIndex;\n            const key = navigationType === 'push'\n                ? String(this.nextKey++)\n                : (oldCurrentNHE?.key ?? String(this.nextKey++));\n            const newNHE = new FakeNavigationHistoryEntry(this.eventTarget, destination.url, {\n                id: String(this.nextId++),\n                key,\n                index,\n                sameDocument: true,\n                state: destination.getState(),\n                historyState: destination.getHistoryState(),\n            });\n            this.entriesArr[this.currentEntryIndex] = newNHE;\n        }\n        result.committedResolve(this.currentEntry);\n        const currentEntryChangeEvent = createFakeNavigationCurrentEntryChangeEvent({\n            from: oldCurrentNHE,\n            navigationType: navigationType,\n        });\n        this.eventTarget.dispatchEvent(currentEntryChangeEvent);\n        for (const disposedNHE of disposedNHEs) {\n            disposedNHE.dispose();\n        }\n    }\n    /** Utility method for finding entries with the given `key`. */\n    findEntry(key) {\n        for (const entry of this.entriesArr) {\n            if (entry.key === key)\n                return entry;\n        }\n        return undefined;\n    }\n    set onnavigate(\n    // tslint:disable-next-line:no-any\n    _handler) {\n        throw new Error('unimplemented');\n    }\n    // tslint:disable-next-line:no-any\n    get onnavigate() {\n        throw new Error('unimplemented');\n    }\n    set oncurrententrychange(_handler) {\n        throw new Error('unimplemented');\n    }\n    get oncurrententrychange() {\n        throw new Error('unimplemented');\n    }\n    set onnavigatesuccess(\n    // tslint:disable-next-line:no-any\n    _handler) {\n        throw new Error('unimplemented');\n    }\n    // tslint:disable-next-line:no-any\n    get onnavigatesuccess() {\n        throw new Error('unimplemented');\n    }\n    set onnavigateerror(\n    // tslint:disable-next-line:no-any\n    _handler) {\n        throw new Error('unimplemented');\n    }\n    // tslint:disable-next-line:no-any\n    get onnavigateerror() {\n        throw new Error('unimplemented');\n    }\n    _transition = null;\n    /** @internal */\n    set transition(t) {\n        this._transition = t;\n    }\n    get transition() {\n        return this._transition;\n    }\n    updateCurrentEntry(_options) {\n        throw new Error('unimplemented');\n    }\n    reload(_options) {\n        throw new Error('unimplemented');\n    }\n}\n/**\n * Fake equivalent of `NavigationHistoryEntry`.\n */\nclass FakeNavigationHistoryEntry {\n    eventTarget;\n    url;\n    sameDocument;\n    id;\n    key;\n    index;\n    state;\n    historyState;\n    // tslint:disable-next-line:no-any\n    ondispose = null;\n    constructor(eventTarget, url, { id, key, index, sameDocument, state, historyState, }) {\n        this.eventTarget = eventTarget;\n        this.url = url;\n        this.id = id;\n        this.key = key;\n        this.index = index;\n        this.sameDocument = sameDocument;\n        this.state = state;\n        this.historyState = historyState;\n    }\n    getState() {\n        // Budget copy.\n        return this.state ? JSON.parse(JSON.stringify(this.state)) : this.state;\n    }\n    getHistoryState() {\n        // Budget copy.\n        return this.historyState\n            ? JSON.parse(JSON.stringify(this.historyState))\n            : this.historyState;\n    }\n    addEventListener(type, callback, options) {\n        this.eventTarget.addEventListener(type, callback, options);\n    }\n    removeEventListener(type, callback, options) {\n        this.eventTarget.removeEventListener(type, callback, options);\n    }\n    dispatchEvent(event) {\n        return this.eventTarget.dispatchEvent(event);\n    }\n    /** internal */\n    dispose() {\n        const disposeEvent = new Event('disposed');\n        this.dispatchEvent(disposeEvent);\n        // release current listeners\n        this.eventTarget = null;\n    }\n}\n/**\n * Create a fake equivalent of `NavigateEvent`. This is not a class because ES5\n * transpiled JavaScript cannot extend native Event.\n *\n * https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigate-event-firing\n */\nfunction dispatchNavigateEvent({ cancelable, canIntercept, userInitiated, hashChange, navigationType, destination, info, sameDocument, result, }) {\n    const { navigation } = result;\n    const eventAbortController = new AbortController();\n    const event = new Event('navigate', { bubbles: false, cancelable });\n    event.navigationType = navigationType;\n    event.destination = destination;\n    event.canIntercept = canIntercept;\n    event.userInitiated = userInitiated;\n    event.hashChange = hashChange;\n    event.signal = eventAbortController.signal;\n    event.abortController = eventAbortController;\n    event.info = info;\n    event.focusResetBehavior = null;\n    event.scrollBehavior = null;\n    event.interceptionState = 'none';\n    event.downloadRequest = null;\n    event.formData = null;\n    event.result = result;\n    event.sameDocument = sameDocument;\n    let precommitHandlers = [];\n    let handlers = [];\n    // https://whatpr.org/html/10919/nav-history-apis.html#dom-navigateevent-intercept\n    event.intercept = function (options) {\n        if (!this.canIntercept) {\n            throw new DOMException(`Cannot intercept when canIntercept is 'false'`, 'SecurityError');\n        }\n        this.interceptionState = 'intercepted';\n        event.sameDocument = true;\n        const precommitHandler = options?.precommitHandler;\n        if (precommitHandler) {\n            if (!this.cancelable) {\n                throw new DOMException(`Cannot use precommitHandler when cancelable is 'false'`, 'InvalidStateError');\n            }\n            precommitHandlers.push(precommitHandler);\n        }\n        if (event.interceptionState !== 'none' && event.interceptionState !== 'intercepted') {\n            throw new Error('Event interceptionState should be \"none\" or \"intercepted\"');\n        }\n        event.interceptionState = 'intercepted';\n        const handler = options?.handler;\n        if (handler) {\n            handlers.push(handler);\n        }\n        // override old options with new ones. UA _may_ report a console warning if new options differ from previous\n        event.focusResetBehavior = options?.focusReset ?? event.focusResetBehavior;\n        event.scrollBehavior = options?.scroll ?? event.scrollBehavior;\n    };\n    // https://whatpr.org/html/10919/nav-history-apis.html#dom-navigateevent-scroll\n    event.scroll = function () {\n        if (event.interceptionState !== 'committed') {\n            throw new DOMException(`Failed to execute 'scroll' on 'NavigateEvent': scroll() must be ` +\n                `called after commit() and interception options must specify manual scroll.`, 'InvalidStateError');\n        }\n        processScrollBehavior(event);\n    };\n    // https://whatpr.org/html/10919/nav-history-apis.html#dom-navigationprecommitcontroller-redirect\n    function redirect(url, options = {}) {\n        if (event.interceptionState === 'none') {\n            throw new Error('cannot redirect when event is not intercepted');\n        }\n        if (event.interceptionState !== 'intercepted') {\n            throw new DOMException(`cannot redirect when event is not in 'intercepted' state`, 'InvalidStateError');\n        }\n        if (event.navigationType !== 'push' && event.navigationType !== 'replace') {\n            throw new DOMException(`cannot redirect when navigationType is not 'push' or 'replace`, 'InvalidStateError');\n        }\n        const destinationUrl = new URL(url, navigation.currentEntry.url);\n        if (options.history === 'push' || options.history === 'replace') {\n            event.navigationType = options.history;\n        }\n        if (options.hasOwnProperty('state')) {\n            event.destination.state = options.state;\n        }\n        event.destination.url = destinationUrl.href;\n        if (options.hasOwnProperty('info')) {\n            event.info = options.info;\n        }\n    }\n    // https://whatpr.org/html/10919/nav-history-apis.html#inner-navigate-event-firing-algorithm\n    // \"Let commit be the following steps:\"\n    function commit() {\n        if (result.signal.aborted) {\n            return;\n        }\n        navigation.transition?.committedResolve();\n        if (event.interceptionState === 'intercepted') {\n            event.interceptionState = 'committed';\n            switch (event.navigationType) {\n                case 'push':\n                case 'replace': {\n                    navigation.urlAndHistoryUpdateSteps(event);\n                    break;\n                }\n                case 'reload': {\n                    navigation.updateNavigationEntriesForSameDocumentNavigation(event);\n                    break;\n                }\n                case 'traverse': {\n                    navigation.userAgentTraverse(event);\n                    break;\n                }\n            }\n        }\n        const promisesList = handlers.map((handler) => handler());\n        if (promisesList.length === 0) {\n            promisesList.push(Promise.resolve());\n        }\n        Promise.all(promisesList)\n            .then(() => {\n            // Follows steps outlined under \"Wait for all of promisesList, with the following success steps:\"\n            // in the spec https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigate-event-firing.\n            if (result.signal.aborted) {\n                return;\n            }\n            if (event !== navigation.navigateEvent) {\n                if (!result.signal.aborted && result.committedTo) {\n                    result.finishedReject(new DOMException('Navigation superseded before handler completion', 'AbortError'));\n                }\n                return;\n            }\n            navigation.navigateEvent = null;\n            finishNavigationEvent(event, true);\n            result.finishedResolve();\n            const navigatesuccessEvent = new Event('navigatesuccess', {\n                bubbles: false,\n                cancelable: false,\n            });\n            navigation.eventTarget.dispatchEvent(navigatesuccessEvent);\n            navigation.transition?.finishedResolve();\n            navigation.transition = null;\n        })\n            .catch((reason) => {\n            if (!event.abortController.signal.aborted) {\n                event.cancel(reason);\n            }\n        });\n    }\n    // Internal only.\n    // https://whatpr.org/html/10919/nav-history-apis.html#inner-navigate-event-firing-algorithm\n    // \"Let cancel be the following steps given reason\"\n    event.cancel = function (reason) {\n        if (result.signal.aborted) {\n            return;\n        }\n        this.abortController.abort(reason);\n        const isCurrentGlobalNavigationEvent = this === navigation.navigateEvent;\n        if (isCurrentGlobalNavigationEvent) {\n            navigation.navigateEvent = null;\n        }\n        if (this.interceptionState !== 'intercepted' && this.interceptionState !== 'finished') {\n            finishNavigationEvent(this, false);\n        }\n        else if (this.interceptionState === 'intercepted') {\n            this.interceptionState = 'finished';\n        }\n        result.committedReject(reason);\n        result.finishedReject(reason);\n        const navigateerrorEvent = new Event('navigateerror', {\n            bubbles: false,\n            cancelable,\n        });\n        navigateerrorEvent.error = reason;\n        navigation.eventTarget.dispatchEvent(navigateerrorEvent);\n        const transition = navigation.transition;\n        transition?.committedReject(reason);\n        transition?.finishedReject(reason);\n        navigation.transition = null;\n    };\n    function dispatch() {\n        navigation.navigateEvent = event;\n        const dispatchResult = navigation.eventTarget.dispatchEvent(event);\n        if (event.interceptionState === 'intercepted') {\n            if (!navigation.currentEntry) {\n                event.cancel(new DOMException('Cannot create transition without a currentEntry for intercepted navigation.', 'InvalidStateError'));\n                return;\n            }\n            const transition = new InternalNavigationTransition(navigation.currentEntry, navigationType);\n            navigation.transition = transition;\n            // Mark transition.finished as handled (Spec Step 33.4)\n            transition.finished.catch(() => { });\n            transition.committed.catch(() => { });\n        }\n        if (!dispatchResult && event.cancelable) {\n            if (!event.abortController.signal.aborted) {\n                event.cancel(new DOMException('Navigation prevented by event.preventDefault()', 'AbortError'));\n            }\n        }\n        else {\n            if (precommitHandlers.length === 0) {\n                commit();\n            }\n            else {\n                const precommitController = { redirect };\n                const precommitPromisesList = precommitHandlers.map((handler) => {\n                    let p;\n                    try {\n                        p = handler(precommitController);\n                    }\n                    catch (e) {\n                        p = Promise.reject(e);\n                    }\n                    p.catch(() => { });\n                    return p;\n                });\n                Promise.all(precommitPromisesList)\n                    .then(() => commit())\n                    .catch((reason) => {\n                    if (event.abortController.signal.aborted) {\n                        return;\n                    }\n                    if (navigation.transition) {\n                        navigation.transition.committedReject(reason);\n                    }\n                    event.cancel(reason);\n                });\n            }\n        }\n    }\n    dispatch();\n    return event.interceptionState === 'none';\n}\n/** https://whatpr.org/html/10919/nav-history-apis.html#navigateevent-finish */\nfunction finishNavigationEvent(event, didFulfill) {\n    if (event.interceptionState === 'finished') {\n        throw new Error('Attempting to finish navigation event that was already finished');\n    }\n    if (event.interceptionState === 'intercepted') {\n        if (didFulfill === true) {\n            throw new Error('didFulfill should be false');\n        }\n        event.interceptionState = 'finished';\n        return;\n    }\n    if (event.interceptionState === 'none') {\n        return;\n    }\n    potentiallyResetFocus(event);\n    if (didFulfill) {\n        potentiallyResetScroll(event);\n    }\n    event.interceptionState = 'finished';\n}\n/** https://whatpr.org/html/10919/nav-history-apis.html#potentially-reset-the-focus */\nfunction potentiallyResetFocus(event) {\n    if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n        throw new Error('cannot reset focus if navigation event is not committed or scrolled');\n    }\n    if (event.focusResetBehavior === 'manual') {\n        return;\n    }\n    // TODO(atscott): the rest of the steps\n}\nfunction potentiallyResetScroll(event) {\n    if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n        throw new Error('cannot reset scroll if navigation event is not committed or scrolled');\n    }\n    if (event.interceptionState === 'scrolled' || event.scrollBehavior === 'manual') {\n        return;\n    }\n    processScrollBehavior(event);\n}\n/* https://whatpr.org/html/10919/nav-history-apis.html#process-scroll-behavior */\nfunction processScrollBehavior(event) {\n    if (event.interceptionState !== 'committed') {\n        throw new Error('invalid event interception state when processing scroll behavior');\n    }\n    event.interceptionState = 'scrolled';\n    // TODO(atscott): the rest of the steps\n}\n/**\n * Create a fake equivalent of `NavigationCurrentEntryChange`. This does not use\n * a class because ES5 transpiled JavaScript cannot extend native Event.\n */\nfunction createFakeNavigationCurrentEntryChangeEvent({ from, navigationType, }) {\n    const event = new Event('currententrychange', {\n        bubbles: false,\n        cancelable: false,\n    });\n    event.from = from;\n    event.navigationType = navigationType;\n    return event;\n}\n/**\n * Create a fake equivalent of `PopStateEvent`. This does not use a class\n * because ES5 transpiled JavaScript cannot extend native Event.\n */\nfunction createPopStateEvent({ state }) {\n    const event = new Event('popstate', {\n        bubbles: false,\n        cancelable: false,\n    });\n    event.state = state;\n    return event;\n}\nfunction createHashChangeEvent(newURL, oldURL) {\n    const event = new Event('hashchange', {\n        bubbles: false,\n        cancelable: false,\n    });\n    event.newURL = newURL;\n    event.oldURL = oldURL;\n    return event;\n}\n/**\n * Fake equivalent of `NavigationDestination`.\n */\nclass FakeNavigationDestination {\n    url;\n    sameDocument;\n    key;\n    id;\n    index;\n    state;\n    historyState;\n    constructor({ url, sameDocument, historyState, state, key = null, id = null, index = -1, }) {\n        this.url = url;\n        this.sameDocument = sameDocument;\n        this.state = state;\n        this.historyState = historyState;\n        this.key = key;\n        this.id = id;\n        this.index = index;\n    }\n    getState() {\n        return this.state;\n    }\n    getHistoryState() {\n        return this.historyState;\n    }\n}\n/** Utility function to determine whether two UrlLike have the same hash. */\nfunction isHashChange(from, to) {\n    return (to.hash !== from.hash &&\n        to.hostname === from.hostname &&\n        to.pathname === from.pathname &&\n        to.search === from.search);\n}\nclass InternalNavigationTransition {\n    from;\n    navigationType;\n    finished;\n    committed;\n    finishedResolve;\n    finishedReject;\n    committedResolve;\n    committedReject;\n    constructor(from, navigationType) {\n        this.from = from;\n        this.navigationType = navigationType;\n        this.finished = new Promise((resolve, reject) => {\n            this.finishedReject = reject;\n            this.finishedResolve = resolve;\n        });\n        this.committed = new Promise((resolve, reject) => {\n            this.committedReject = reject;\n            this.committedResolve = resolve;\n        });\n        // All rejections are handled.\n        this.finished.catch(() => { });\n        this.committed.catch(() => { });\n    }\n}\n/**\n * Internal utility class for representing the result of a navigation.\n * Generally equivalent to the \"apiMethodTracker\" in the spec.\n */\nclass InternalNavigationResult {\n    navigation;\n    committedTo = null;\n    committedResolve;\n    committedReject;\n    finishedResolve;\n    finishedReject;\n    committed;\n    finished;\n    get signal() {\n        return this.abortController.signal;\n    }\n    abortController = new AbortController();\n    constructor(navigation) {\n        this.navigation = navigation;\n        this.committed = new Promise((resolve, reject) => {\n            this.committedResolve = (entry) => {\n                this.committedTo = entry;\n                resolve(entry);\n            };\n            this.committedReject = reject;\n        });\n        this.finished = new Promise((resolve, reject) => {\n            this.finishedResolve = () => {\n                if (this.committedTo === null) {\n                    throw new Error('NavigateEvent should have been committed before resolving finished promise.');\n                }\n                resolve(this.committedTo);\n            };\n            this.finishedReject = (reason) => {\n                reject(reason);\n                this.abortController.abort(reason);\n            };\n        });\n        // All rejections are handled.\n        this.committed.catch(() => { });\n        this.finished.catch(() => { });\n    }\n}\n\n/**\n * Public Test Library for unit testing Angular applications. Assumes that you are running\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\n */\n// Reset the test providers and the fake async zone before each test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// beforeEach is only defined when executing the tests\nglobalThis.beforeEach?.(getCleanupHook(false));\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// afterEach is only defined when executing the tests\nglobalThis.afterEach?.(getCleanupHook(true));\nfunction getCleanupHook(expectedTeardownValue) {\n    return () => {\n        const testBed = TestBedImpl.INSTANCE;\n        if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n            testBed.resetTestingModule();\n            resetFakeAsyncZoneIfExists();\n        }\n    };\n}\n\nclass Log {\n    logItems;\n    constructor() {\n        this.logItems = [];\n    }\n    add(value) {\n        this.logItems.push(value);\n    }\n    fn(value) {\n        return () => {\n            this.logItems.push(value);\n        };\n    }\n    clear() {\n        this.logItems = [];\n    }\n    result() {\n        return this.logItems.join('; ');\n    }\n    static \u0275fac = function Log_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || Log)(); };\n    static \u0275prov = /*@__PURE__*/ i0.\u0275\u0275defineInjectable({ token: Log, factory: Log.\u0275fac });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.\u0275setClassMetadata(Log, [{\n        type: Injectable\n    }], () => [], null); })();\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, DeferBlockBehavior, DeferBlockFixture, DeferBlockState, InjectSetupWrapper, TestBed, TestComponentRenderer, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, FakeNavigation as \u0275FakeNavigation, Log as \u0275Log, MetadataOverrider as \u0275MetadataOverrider, getCleanupHook as \u0275getCleanupHook };\n//# sourceMappingURL=testing.mjs.map\n"],
  "mappings": "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",
  "names": ["_Zone", "inject$1", "_a", "_b", "TestingModuleOverride", "_c", "arr", "_setUnknownElementStrictMode", "_setUnknownPropertyStrictMode", "_getUnknownElementStrictMode", "_getUnknownPropertyStrictMode", "getComponentDef$1"]
}
