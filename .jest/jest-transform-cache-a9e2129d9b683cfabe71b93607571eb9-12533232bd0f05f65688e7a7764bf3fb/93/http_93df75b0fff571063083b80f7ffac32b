d0ea8edeb4e4804cdf8d3819dc6925b6
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var http_exports = {};
__export(http_exports, {
  FetchBackend: () => import_module2.FetchBackend,
  HTTP_INTERCEPTORS: () => import_module2.HTTP_INTERCEPTORS,
  HTTP_TRANSFER_CACHE_ORIGIN_MAP: () => HTTP_TRANSFER_CACHE_ORIGIN_MAP,
  HttpBackend: () => import_module2.HttpBackend,
  HttpClient: () => import_module.HttpClient,
  HttpClientJsonpModule: () => import_module2.HttpClientJsonpModule,
  HttpClientModule: () => import_module2.HttpClientModule,
  HttpClientXsrfModule: () => import_module2.HttpClientXsrfModule,
  HttpContext: () => import_module2.HttpContext,
  HttpContextToken: () => import_module2.HttpContextToken,
  HttpErrorResponse: () => import_module.HttpErrorResponse,
  HttpEventType: () => import_module.HttpEventType,
  HttpFeatureKind: () => import_module2.HttpFeatureKind,
  HttpHandler: () => import_module2.HttpHandler,
  HttpHeaderResponse: () => import_module2.HttpHeaderResponse,
  HttpHeaders: () => import_module.HttpHeaders,
  HttpParams: () => import_module.HttpParams,
  HttpRequest: () => import_module.HttpRequest,
  HttpResponse: () => import_module.HttpResponse,
  HttpResponseBase: () => import_module2.HttpResponseBase,
  HttpStatusCode: () => import_module2.HttpStatusCode,
  HttpUrlEncodingCodec: () => import_module2.HttpUrlEncodingCodec,
  HttpXhrBackend: () => import_module2.HttpXhrBackend,
  HttpXsrfTokenExtractor: () => import_module2.HttpXsrfTokenExtractor,
  JsonpClientBackend: () => import_module2.JsonpClientBackend,
  JsonpInterceptor: () => import_module2.JsonpInterceptor,
  httpResource: () => httpResource,
  provideHttpClient: () => import_module2.provideHttpClient,
  withFetch: () => import_module2.withFetch,
  withInterceptors: () => import_module2.withInterceptors,
  withInterceptorsFromDi: () => import_module2.withInterceptorsFromDi,
  withJsonpSupport: () => import_module2.withJsonpSupport,
  withNoXsrfProtection: () => import_module2.withNoXsrfProtection,
  withRequestsMadeViaParent: () => import_module2.withRequestsMadeViaParent,
  withXsrfConfiguration: () => import_module2.withXsrfConfiguration,
  \u0275HTTP_ROOT_INTERCEPTOR_FNS: () => import_module.HTTP_ROOT_INTERCEPTOR_FNS,
  \u0275HttpInterceptingHandler: () => import_module2.HttpInterceptorHandler,
  \u0275HttpInterceptorHandler: () => import_module2.HttpInterceptorHandler,
  \u0275REQUESTS_CONTRIBUTE_TO_STABILITY: () => import_module2.REQUESTS_CONTRIBUTE_TO_STABILITY,
  \u0275withHttpTransferCache: () => withHttpTransferCache
});
module.exports = __toCommonJS(http_exports);
var import_module = require("./module.mjs");
var import_module2 = require("./module.mjs");
var import_core = require("@angular/core");
var import_rxjs = require("rxjs");
var import_operators = require("rxjs/operators");
var import_xhr = require("./xhr.mjs");
/**
 * @license Angular v20.3.16
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */
const httpResource = (() => {
  const jsonFn = makeHttpResourceFn("json");
  jsonFn.arrayBuffer = makeHttpResourceFn("arraybuffer");
  jsonFn.blob = makeHttpResourceFn("blob");
  jsonFn.text = makeHttpResourceFn("text");
  return jsonFn;
})();
function makeHttpResourceFn(responseType) {
  return function httpResource2(request, options) {
    var _a;
    if (ngDevMode && !(options == null ? void 0 : options.injector)) {
      (0, import_core.assertInInjectionContext)(httpResource2);
    }
    const injector = (_a = options == null ? void 0 : options.injector) != null ? _a : (0, import_core.inject)(import_core.Injector);
    return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options == null ? void 0 : options.defaultValue, options == null ? void 0 : options.parse, options == null ? void 0 : options.equal);
  };
}
function normalizeRequest(request, responseType) {
  var _a, _b;
  let unwrappedRequest = typeof request === "function" ? request() : request;
  if (unwrappedRequest === void 0) {
    return void 0;
  } else if (typeof unwrappedRequest === "string") {
    unwrappedRequest = { url: unwrappedRequest };
  }
  const headers = unwrappedRequest.headers instanceof import_module.HttpHeaders ? unwrappedRequest.headers : new import_module.HttpHeaders(unwrappedRequest.headers);
  const params = unwrappedRequest.params instanceof import_module.HttpParams ? unwrappedRequest.params : new import_module.HttpParams({ fromObject: unwrappedRequest.params });
  return new import_module.HttpRequest((_a = unwrappedRequest.method) != null ? _a : "GET", unwrappedRequest.url, (_b = unwrappedRequest.body) != null ? _b : null, {
    headers,
    params,
    reportProgress: unwrappedRequest.reportProgress,
    withCredentials: unwrappedRequest.withCredentials,
    keepalive: unwrappedRequest.keepalive,
    cache: unwrappedRequest.cache,
    priority: unwrappedRequest.priority,
    mode: unwrappedRequest.mode,
    redirect: unwrappedRequest.redirect,
    responseType,
    context: unwrappedRequest.context,
    transferCache: unwrappedRequest.transferCache,
    credentials: unwrappedRequest.credentials,
    referrer: unwrappedRequest.referrer,
    integrity: unwrappedRequest.integrity,
    timeout: unwrappedRequest.timeout
  });
}
class HttpResourceImpl extends import_core.\u0275ResourceImpl {
  constructor(injector, request, defaultValue, parse, equal) {
    super(request, ({ params: request2, abortSignal }) => {
      let sub;
      const onAbort = () => sub.unsubscribe();
      abortSignal.addEventListener("abort", onAbort);
      const stream = (0, import_core.signal)({ value: void 0 }, ...ngDevMode ? [{ debugName: "stream" }] : []);
      let resolve;
      const promise = new Promise((r) => resolve = r);
      const send = (value) => {
        stream.set(value);
        resolve == null ? void 0 : resolve(stream);
        resolve = void 0;
      };
      sub = this.client.request(request2).subscribe({
        next: (event) => {
          switch (event.type) {
            case import_module.HttpEventType.Response:
              this._headers.set(event.headers);
              this._statusCode.set(event.status);
              try {
                send({ value: parse ? parse(event.body) : event.body });
              } catch (error) {
                send({ error: (0, import_core.\u0275encapsulateResourceError)(error) });
              }
              break;
            case import_module.HttpEventType.DownloadProgress:
              this._progress.set(event);
              break;
          }
        },
        error: (error) => {
          if (error instanceof import_module.HttpErrorResponse) {
            this._headers.set(error.headers);
            this._statusCode.set(error.status);
          }
          send({ error });
          abortSignal.removeEventListener("abort", onAbort);
        },
        complete: () => {
          if (resolve) {
            send({
              error: new import_core.\u0275RuntimeError(991, ngDevMode && "Resource completed before producing a value")
            });
          }
          abortSignal.removeEventListener("abort", onAbort);
        }
      });
      return promise;
    }, defaultValue, equal, injector);
    __publicField(this, "client");
    __publicField(this, "_headers", (0, import_core.linkedSignal)(...ngDevMode ? [{
      debugName: "_headers",
      source: this.extRequest,
      computation: () => void 0
    }] : [{
      source: this.extRequest,
      computation: () => void 0
    }]));
    __publicField(this, "_progress", (0, import_core.linkedSignal)(...ngDevMode ? [{
      debugName: "_progress",
      source: this.extRequest,
      computation: () => void 0
    }] : [{
      source: this.extRequest,
      computation: () => void 0
    }]));
    __publicField(this, "_statusCode", (0, import_core.linkedSignal)(...ngDevMode ? [{
      debugName: "_statusCode",
      source: this.extRequest,
      computation: () => void 0
    }] : [{
      source: this.extRequest,
      computation: () => void 0
    }]));
    __publicField(this, "headers", (0, import_core.computed)(() => this.status() === "resolved" || this.status() === "error" ? this._headers() : void 0, ...ngDevMode ? [{ debugName: "headers" }] : []));
    __publicField(this, "progress", this._progress.asReadonly());
    __publicField(this, "statusCode", this._statusCode.asReadonly());
    this.client = injector.get(import_module.HttpClient);
  }
  set(value) {
    super.set(value);
    this._headers.set(void 0);
    this._progress.set(void 0);
    this._statusCode.set(void 0);
  }
}
const HTTP_TRANSFER_CACHE_ORIGIN_MAP = new import_core.InjectionToken(ngDevMode ? "HTTP_TRANSFER_CACHE_ORIGIN_MAP" : "");
const BODY = "b";
const HEADERS = "h";
const STATUS = "s";
const STATUS_TEXT = "st";
const REQ_URL = "u";
const RESPONSE_TYPE = "rt";
const CACHE_OPTIONS = new import_core.InjectionToken(ngDevMode ? "HTTP_TRANSFER_STATE_CACHE_OPTIONS" : "");
const ALLOWED_METHODS = ["GET", "HEAD"];
function transferCacheInterceptorFn(req, next) {
  var _b;
  const _a = (0, import_core.inject)(CACHE_OPTIONS), { isCacheActive } = _a, globalOptions = __objRest(_a, ["isCacheActive"]);
  const { transferCache: requestOptions, method: requestMethod } = req;
  if (!isCacheActive || requestOptions === false || // POST requests are allowed either globally or at request level
  requestMethod === "POST" && !globalOptions.includePostRequests && !requestOptions || requestMethod !== "POST" && !ALLOWED_METHODS.includes(requestMethod) || // Do not cache request that require authorization when includeRequestsWithAuthHeaders is falsey
  !globalOptions.includeRequestsWithAuthHeaders && hasAuthHeaders(req) || ((_b = globalOptions.filter) == null ? void 0 : _b.call(globalOptions, req)) === false) {
    return next(req);
  }
  const transferState = (0, import_core.inject)(import_core.TransferState);
  const originMap = (0, import_core.inject)(HTTP_TRANSFER_CACHE_ORIGIN_MAP, {
    optional: true
  });
  if (typeof ngServerMode !== "undefined" && !ngServerMode && originMap) {
    throw new import_core.\u0275RuntimeError(2803, ngDevMode && "Angular detected that the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token is configured and present in the client side code. Please ensure that this token is only provided in the server code of the application.");
  }
  const requestUrl = typeof ngServerMode !== "undefined" && ngServerMode && originMap ? mapRequestOriginUrl(req.url, originMap) : req.url;
  const storeKey = makeCacheKey(req, requestUrl);
  const response = transferState.get(storeKey, null);
  let headersToInclude = globalOptions.includeHeaders;
  if (typeof requestOptions === "object" && requestOptions.includeHeaders) {
    headersToInclude = requestOptions.includeHeaders;
  }
  if (response) {
    const { [BODY]: undecodedBody, [RESPONSE_TYPE]: responseType, [HEADERS]: httpHeaders, [STATUS]: status, [STATUS_TEXT]: statusText, [REQ_URL]: url } = response;
    let body = undecodedBody;
    switch (responseType) {
      case "arraybuffer":
        body = new TextEncoder().encode(undecodedBody).buffer;
        break;
      case "blob":
        body = new Blob([undecodedBody]);
        break;
    }
    let headers = new import_module.HttpHeaders(httpHeaders);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      headers = appendMissingHeadersDetection(req.url, headers, headersToInclude != null ? headersToInclude : []);
    }
    return (0, import_rxjs.of)(new import_module.HttpResponse({
      body,
      headers,
      status,
      statusText,
      url
    }));
  }
  const event$ = next(req);
  if (typeof ngServerMode !== "undefined" && ngServerMode) {
    return event$.pipe((0, import_operators.tap)((event) => {
      if (event instanceof import_module.HttpResponse) {
        transferState.set(storeKey, {
          [BODY]: event.body,
          [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),
          [STATUS]: event.status,
          [STATUS_TEXT]: event.statusText,
          [REQ_URL]: requestUrl,
          [RESPONSE_TYPE]: req.responseType
        });
      }
    }));
  }
  return event$;
}
function hasAuthHeaders(req) {
  return req.headers.has("authorization") || req.headers.has("proxy-authorization");
}
function getFilteredHeaders(headers, includeHeaders) {
  if (!includeHeaders) {
    return {};
  }
  const headersMap = {};
  for (const key of includeHeaders) {
    const values = headers.getAll(key);
    if (values !== null) {
      headersMap[key] = values;
    }
  }
  return headersMap;
}
function sortAndConcatParams(params) {
  return [...params.keys()].sort().map((k) => `${k}=${params.getAll(k)}`).join("&");
}
function makeCacheKey(request, mappedRequestUrl) {
  const { params, method, responseType } = request;
  const encodedParams = sortAndConcatParams(params);
  let serializedBody = request.serializeBody();
  if (serializedBody instanceof URLSearchParams) {
    serializedBody = sortAndConcatParams(serializedBody);
  } else if (typeof serializedBody !== "string") {
    serializedBody = "";
  }
  const key = [method, responseType, mappedRequestUrl, serializedBody, encodedParams].join("|");
  const hash = generateHash(key);
  return (0, import_core.makeStateKey)(hash);
}
function generateHash(value) {
  let hash = 0;
  for (const char of value) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  return hash.toString();
}
function withHttpTransferCache(cacheOptions) {
  return [
    {
      provide: CACHE_OPTIONS,
      useFactory: () => {
        (0, import_core.\u0275performanceMarkFeature)("NgHttpTransferCache");
        return __spreadValues({ isCacheActive: true }, cacheOptions);
      }
    },
    {
      provide: import_module.HTTP_ROOT_INTERCEPTOR_FNS,
      useValue: transferCacheInterceptorFn,
      multi: true
    },
    {
      provide: import_core.APP_BOOTSTRAP_LISTENER,
      multi: true,
      useFactory: () => {
        const appRef = (0, import_core.inject)(import_core.ApplicationRef);
        const cacheState = (0, import_core.inject)(CACHE_OPTIONS);
        return () => {
          appRef.whenStable().then(() => {
            cacheState.isCacheActive = false;
          });
        };
      }
    }
  ];
}
function appendMissingHeadersDetection(url, headers, headersToInclude) {
  const warningProduced = /* @__PURE__ */ new Set();
  return new Proxy(headers, {
    get(target, prop) {
      const value = Reflect.get(target, prop);
      const methods = /* @__PURE__ */ new Set(["get", "has", "getAll"]);
      if (typeof value !== "function" || !methods.has(prop)) {
        return value;
      }
      return (headerName) => {
        const key = (prop + ":" + headerName).toLowerCase();
        if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {
          warningProduced.add(key);
          const truncatedUrl = (0, import_core.\u0275truncateMiddle)(url);
          console.warn((0, import_core.\u0275formatRuntimeError)(-2802, `Angular detected that the \`${headerName}\` header is accessed, but the value of the header was not transferred from the server to the client by the HttpTransferCache. To include the value of the \`${headerName}\` header for the \`${truncatedUrl}\` request, use the \`includeHeaders\` list. The \`includeHeaders\` can be defined either on a request level by adding the \`transferCache\` parameter, or on an application level by adding the \`httpCacheTransfer.includeHeaders\` argument to the \`provideClientHydration()\` call. `));
        }
        return value.apply(target, [headerName]);
      };
    }
  });
}
function mapRequestOriginUrl(url, originMap) {
  const origin = new URL(url, "resolve://").origin;
  const mappedOrigin = originMap[origin];
  if (!mappedOrigin) {
    return url;
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    verifyMappedOrigin(mappedOrigin);
  }
  return url.replace(origin, mappedOrigin);
}
function verifyMappedOrigin(url) {
  if (new URL(url, "resolve://").pathname !== "/") {
    throw new import_core.\u0275RuntimeError(2804, `Angular detected a URL with a path segment in the value provided for the \`HTTP_TRANSFER_CACHE_ORIGIN_MAP\` token: ${url}. The map should only contain origins without any other segments.`);
  }
}
