{
  "version": 3,
  "sources": ["/Users/cmackey/Documents/midwest.mackey/midwest-mackey-website/node_modules/@angular/common/fesm2022/http.mjs"],
  "sourcesContent": ["/**\n * @license Angular v20.3.16\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { HttpHeaders, HttpParams, HttpRequest, HttpEventType, HttpErrorResponse, HttpClient, HTTP_ROOT_INTERCEPTOR_FNS, HttpResponse } from './module.mjs';\nexport { FetchBackend, HTTP_INTERCEPTORS, HttpBackend, HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, HttpContext, HttpContextToken, HttpFeatureKind, HttpHandler, HttpHeaderResponse, HttpResponseBase, HttpStatusCode, HttpUrlEncodingCodec, HttpXhrBackend, HttpXsrfTokenExtractor, JsonpClientBackend, JsonpInterceptor, provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, withJsonpSupport, withNoXsrfProtection, withRequestsMadeViaParent, withXsrfConfiguration, HttpInterceptorHandler as \u0275HttpInterceptingHandler, HttpInterceptorHandler as \u0275HttpInterceptorHandler, REQUESTS_CONTRIBUTE_TO_STABILITY as \u0275REQUESTS_CONTRIBUTE_TO_STABILITY } from './module.mjs';\nimport { assertInInjectionContext, inject, Injector, \u0275ResourceImpl as _ResourceImpl, linkedSignal, computed, signal, \u0275encapsulateResourceError as _encapsulateResourceError, \u0275RuntimeError as _RuntimeError, InjectionToken, \u0275performanceMarkFeature as _performanceMarkFeature, APP_BOOTSTRAP_LISTENER, ApplicationRef, TransferState, makeStateKey, \u0275truncateMiddle as _truncateMiddle, \u0275formatRuntimeError as _formatRuntimeError } from '@angular/core';\nimport { of } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nimport './xhr.mjs';\n\n/**\n * `httpResource` makes a reactive HTTP request and exposes the request status and response value as\n * a `WritableResource`. By default, it assumes that the backend will return JSON data. To make a\n * request that expects a different kind of data, you can use a sub-constructor of `httpResource`,\n * such as `httpResource.text`.\n *\n * @experimental 19.2\n * @initializerApiFunction\n */\nconst httpResource = (() => {\n    const jsonFn = makeHttpResourceFn('json');\n    jsonFn.arrayBuffer = makeHttpResourceFn('arraybuffer');\n    jsonFn.blob = makeHttpResourceFn('blob');\n    jsonFn.text = makeHttpResourceFn('text');\n    return jsonFn;\n})();\nfunction makeHttpResourceFn(responseType) {\n    return function httpResource(request, options) {\n        if (ngDevMode && !options?.injector) {\n            assertInInjectionContext(httpResource);\n        }\n        const injector = options?.injector ?? inject(Injector);\n        return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options?.defaultValue, options?.parse, options?.equal);\n    };\n}\nfunction normalizeRequest(request, responseType) {\n    let unwrappedRequest = typeof request === 'function' ? request() : request;\n    if (unwrappedRequest === undefined) {\n        return undefined;\n    }\n    else if (typeof unwrappedRequest === 'string') {\n        unwrappedRequest = { url: unwrappedRequest };\n    }\n    const headers = unwrappedRequest.headers instanceof HttpHeaders\n        ? unwrappedRequest.headers\n        : new HttpHeaders(unwrappedRequest.headers);\n    const params = unwrappedRequest.params instanceof HttpParams\n        ? unwrappedRequest.params\n        : new HttpParams({ fromObject: unwrappedRequest.params });\n    return new HttpRequest(unwrappedRequest.method ?? 'GET', unwrappedRequest.url, unwrappedRequest.body ?? null, {\n        headers,\n        params,\n        reportProgress: unwrappedRequest.reportProgress,\n        withCredentials: unwrappedRequest.withCredentials,\n        keepalive: unwrappedRequest.keepalive,\n        cache: unwrappedRequest.cache,\n        priority: unwrappedRequest.priority,\n        mode: unwrappedRequest.mode,\n        redirect: unwrappedRequest.redirect,\n        responseType,\n        context: unwrappedRequest.context,\n        transferCache: unwrappedRequest.transferCache,\n        credentials: unwrappedRequest.credentials,\n        referrer: unwrappedRequest.referrer,\n        integrity: unwrappedRequest.integrity,\n        timeout: unwrappedRequest.timeout,\n    });\n}\nclass HttpResourceImpl extends _ResourceImpl {\n    client;\n    _headers = linkedSignal(...(ngDevMode ? [{ debugName: \"_headers\", source: this.extRequest,\n            computation: () => undefined }] : [{\n            source: this.extRequest,\n            computation: () => undefined,\n        }]));\n    _progress = linkedSignal(...(ngDevMode ? [{ debugName: \"_progress\", source: this.extRequest,\n            computation: () => undefined }] : [{\n            source: this.extRequest,\n            computation: () => undefined,\n        }]));\n    _statusCode = linkedSignal(...(ngDevMode ? [{ debugName: \"_statusCode\", source: this.extRequest,\n            computation: () => undefined }] : [{\n            source: this.extRequest,\n            computation: () => undefined,\n        }]));\n    headers = computed(() => this.status() === 'resolved' || this.status() === 'error' ? this._headers() : undefined, ...(ngDevMode ? [{ debugName: \"headers\" }] : []));\n    progress = this._progress.asReadonly();\n    statusCode = this._statusCode.asReadonly();\n    constructor(injector, request, defaultValue, parse, equal) {\n        super(request, ({ params: request, abortSignal }) => {\n            let sub;\n            // Track the abort listener so it can be removed if the Observable completes (as a memory\n            // optimization).\n            const onAbort = () => sub.unsubscribe();\n            abortSignal.addEventListener('abort', onAbort);\n            // Start off stream as undefined.\n            const stream = signal({ value: undefined }, ...(ngDevMode ? [{ debugName: \"stream\" }] : []));\n            let resolve;\n            const promise = new Promise((r) => (resolve = r));\n            const send = (value) => {\n                stream.set(value);\n                resolve?.(stream);\n                resolve = undefined;\n            };\n            sub = this.client.request(request).subscribe({\n                next: (event) => {\n                    switch (event.type) {\n                        case HttpEventType.Response:\n                            this._headers.set(event.headers);\n                            this._statusCode.set(event.status);\n                            try {\n                                send({ value: parse ? parse(event.body) : event.body });\n                            }\n                            catch (error) {\n                                send({ error: _encapsulateResourceError(error) });\n                            }\n                            break;\n                        case HttpEventType.DownloadProgress:\n                            this._progress.set(event);\n                            break;\n                    }\n                },\n                error: (error) => {\n                    if (error instanceof HttpErrorResponse) {\n                        this._headers.set(error.headers);\n                        this._statusCode.set(error.status);\n                    }\n                    send({ error });\n                    abortSignal.removeEventListener('abort', onAbort);\n                },\n                complete: () => {\n                    if (resolve) {\n                        send({\n                            error: new _RuntimeError(991 /* \u0275RuntimeErrorCode.RESOURCE_COMPLETED_BEFORE_PRODUCING_VALUE */, ngDevMode && 'Resource completed before producing a value'),\n                        });\n                    }\n                    abortSignal.removeEventListener('abort', onAbort);\n                },\n            });\n            return promise;\n        }, defaultValue, equal, injector);\n        this.client = injector.get(HttpClient);\n    }\n    set(value) {\n        super.set(value);\n        this._headers.set(undefined);\n        this._progress.set(undefined);\n        this._statusCode.set(undefined);\n    }\n}\n\n/**\n * If your application uses different HTTP origins to make API calls (via `HttpClient`) on the server and\n * on the client, the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token allows you to establish a mapping\n * between those origins, so that `HttpTransferCache` feature can recognize those requests as the same\n * ones and reuse the data cached on the server during hydration on the client.\n *\n * **Important note**: the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token should *only* be provided in\n * the *server* code of your application (typically in the `app.server.config.ts` script). Angular throws an\n * error if it detects that the token is defined while running on the client.\n *\n * @usageNotes\n *\n * When the same API endpoint is accessed via `http://internal-domain.com:8080` on the server and\n * via `https://external-domain.com` on the client, you can use the following configuration:\n * ```ts\n * // in app.server.config.ts\n * {\n *     provide: HTTP_TRANSFER_CACHE_ORIGIN_MAP,\n *     useValue: {\n *         'http://internal-domain.com:8080': 'https://external-domain.com'\n *     }\n * }\n * ```\n *\n * @publicApi\n */\nconst HTTP_TRANSFER_CACHE_ORIGIN_MAP = new InjectionToken(ngDevMode ? 'HTTP_TRANSFER_CACHE_ORIGIN_MAP' : '');\n/**\n * Keys within cached response data structure.\n */\nconst BODY = 'b';\nconst HEADERS = 'h';\nconst STATUS = 's';\nconst STATUS_TEXT = 'st';\nconst REQ_URL = 'u';\nconst RESPONSE_TYPE = 'rt';\nconst CACHE_OPTIONS = new InjectionToken(ngDevMode ? 'HTTP_TRANSFER_STATE_CACHE_OPTIONS' : '');\n/**\n * A list of allowed HTTP methods to cache.\n */\nconst ALLOWED_METHODS = ['GET', 'HEAD'];\nfunction transferCacheInterceptorFn(req, next) {\n    const { isCacheActive, ...globalOptions } = inject(CACHE_OPTIONS);\n    const { transferCache: requestOptions, method: requestMethod } = req;\n    // In the following situations we do not want to cache the request\n    if (!isCacheActive ||\n        requestOptions === false ||\n        // POST requests are allowed either globally or at request level\n        (requestMethod === 'POST' && !globalOptions.includePostRequests && !requestOptions) ||\n        (requestMethod !== 'POST' && !ALLOWED_METHODS.includes(requestMethod)) ||\n        // Do not cache request that require authorization when includeRequestsWithAuthHeaders is falsey\n        (!globalOptions.includeRequestsWithAuthHeaders && hasAuthHeaders(req)) ||\n        globalOptions.filter?.(req) === false) {\n        return next(req);\n    }\n    const transferState = inject(TransferState);\n    const originMap = inject(HTTP_TRANSFER_CACHE_ORIGIN_MAP, {\n        optional: true,\n    });\n    if (typeof ngServerMode !== 'undefined' && !ngServerMode && originMap) {\n        throw new _RuntimeError(2803 /* RuntimeErrorCode.HTTP_ORIGIN_MAP_USED_IN_CLIENT */, ngDevMode &&\n            'Angular detected that the `HTTP_TRANSFER_CACHE_ORIGIN_MAP` token is configured and ' +\n                'present in the client side code. Please ensure that this token is only provided in the ' +\n                'server code of the application.');\n    }\n    const requestUrl = typeof ngServerMode !== 'undefined' && ngServerMode && originMap\n        ? mapRequestOriginUrl(req.url, originMap)\n        : req.url;\n    const storeKey = makeCacheKey(req, requestUrl);\n    const response = transferState.get(storeKey, null);\n    let headersToInclude = globalOptions.includeHeaders;\n    if (typeof requestOptions === 'object' && requestOptions.includeHeaders) {\n        // Request-specific config takes precedence over the global config.\n        headersToInclude = requestOptions.includeHeaders;\n    }\n    if (response) {\n        const { [BODY]: undecodedBody, [RESPONSE_TYPE]: responseType, [HEADERS]: httpHeaders, [STATUS]: status, [STATUS_TEXT]: statusText, [REQ_URL]: url, } = response;\n        // Request found in cache. Respond using it.\n        let body = undecodedBody;\n        switch (responseType) {\n            case 'arraybuffer':\n                body = new TextEncoder().encode(undecodedBody).buffer;\n                break;\n            case 'blob':\n                body = new Blob([undecodedBody]);\n                break;\n        }\n        // We want to warn users accessing a header provided from the cache\n        // That HttpTransferCache alters the headers\n        // The warning will be logged a single time by HttpHeaders instance\n        let headers = new HttpHeaders(httpHeaders);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            // Append extra logic in dev mode to produce a warning when a header\n            // that was not transferred to the client is accessed in the code via `get`\n            // and `has` calls.\n            headers = appendMissingHeadersDetection(req.url, headers, headersToInclude ?? []);\n        }\n        return of(new HttpResponse({\n            body,\n            headers,\n            status,\n            statusText,\n            url,\n        }));\n    }\n    const event$ = next(req);\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n        // Request not found in cache. Make the request and cache it if on the server.\n        return event$.pipe(tap((event) => {\n            // Only cache successful HTTP responses.\n            if (event instanceof HttpResponse) {\n                transferState.set(storeKey, {\n                    [BODY]: event.body,\n                    [HEADERS]: getFilteredHeaders(event.headers, headersToInclude),\n                    [STATUS]: event.status,\n                    [STATUS_TEXT]: event.statusText,\n                    [REQ_URL]: requestUrl,\n                    [RESPONSE_TYPE]: req.responseType,\n                });\n            }\n        }));\n    }\n    return event$;\n}\n/** @returns true when the requests contains autorization related headers. */\nfunction hasAuthHeaders(req) {\n    return req.headers.has('authorization') || req.headers.has('proxy-authorization');\n}\nfunction getFilteredHeaders(headers, includeHeaders) {\n    if (!includeHeaders) {\n        return {};\n    }\n    const headersMap = {};\n    for (const key of includeHeaders) {\n        const values = headers.getAll(key);\n        if (values !== null) {\n            headersMap[key] = values;\n        }\n    }\n    return headersMap;\n}\nfunction sortAndConcatParams(params) {\n    return [...params.keys()]\n        .sort()\n        .map((k) => `${k}=${params.getAll(k)}`)\n        .join('&');\n}\nfunction makeCacheKey(request, mappedRequestUrl) {\n    // make the params encoded same as a url so it's easy to identify\n    const { params, method, responseType } = request;\n    const encodedParams = sortAndConcatParams(params);\n    let serializedBody = request.serializeBody();\n    if (serializedBody instanceof URLSearchParams) {\n        serializedBody = sortAndConcatParams(serializedBody);\n    }\n    else if (typeof serializedBody !== 'string') {\n        serializedBody = '';\n    }\n    const key = [method, responseType, mappedRequestUrl, serializedBody, encodedParams].join('|');\n    const hash = generateHash(key);\n    return makeStateKey(hash);\n}\n/**\n * A method that returns a hash representation of a string using a variant of DJB2 hash\n * algorithm.\n *\n * This is the same hashing logic that is used to generate component ids.\n */\nfunction generateHash(value) {\n    let hash = 0;\n    for (const char of value) {\n        hash = (Math.imul(31, hash) + char.charCodeAt(0)) << 0;\n    }\n    // Force positive number hash.\n    // 2147483647 = equivalent of Integer.MAX_VALUE.\n    hash += 2147483647 + 1;\n    return hash.toString();\n}\n/**\n * Returns the DI providers needed to enable HTTP transfer cache.\n *\n * By default, when using server rendering, requests are performed twice: once on the server and\n * other one on the browser.\n *\n * When these providers are added, requests performed on the server are cached and reused during the\n * bootstrapping of the application in the browser thus avoiding duplicate requests and reducing\n * load time.\n *\n * @see [Caching data when using HttpClient](guide/ssr#configuring-the-caching-options)\n *\n */\nfunction withHttpTransferCache(cacheOptions) {\n    return [\n        {\n            provide: CACHE_OPTIONS,\n            useFactory: () => {\n                _performanceMarkFeature('NgHttpTransferCache');\n                return { isCacheActive: true, ...cacheOptions };\n            },\n        },\n        {\n            provide: HTTP_ROOT_INTERCEPTOR_FNS,\n            useValue: transferCacheInterceptorFn,\n            multi: true,\n        },\n        {\n            provide: APP_BOOTSTRAP_LISTENER,\n            multi: true,\n            useFactory: () => {\n                const appRef = inject(ApplicationRef);\n                const cacheState = inject(CACHE_OPTIONS);\n                return () => {\n                    appRef.whenStable().then(() => {\n                        cacheState.isCacheActive = false;\n                    });\n                };\n            },\n        },\n    ];\n}\n/**\n * This function will add a proxy to an HttpHeader to intercept calls to get/has\n * and log a warning if the header entry requested has been removed\n */\nfunction appendMissingHeadersDetection(url, headers, headersToInclude) {\n    const warningProduced = new Set();\n    return new Proxy(headers, {\n        get(target, prop) {\n            const value = Reflect.get(target, prop);\n            const methods = new Set(['get', 'has', 'getAll']);\n            if (typeof value !== 'function' || !methods.has(prop)) {\n                return value;\n            }\n            return (headerName) => {\n                // We log when the key has been removed and a warning hasn't been produced for the header\n                const key = (prop + ':' + headerName).toLowerCase(); // e.g. `get:cache-control`\n                if (!headersToInclude.includes(headerName) && !warningProduced.has(key)) {\n                    warningProduced.add(key);\n                    const truncatedUrl = _truncateMiddle(url);\n                    console.warn(_formatRuntimeError(-2802 /* RuntimeErrorCode.HEADERS_ALTERED_BY_TRANSFER_CACHE */, `Angular detected that the \\`${headerName}\\` header is accessed, but the value of the header ` +\n                        `was not transferred from the server to the client by the HttpTransferCache. ` +\n                        `To include the value of the \\`${headerName}\\` header for the \\`${truncatedUrl}\\` request, ` +\n                        `use the \\`includeHeaders\\` list. The \\`includeHeaders\\` can be defined either ` +\n                        `on a request level by adding the \\`transferCache\\` parameter, or on an application ` +\n                        `level by adding the \\`httpCacheTransfer.includeHeaders\\` argument to the ` +\n                        `\\`provideClientHydration()\\` call. `));\n                }\n                // invoking the original method\n                return value.apply(target, [headerName]);\n            };\n        },\n    });\n}\nfunction mapRequestOriginUrl(url, originMap) {\n    const origin = new URL(url, 'resolve://').origin;\n    const mappedOrigin = originMap[origin];\n    if (!mappedOrigin) {\n        return url;\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        verifyMappedOrigin(mappedOrigin);\n    }\n    return url.replace(origin, mappedOrigin);\n}\nfunction verifyMappedOrigin(url) {\n    if (new URL(url, 'resolve://').pathname !== '/') {\n        throw new _RuntimeError(2804 /* RuntimeErrorCode.HTTP_ORIGIN_MAP_CONTAINS_PATH */, 'Angular detected a URL with a path segment in the value provided for the ' +\n            `\\`HTTP_TRANSFER_CACHE_ORIGIN_MAP\\` token: ${url}. The map should only contain origins ` +\n            'without any other segments.');\n    }\n}\n\nexport { HTTP_TRANSFER_CACHE_ORIGIN_MAP, HttpClient, HttpErrorResponse, HttpEventType, HttpHeaders, HttpParams, HttpRequest, HttpResponse, httpResource, HTTP_ROOT_INTERCEPTOR_FNS as \u0275HTTP_ROOT_INTERCEPTOR_FNS, withHttpTransferCache as \u0275withHttpTransferCache };\n//# sourceMappingURL=http.mjs.map\n"],
  "mappings": "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",
  "names": ["import_module", "httpResource", "_ResourceImpl", "request", "_encapsulateResourceError", "_RuntimeError", "_performanceMarkFeature", "_truncateMiddle", "_formatRuntimeError"]
}
