17c4f5e7ba9000b3e18322a86b5e7c98
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var platform_browser_exports = {};
__export(platform_browser_exports, {
  BrowserModule: () => import_browser.BrowserModule,
  By: () => By,
  DomSanitizer: () => DomSanitizer,
  EVENT_MANAGER_PLUGINS: () => import_dom_renderer.EVENT_MANAGER_PLUGINS,
  EventManager: () => import_dom_renderer2.EventManager,
  EventManagerPlugin: () => import_dom_renderer.EventManagerPlugin,
  HAMMER_GESTURE_CONFIG: () => HAMMER_GESTURE_CONFIG,
  HAMMER_LOADER: () => HAMMER_LOADER,
  HammerGestureConfig: () => HammerGestureConfig,
  HammerModule: () => HammerModule,
  HydrationFeatureKind: () => HydrationFeatureKind,
  Meta: () => Meta,
  REMOVE_STYLES_ON_COMPONENT_DESTROY: () => import_dom_renderer2.REMOVE_STYLES_ON_COMPONENT_DESTROY,
  Title: () => Title,
  VERSION: () => VERSION,
  bootstrapApplication: () => import_browser.bootstrapApplication,
  createApplication: () => import_browser.createApplication,
  disableDebugTools: () => disableDebugTools,
  enableDebugTools: () => enableDebugTools,
  platformBrowser: () => import_browser.platformBrowser,
  provideClientHydration: () => provideClientHydration,
  provideProtractorTestingSupport: () => import_browser.provideProtractorTestingSupport,
  withEventReplay: () => withEventReplay,
  withHttpTransferCacheOptions: () => withHttpTransferCacheOptions,
  withI18nSupport: () => withI18nSupport,
  withIncrementalHydration: () => withIncrementalHydration,
  withNoHttpTransferCache: () => withNoHttpTransferCache,
  \u0275BrowserDomAdapter: () => import_browser.BrowserDomAdapter,
  \u0275BrowserGetTestability: () => import_browser.BrowserGetTestability,
  \u0275DomEventsPlugin: () => import_dom_renderer2.DomEventsPlugin,
  \u0275DomRendererFactory2: () => import_dom_renderer2.DomRendererFactory2,
  \u0275DomSanitizerImpl: () => DomSanitizerImpl,
  \u0275HammerGesturesPlugin: () => HammerGesturesPlugin,
  \u0275KeyEventsPlugin: () => import_browser.KeyEventsPlugin,
  \u0275SharedStylesHost: () => import_dom_renderer2.SharedStylesHost,
  \u0275getDOM: () => import_common2.\u0275getDOM
});
module.exports = __toCommonJS(platform_browser_exports);
var import_browser = require("./browser.mjs");
var import_common = require("@angular/common");
var import_common2 = require("@angular/common");
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
var import_dom_renderer = require("./dom_renderer.mjs");
var import_dom_renderer2 = require("./dom_renderer.mjs");
var import_http = require("@angular/common/http");
/**
 * @license Angular v20.3.16
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */
const _Meta = class _Meta {
  constructor(_doc) {
    __publicField(this, "_doc");
    __publicField(this, "_dom");
    this._doc = _doc;
    this._dom = (0, import_common.\u0275getDOM)();
  }
  /**
   * Retrieves or creates a specific `<meta>` tag element in the current HTML document.
   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
   * values in the provided tag definition, and verifies that all other attribute values are equal.
   * If an existing element is found, it is returned and is not modified in any way.
   * @param tag The definition of a `<meta>` element to match or create.
   * @param forceCreation True to create a new element without checking whether one already exists.
   * @returns The existing element with the same attributes and values if found,
   * the new element if no match is found, or `null` if the tag parameter is not defined.
   */
  addTag(tag, forceCreation = false) {
    if (!tag)
      return null;
    return this._getOrCreateElement(tag, forceCreation);
  }
  /**
   * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.
   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
   * values in the provided tag definition, and verifies that all other attribute values are equal.
   * @param tags An array of tag definitions to match or create.
   * @param forceCreation True to create new elements without checking whether they already exist.
   * @returns The matching elements if found, or the new elements.
   */
  addTags(tags, forceCreation = false) {
    if (!tags)
      return [];
    return tags.reduce((result, tag) => {
      if (tag) {
        result.push(this._getOrCreateElement(tag, forceCreation));
      }
      return result;
    }, []);
  }
  /**
   * Retrieves a `<meta>` tag element in the current HTML document.
   * @param attrSelector The tag attribute and value to match against, in the format
   * `"tag_attribute='value string'"`.
   * @returns The matching element, if any.
   */
  getTag(attrSelector) {
    if (!attrSelector)
      return null;
    return this._doc.querySelector(`meta[${attrSelector}]`) || null;
  }
  /**
   * Retrieves a set of `<meta>` tag elements in the current HTML document.
   * @param attrSelector The tag attribute and value to match against, in the format
   * `"tag_attribute='value string'"`.
   * @returns The matching elements, if any.
   */
  getTags(attrSelector) {
    if (!attrSelector)
      return [];
    const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
    return list ? [].slice.call(list) : [];
  }
  /**
   * Modifies an existing `<meta>` tag element in the current HTML document.
   * @param tag The tag description with which to replace the existing tag content.
   * @param selector A tag attribute and value to match against, to identify
   * an existing tag. A string in the format `"tag_attribute=`value string`"`.
   * If not supplied, matches a tag with the same `name` or `property` attribute value as the
   * replacement tag.
   * @return The modified element.
   */
  updateTag(tag, selector) {
    if (!tag)
      return null;
    selector = selector || this._parseSelector(tag);
    const meta = this.getTag(selector);
    if (meta) {
      return this._setMetaElementAttributes(tag, meta);
    }
    return this._getOrCreateElement(tag, true);
  }
  /**
   * Removes an existing `<meta>` tag element from the current HTML document.
   * @param attrSelector A tag attribute and value to match against, to identify
   * an existing tag. A string in the format `"tag_attribute=`value string`"`.
   */
  removeTag(attrSelector) {
    this.removeTagElement(this.getTag(attrSelector));
  }
  /**
   * Removes an existing `<meta>` tag element from the current HTML document.
   * @param meta The tag definition to match against to identify an existing tag.
   */
  removeTagElement(meta) {
    if (meta) {
      this._dom.remove(meta);
    }
  }
  _getOrCreateElement(meta, forceCreation = false) {
    if (!forceCreation) {
      const selector = this._parseSelector(meta);
      const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
      if (elem !== void 0)
        return elem;
    }
    const element = this._dom.createElement("meta");
    this._setMetaElementAttributes(meta, element);
    const head = this._doc.getElementsByTagName("head")[0];
    head.appendChild(element);
    return element;
  }
  _setMetaElementAttributes(tag, el) {
    Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
    return el;
  }
  _parseSelector(tag) {
    const attr = tag.name ? "name" : "property";
    return `${attr}="${tag[attr]}"`;
  }
  _containsAttributes(tag, elem) {
    return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
  }
  _getMetaKeyMap(prop) {
    return META_KEYS_MAP[prop] || prop;
  }
};
__publicField(_Meta, "\u0275fac", i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _Meta, deps: [{ token: import_common.DOCUMENT }], target: i0.\u0275\u0275FactoryTarget.Injectable }));
__publicField(_Meta, "\u0275prov", i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _Meta, providedIn: "root" }));
let Meta = _Meta;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: Meta, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}], ctorParameters: () => [{ type: void 0, decorators: [{
  type: import_core.Inject,
  args: [import_common.DOCUMENT]
}] }] });
const META_KEYS_MAP = {
  httpEquiv: "http-equiv"
};
const _Title = class _Title {
  constructor(_doc) {
    __publicField(this, "_doc");
    this._doc = _doc;
  }
  /**
   * Get the title of the current HTML document.
   */
  getTitle() {
    return this._doc.title;
  }
  /**
   * Set the title of the current HTML document.
   * @param newTitle
   */
  setTitle(newTitle) {
    this._doc.title = newTitle || "";
  }
};
__publicField(_Title, "\u0275fac", i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _Title, deps: [{ token: import_common.DOCUMENT }], target: i0.\u0275\u0275FactoryTarget.Injectable }));
__publicField(_Title, "\u0275prov", i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _Title, providedIn: "root" }));
let Title = _Title;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: Title, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}], ctorParameters: () => [{ type: void 0, decorators: [{
  type: import_core.Inject,
  args: [import_common.DOCUMENT]
}] }] });
function exportNgVar(name, value) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const ng = import_core.\u0275global["ng"] = import_core.\u0275global["ng"] || {};
    ng[name] = value;
  }
}
class ChangeDetectionPerfRecord {
  constructor(msPerTick, numTicks) {
    __publicField(this, "msPerTick");
    __publicField(this, "numTicks");
    this.msPerTick = msPerTick;
    this.numTicks = numTicks;
  }
}
class AngularProfiler {
  constructor(ref) {
    __publicField(this, "appRef");
    this.appRef = ref.injector.get(import_core.ApplicationRef);
  }
  // tslint:disable:no-console
  /**
   * Exercises change detection in a loop and then prints the average amount of
   * time in milliseconds how long a single round of change detection takes for
   * the current state of the UI. It runs a minimum of 5 rounds for a minimum
   * of 500 milliseconds.
   *
   * Optionally, a user may pass a `config` parameter containing a map of
   * options. Supported options are:
   *
   * `record` (boolean) - causes the profiler to record a CPU profile while
   * it exercises the change detector. Example:
   *
   * ```ts
   * ng.profiler.timeChangeDetection({record: true})
   * ```
   */
  timeChangeDetection(config) {
    const record = config && config["record"];
    const profileName = "Change Detection";
    if (record && "profile" in console && typeof console.profile === "function") {
      console.profile(profileName);
    }
    const start = performance.now();
    let numTicks = 0;
    while (numTicks < 5 || performance.now() - start < 500) {
      this.appRef.tick();
      numTicks++;
    }
    const end = performance.now();
    if (record && "profileEnd" in console && typeof console.profileEnd === "function") {
      console.profileEnd(profileName);
    }
    const msPerTick = (end - start) / numTicks;
    console.log(`ran ${numTicks} change detection cycles`);
    console.log(`${msPerTick.toFixed(2)} ms per check`);
    return new ChangeDetectionPerfRecord(msPerTick, numTicks);
  }
}
const PROFILER_GLOBAL_NAME = "profiler";
function enableDebugTools(ref) {
  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
  return ref;
}
function disableDebugTools() {
  exportNgVar(PROFILER_GLOBAL_NAME, null);
}
class By {
  /**
   * Match all nodes.
   *
   * @usageNotes
   * ### Example
   *
   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
   */
  static all() {
    return () => true;
  }
  /**
   * Match elements by the given CSS selector.
   *
   * @usageNotes
   * ### Example
   *
   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
   */
  static css(selector) {
    return (debugElement) => {
      return debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;
    };
  }
  /**
   * Match nodes that have the given directive present.
   *
   * @usageNotes
   * ### Example
   *
   * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
   */
  static directive(type) {
    return (debugNode) => debugNode.providerTokens.indexOf(type) !== -1;
  }
}
function elementMatches(n, selector) {
  if ((0, import_common.\u0275getDOM)().isElementNode(n)) {
    return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
  }
  return false;
}
const EVENT_NAMES = {
  // pan
  "pan": true,
  "panstart": true,
  "panmove": true,
  "panend": true,
  "pancancel": true,
  "panleft": true,
  "panright": true,
  "panup": true,
  "pandown": true,
  // pinch
  "pinch": true,
  "pinchstart": true,
  "pinchmove": true,
  "pinchend": true,
  "pinchcancel": true,
  "pinchin": true,
  "pinchout": true,
  // press
  "press": true,
  "pressup": true,
  // rotate
  "rotate": true,
  "rotatestart": true,
  "rotatemove": true,
  "rotateend": true,
  "rotatecancel": true,
  // swipe
  "swipe": true,
  "swipeleft": true,
  "swiperight": true,
  "swipeup": true,
  "swipedown": true,
  // tap
  "tap": true,
  "doubletap": true
};
const HAMMER_GESTURE_CONFIG = new import_core.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerGestureConfig" : "");
const HAMMER_LOADER = new import_core.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerLoader" : "");
const _HammerGestureConfig = class _HammerGestureConfig {
  constructor() {
    /**
     * A set of supported event names for gestures to be used in Angular.
     * Angular supports all built-in recognizers, as listed in
     * [HammerJS documentation](https://hammerjs.github.io/).
     */
    __publicField(this, "events", []);
    /**
     * Maps gesture event names to a set of configuration options
     * that specify overrides to the default values for specific properties.
     *
     * The key is a supported event name to be configured,
     * and the options object contains a set of properties, with override values
     * to be applied to the named recognizer event.
     * For example, to disable recognition of the rotate event, specify
     *  `{"rotate": {"enable": false}}`.
     *
     * Properties that are not present take the HammerJS default values.
     * For information about which properties are supported for which events,
     * and their allowed and default values, see
     * [HammerJS documentation](https://hammerjs.github.io/).
     *
     */
    __publicField(this, "overrides", {});
    /**
     * Properties whose default values can be overridden for a given event.
     * Different sets of properties apply to different events.
     * For information about which properties are supported for which events,
     * and their allowed and default values, see
     * [HammerJS documentation](https://hammerjs.github.io/).
     */
    __publicField(this, "options");
  }
  /**
   * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
   * and attaches it to a given HTML element.
   * @param element The element that will recognize gestures.
   * @returns A HammerJS event-manager object.
   */
  buildHammer(element) {
    const mc = new Hammer(element, this.options);
    mc.get("pinch").set({ enable: true });
    mc.get("rotate").set({ enable: true });
    for (const eventName in this.overrides) {
      mc.get(eventName).set(this.overrides[eventName]);
    }
    return mc;
  }
};
__publicField(_HammerGestureConfig, "\u0275fac", i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _HammerGestureConfig, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable }));
__publicField(_HammerGestureConfig, "\u0275prov", i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _HammerGestureConfig }));
let HammerGestureConfig = _HammerGestureConfig;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: HammerGestureConfig, decorators: [{
  type: import_core.Injectable
}] });
const _HammerGesturesPlugin = class _HammerGesturesPlugin extends import_dom_renderer.EventManagerPlugin {
  constructor(doc, _config, _injector, loader) {
    super(doc);
    __publicField(this, "_config");
    __publicField(this, "_injector");
    __publicField(this, "loader");
    __publicField(this, "_loaderPromise", null);
    this._config = _config;
    this._injector = _injector;
    this.loader = loader;
  }
  supports(eventName) {
    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
      return false;
    }
    if (!window.Hammer && !this.loader) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        const _console = this._injector.get(import_core.\u0275Console);
        _console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
      }
      return false;
    }
    return true;
  }
  addEventListener(element, eventName, handler) {
    const zone = this.manager.getZone();
    eventName = eventName.toLowerCase();
    if (!window.Hammer && this.loader) {
      this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
      let cancelRegistration = false;
      let deregister = () => {
        cancelRegistration = true;
      };
      zone.runOutsideAngular(() => this._loaderPromise.then(() => {
        if (!window.Hammer) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            const _console = this._injector.get(import_core.\u0275Console);
            _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
          }
          deregister = () => {
          };
          return;
        }
        if (!cancelRegistration) {
          deregister = this.addEventListener(element, eventName, handler);
        }
      }).catch(() => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const _console = this._injector.get(import_core.\u0275Console);
          _console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
        }
        deregister = () => {
        };
      }));
      return () => {
        deregister();
      };
    }
    return zone.runOutsideAngular(() => {
      const mc = this._config.buildHammer(element);
      const callback = function(eventObj) {
        zone.runGuarded(function() {
          handler(eventObj);
        });
      };
      mc.on(eventName, callback);
      return () => {
        mc.off(eventName, callback);
        if (typeof mc.destroy === "function") {
          mc.destroy();
        }
      };
    });
  }
  isCustomEvent(eventName) {
    return this._config.events.indexOf(eventName) > -1;
  }
};
__publicField(_HammerGesturesPlugin, "\u0275fac", i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _HammerGesturesPlugin, deps: [{ token: import_common.DOCUMENT }, { token: HAMMER_GESTURE_CONFIG }, { token: i0.Injector }, { token: HAMMER_LOADER, optional: true }], target: i0.\u0275\u0275FactoryTarget.Injectable }));
__publicField(_HammerGesturesPlugin, "\u0275prov", i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _HammerGesturesPlugin }));
let HammerGesturesPlugin = _HammerGesturesPlugin;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: HammerGesturesPlugin, decorators: [{
  type: import_core.Injectable
}], ctorParameters: () => [{ type: void 0, decorators: [{
  type: import_core.Inject,
  args: [import_common.DOCUMENT]
}] }, { type: HammerGestureConfig, decorators: [{
  type: import_core.Inject,
  args: [HAMMER_GESTURE_CONFIG]
}] }, { type: i0.Injector }, { type: void 0, decorators: [{
  type: import_core.Optional
}, {
  type: import_core.Inject,
  args: [HAMMER_LOADER]
}] }] });
const _HammerModule = class _HammerModule {
};
__publicField(_HammerModule, "\u0275fac", i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _HammerModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule }));
__publicField(_HammerModule, "\u0275mod", i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.16", ngImport: i0, type: _HammerModule }));
__publicField(_HammerModule, "\u0275inj", i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _HammerModule, providers: [
  {
    provide: import_dom_renderer.EVENT_MANAGER_PLUGINS,
    useClass: HammerGesturesPlugin,
    multi: true,
    deps: [import_common.DOCUMENT, HAMMER_GESTURE_CONFIG, import_core.Injector, [new import_core.Optional(), HAMMER_LOADER]]
  },
  { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig }
] }));
let HammerModule = _HammerModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: HammerModule, decorators: [{
  type: import_core.NgModule,
  args: [{
    providers: [
      {
        provide: import_dom_renderer.EVENT_MANAGER_PLUGINS,
        useClass: HammerGesturesPlugin,
        multi: true,
        deps: [import_common.DOCUMENT, HAMMER_GESTURE_CONFIG, import_core.Injector, [new import_core.Optional(), HAMMER_LOADER]]
      },
      { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig }
    ]
  }]
}] });
const _DomSanitizer = class _DomSanitizer {
};
__publicField(_DomSanitizer, "\u0275fac", i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _DomSanitizer, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable }));
__publicField(_DomSanitizer, "\u0275prov", i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _DomSanitizer, providedIn: "root", useExisting: i0.forwardRef(() => DomSanitizerImpl) }));
let DomSanitizer = _DomSanitizer;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: DomSanitizer, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root", useExisting: (0, import_core.forwardRef)(() => DomSanitizerImpl) }]
}] });
const _DomSanitizerImpl = class _DomSanitizerImpl extends DomSanitizer {
  constructor(_doc) {
    super();
    __publicField(this, "_doc");
    this._doc = _doc;
  }
  sanitize(ctx, value) {
    if (value == null)
      return null;
    switch (ctx) {
      case import_core.SecurityContext.NONE:
        return value;
      case import_core.SecurityContext.HTML:
        if ((0, import_core.\u0275allowSanitizationBypassAndThrow)(
          value,
          "HTML"
          /* BypassType.Html */
        )) {
          return (0, import_core.\u0275unwrapSafeValue)(value);
        }
        return (0, import_core.\u0275_sanitizeHtml)(this._doc, String(value)).toString();
      case import_core.SecurityContext.STYLE:
        if ((0, import_core.\u0275allowSanitizationBypassAndThrow)(
          value,
          "Style"
          /* BypassType.Style */
        )) {
          return (0, import_core.\u0275unwrapSafeValue)(value);
        }
        return value;
      case import_core.SecurityContext.SCRIPT:
        if ((0, import_core.\u0275allowSanitizationBypassAndThrow)(
          value,
          "Script"
          /* BypassType.Script */
        )) {
          return (0, import_core.\u0275unwrapSafeValue)(value);
        }
        throw new import_core.\u0275RuntimeError(5200, (typeof ngDevMode === "undefined" || ngDevMode) && "unsafe value used in a script context");
      case import_core.SecurityContext.URL:
        if ((0, import_core.\u0275allowSanitizationBypassAndThrow)(
          value,
          "URL"
          /* BypassType.Url */
        )) {
          return (0, import_core.\u0275unwrapSafeValue)(value);
        }
        return (0, import_core.\u0275_sanitizeUrl)(String(value));
      case import_core.SecurityContext.RESOURCE_URL:
        if ((0, import_core.\u0275allowSanitizationBypassAndThrow)(
          value,
          "ResourceURL"
          /* BypassType.ResourceUrl */
        )) {
          return (0, import_core.\u0275unwrapSafeValue)(value);
        }
        throw new import_core.\u0275RuntimeError(5201, (typeof ngDevMode === "undefined" || ngDevMode) && `unsafe value used in a resource URL context (see ${import_core.\u0275XSS_SECURITY_URL})`);
      default:
        throw new import_core.\u0275RuntimeError(5202, (typeof ngDevMode === "undefined" || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${import_core.\u0275XSS_SECURITY_URL})`);
    }
  }
  bypassSecurityTrustHtml(value) {
    return (0, import_core.\u0275bypassSanitizationTrustHtml)(value);
  }
  bypassSecurityTrustStyle(value) {
    return (0, import_core.\u0275bypassSanitizationTrustStyle)(value);
  }
  bypassSecurityTrustScript(value) {
    return (0, import_core.\u0275bypassSanitizationTrustScript)(value);
  }
  bypassSecurityTrustUrl(value) {
    return (0, import_core.\u0275bypassSanitizationTrustUrl)(value);
  }
  bypassSecurityTrustResourceUrl(value) {
    return (0, import_core.\u0275bypassSanitizationTrustResourceUrl)(value);
  }
};
__publicField(_DomSanitizerImpl, "\u0275fac", i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _DomSanitizerImpl, deps: [{ token: import_common.DOCUMENT }], target: i0.\u0275\u0275FactoryTarget.Injectable }));
__publicField(_DomSanitizerImpl, "\u0275prov", i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _DomSanitizerImpl, providedIn: "root" }));
let DomSanitizerImpl = _DomSanitizerImpl;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: DomSanitizerImpl, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}], ctorParameters: () => [{ type: void 0, decorators: [{
  type: import_core.Inject,
  args: [import_common.DOCUMENT]
}] }] });
var HydrationFeatureKind;
(function(HydrationFeatureKind2) {
  HydrationFeatureKind2[HydrationFeatureKind2["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
  HydrationFeatureKind2[HydrationFeatureKind2["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
  HydrationFeatureKind2[HydrationFeatureKind2["I18nSupport"] = 2] = "I18nSupport";
  HydrationFeatureKind2[HydrationFeatureKind2["EventReplay"] = 3] = "EventReplay";
  HydrationFeatureKind2[HydrationFeatureKind2["IncrementalHydration"] = 4] = "IncrementalHydration";
})(HydrationFeatureKind || (HydrationFeatureKind = {}));
function hydrationFeature(\u0275kind, \u0275providers = [], \u0275options = {}) {
  return { \u0275kind, \u0275providers };
}
function withNoHttpTransferCache() {
  return hydrationFeature(HydrationFeatureKind.NoHttpTransferCache);
}
function withHttpTransferCacheOptions(options) {
  return hydrationFeature(HydrationFeatureKind.HttpTransferCacheOptions, (0, import_http.\u0275withHttpTransferCache)(options));
}
function withI18nSupport() {
  return hydrationFeature(HydrationFeatureKind.I18nSupport, (0, import_core.\u0275withI18nSupport)());
}
function withEventReplay() {
  return hydrationFeature(HydrationFeatureKind.EventReplay, (0, import_core.\u0275withEventReplay)());
}
function withIncrementalHydration() {
  return hydrationFeature(HydrationFeatureKind.IncrementalHydration, (0, import_core.\u0275withIncrementalHydration)());
}
function provideZoneJsCompatibilityDetector() {
  return [
    {
      provide: import_core.ENVIRONMENT_INITIALIZER,
      useValue: () => {
        const ngZone = (0, import_core.inject)(import_core.NgZone);
        const isZoneless = (0, import_core.inject)(import_core.\u0275ZONELESS_ENABLED);
        if (!isZoneless && ngZone.constructor !== import_core.NgZone) {
          const console2 = (0, import_core.inject)(import_core.\u0275Console);
          const message = (0, import_core.\u0275formatRuntimeError)(-5e3, "Angular detected that hydration was enabled for an application that uses a custom or a noop Zone.js implementation. This is not yet a fully supported configuration.");
          console2.warn(message);
        }
      },
      multi: true
    }
  ];
}
function provideEnabledBlockingInitialNavigationDetector() {
  return [
    {
      provide: import_core.ENVIRONMENT_INITIALIZER,
      useValue: () => {
        const isEnabledBlockingInitialNavigation = (0, import_core.inject)(import_core.\u0275IS_ENABLED_BLOCKING_INITIAL_NAVIGATION, {
          optional: true
        });
        if (isEnabledBlockingInitialNavigation) {
          const console2 = (0, import_core.inject)(import_core.\u0275Console);
          const message = (0, import_core.\u0275formatRuntimeError)(5001, "Configuration error: found both hydration and enabledBlocking initial navigation in the same application, which is a contradiction.");
          console2.warn(message);
        }
      },
      multi: true
    }
  ];
}
function provideClientHydration(...features) {
  const providers = [];
  const featuresKind = /* @__PURE__ */ new Set();
  for (const { \u0275providers, \u0275kind } of features) {
    featuresKind.add(\u0275kind);
    if (\u0275providers.length) {
      providers.push(\u0275providers);
    }
  }
  const hasHttpTransferCacheOptions = featuresKind.has(HydrationFeatureKind.HttpTransferCacheOptions);
  if (typeof ngDevMode !== "undefined" && ngDevMode && featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) && hasHttpTransferCacheOptions) {
    throw new import_core.\u0275RuntimeError(5001, "Configuration error: found both withHttpTransferCacheOptions() and withNoHttpTransferCache() in the same call to provideClientHydration(), which is a contradiction.");
  }
  return (0, import_core.makeEnvironmentProviders)([
    typeof ngDevMode !== "undefined" && ngDevMode ? provideZoneJsCompatibilityDetector() : [],
    typeof ngDevMode !== "undefined" && ngDevMode ? provideEnabledBlockingInitialNavigationDetector() : [],
    (0, import_core.\u0275withDomHydration)(),
    featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) || hasHttpTransferCacheOptions ? [] : (0, import_http.\u0275withHttpTransferCache)({}),
    providers
  ]);
}
const VERSION = /* @__PURE__ */ new import_core.Version("20.3.16");
