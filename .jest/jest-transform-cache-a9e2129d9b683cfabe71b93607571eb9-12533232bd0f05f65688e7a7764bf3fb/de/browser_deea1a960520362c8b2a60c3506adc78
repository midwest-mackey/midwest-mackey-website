d5cc30bf60e0cf1d4fd958c08f5d9ae0
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var browser_exports = {};
__export(browser_exports, {
  BrowserDomAdapter: () => BrowserDomAdapter,
  BrowserGetTestability: () => BrowserGetTestability,
  BrowserModule: () => BrowserModule,
  KeyEventsPlugin: () => KeyEventsPlugin,
  bootstrapApplication: () => bootstrapApplication,
  createApplication: () => createApplication,
  platformBrowser: () => platformBrowser,
  provideProtractorTestingSupport: () => provideProtractorTestingSupport
});
module.exports = __toCommonJS(browser_exports);
var import_common = require("@angular/common");
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
var import_dom_renderer = require("./dom_renderer.mjs");
/**
 * @license Angular v20.3.16
 * (c) 2010-2025 Google LLC. https://angular.dev/
 * License: MIT
 */
class BrowserDomAdapter extends import_common.\u0275DomAdapter {
  constructor() {
    super(...arguments);
    __publicField(this, "supportsDOMEvents", true);
  }
  static makeCurrent() {
    (0, import_common.\u0275setRootDomAdapter)(new BrowserDomAdapter());
  }
  onAndCancel(el, evt, listener, options) {
    el.addEventListener(evt, listener, options);
    return () => {
      el.removeEventListener(evt, listener, options);
    };
  }
  dispatchEvent(el, evt) {
    el.dispatchEvent(evt);
  }
  remove(node) {
    node.remove();
  }
  createElement(tagName, doc) {
    doc = doc || this.getDefaultDocument();
    return doc.createElement(tagName);
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument("fakeTitle");
  }
  getDefaultDocument() {
    return document;
  }
  isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isShadowRoot(node) {
    return node instanceof DocumentFragment;
  }
  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */
  getGlobalEventTarget(doc, target) {
    if (target === "window") {
      return window;
    }
    if (target === "document") {
      return doc;
    }
    if (target === "body") {
      return doc.body;
    }
    return null;
  }
  getBaseHref(doc) {
    const href = getBaseElementHref();
    return href == null ? null : relativePath(href);
  }
  resetBaseElement() {
    baseElement = null;
  }
  getUserAgent() {
    return window.navigator.userAgent;
  }
  getCookie(name) {
    return (0, import_common.\u0275parseCookieValue)(document.cookie, name);
  }
}
let baseElement = null;
function getBaseElementHref() {
  baseElement = baseElement || document.head.querySelector("base");
  return baseElement ? baseElement.getAttribute("href") : null;
}
function relativePath(url) {
  return new URL(url, document.baseURI).pathname;
}
class BrowserGetTestability {
  addToWindow(registry) {
    import_core.\u0275global["getAngularTestability"] = (elem, findInAncestors = true) => {
      const testability = registry.findTestabilityInTree(elem, findInAncestors);
      if (testability == null) {
        throw new import_core.\u0275RuntimeError(5103, (typeof ngDevMode === "undefined" || ngDevMode) && "Could not find testability for element.");
      }
      return testability;
    };
    import_core.\u0275global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
    import_core.\u0275global["getAllAngularRootElements"] = () => registry.getAllRootElements();
    const whenAllStable = (callback) => {
      const testabilities = import_core.\u0275global["getAllAngularTestabilities"]();
      let count = testabilities.length;
      const decrement = function() {
        count--;
        if (count == 0) {
          callback();
        }
      };
      testabilities.forEach((testability) => {
        testability.whenStable(decrement);
      });
    };
    if (!import_core.\u0275global["frameworkStabilizers"]) {
      import_core.\u0275global["frameworkStabilizers"] = [];
    }
    import_core.\u0275global["frameworkStabilizers"].push(whenAllStable);
  }
  findTestabilityInTree(registry, elem, findInAncestors) {
    if (elem == null) {
      return null;
    }
    const t = registry.getTestability(elem);
    if (t != null) {
      return t;
    } else if (!findInAncestors) {
      return null;
    }
    if ((0, import_common.\u0275getDOM)().isShadowRoot(elem)) {
      return this.findTestabilityInTree(registry, elem.host, true);
    }
    return this.findTestabilityInTree(registry, elem.parentElement, true);
  }
}
const _BrowserXhr = class _BrowserXhr {
  build() {
    return new XMLHttpRequest();
  }
};
__publicField(_BrowserXhr, "\u0275fac", i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _BrowserXhr, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable }));
__publicField(_BrowserXhr, "\u0275prov", i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _BrowserXhr }));
let BrowserXhr = _BrowserXhr;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: BrowserXhr, decorators: [{
  type: import_core.Injectable
}] });
const MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
const _keyMap = {
  "\b": "Backspace",
  "	": "Tab",
  "\x7F": "Delete",
  "\x1B": "Escape",
  "Del": "Delete",
  "Esc": "Escape",
  "Left": "ArrowLeft",
  "Right": "ArrowRight",
  "Up": "ArrowUp",
  "Down": "ArrowDown",
  "Menu": "ContextMenu",
  "Scroll": "ScrollLock",
  "Win": "OS"
};
const MODIFIER_KEY_GETTERS = {
  "alt": (event) => event.altKey,
  "control": (event) => event.ctrlKey,
  "meta": (event) => event.metaKey,
  "shift": (event) => event.shiftKey
};
const _KeyEventsPlugin = class _KeyEventsPlugin extends import_dom_renderer.EventManagerPlugin {
  /**
   * Initializes an instance of the browser plug-in.
   * @param doc The document in which key events will be detected.
   */
  constructor(doc) {
    super(doc);
  }
  /**
   * Reports whether a named key event is supported.
   * @param eventName The event name to query.
   * @return True if the named key event is supported.
   */
  supports(eventName) {
    return _KeyEventsPlugin.parseEventName(eventName) != null;
  }
  /**
   * Registers a handler for a specific element and key event.
   * @param element The HTML element to receive event notifications.
   * @param eventName The name of the key event to listen for.
   * @param handler A function to call when the notification occurs. Receives the
   * event object as an argument.
   * @returns The key event that was registered.
   */
  addEventListener(element, eventName, handler, options) {
    const parsedEvent = _KeyEventsPlugin.parseEventName(eventName);
    const outsideHandler = _KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
    return this.manager.getZone().runOutsideAngular(() => {
      return (0, import_common.\u0275getDOM)().onAndCancel(element, parsedEvent["domEventName"], outsideHandler, options);
    });
  }
  /**
   * Parses the user provided full keyboard event definition and normalizes it for
   * later internal use. It ensures the string is all lowercase, converts special
   * characters to a standard spelling, and orders all the values consistently.
   *
   * @param eventName The name of the key event to listen for.
   * @returns an object with the full, normalized string, and the dom event name
   * or null in the case when the event doesn't match a keyboard event.
   */
  static parseEventName(eventName) {
    const parts = eventName.toLowerCase().split(".");
    const domEventName = parts.shift();
    if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
      return null;
    }
    const key = _KeyEventsPlugin._normalizeKey(parts.pop());
    let fullKey = "";
    let codeIX = parts.indexOf("code");
    if (codeIX > -1) {
      parts.splice(codeIX, 1);
      fullKey = "code.";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      const index = parts.indexOf(modifierName);
      if (index > -1) {
        parts.splice(index, 1);
        fullKey += modifierName + ".";
      }
    });
    fullKey += key;
    if (parts.length != 0 || key.length === 0) {
      return null;
    }
    const result = {};
    result["domEventName"] = domEventName;
    result["fullKey"] = fullKey;
    return result;
  }
  /**
   * Determines whether the actual keys pressed match the configured key code string.
   * The `fullKeyCode` event is normalized in the `parseEventName` method when the
   * event is attached to the DOM during the `addEventListener` call. This is unseen
   * by the end user and is normalized for internal consistency and parsing.
   *
   * @param event The keyboard event.
   * @param fullKeyCode The normalized user defined expected key event string
   * @returns boolean.
   */
  static matchEventFullKeyCode(event, fullKeyCode) {
    let keycode = _keyMap[event.key] || event.key;
    let key = "";
    if (fullKeyCode.indexOf("code.") > -1) {
      keycode = event.code;
      key = "code.";
    }
    if (keycode == null || !keycode)
      return false;
    keycode = keycode.toLowerCase();
    if (keycode === " ") {
      keycode = "space";
    } else if (keycode === ".") {
      keycode = "dot";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      if (modifierName !== keycode) {
        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
        if (modifierGetter(event)) {
          key += modifierName + ".";
        }
      }
    });
    key += keycode;
    return key === fullKeyCode;
  }
  /**
   * Configures a handler callback for a key event.
   * @param fullKey The event name that combines all simultaneous keystrokes.
   * @param handler The function that responds to the key event.
   * @param zone The zone in which the event occurred.
   * @returns A callback function.
   */
  static eventCallback(fullKey, handler, zone) {
    return (event) => {
      if (_KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
        zone.runGuarded(() => handler(event));
      }
    };
  }
  /** @internal */
  static _normalizeKey(keyName) {
    return keyName === "esc" ? "escape" : keyName;
  }
};
__publicField(_KeyEventsPlugin, "\u0275fac", i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _KeyEventsPlugin, deps: [{ token: import_common.DOCUMENT }], target: i0.\u0275\u0275FactoryTarget.Injectable }));
__publicField(_KeyEventsPlugin, "\u0275prov", i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _KeyEventsPlugin }));
let KeyEventsPlugin = _KeyEventsPlugin;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: KeyEventsPlugin, decorators: [{
  type: import_core.Injectable
}], ctorParameters: () => [{ type: void 0, decorators: [{
  type: import_core.Inject,
  args: [import_common.DOCUMENT]
}] }] });
function bootstrapApplication(rootComponent, options, context) {
  const config = __spreadValues({
    rootComponent,
    platformRef: context == null ? void 0 : context.platformRef
  }, createProvidersConfig(options));
  if ((typeof ngJitMode === "undefined" || ngJitMode) && typeof fetch === "function") {
    return (0, import_core.\u0275resolveComponentResources)(fetch).catch((error) => {
      console.error(error);
      return Promise.resolve();
    }).then(() => (0, import_core.\u0275internalCreateApplication)(config));
  }
  return (0, import_core.\u0275internalCreateApplication)(config);
}
function createApplication(options) {
  return (0, import_core.\u0275internalCreateApplication)(createProvidersConfig(options));
}
function createProvidersConfig(options) {
  var _a;
  return {
    appProviders: [...BROWSER_MODULE_PROVIDERS, ...(_a = options == null ? void 0 : options.providers) != null ? _a : []],
    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
  };
}
function provideProtractorTestingSupport() {
  return [...TESTABILITY_PROVIDERS];
}
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new import_core.ErrorHandler();
}
function _document() {
  (0, import_core.\u0275setDocument)(document);
  return document;
}
const INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
  { provide: import_core.PLATFORM_ID, useValue: import_common.\u0275PLATFORM_BROWSER_ID },
  { provide: import_core.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
  { provide: import_common.DOCUMENT, useFactory: _document }
];
const platformBrowser = (0, import_core.createPlatformFactory)(import_core.platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
const BROWSER_MODULE_PROVIDERS_MARKER = new import_core.InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "BrowserModule Providers Marker" : "");
const TESTABILITY_PROVIDERS = [
  {
    provide: import_core.\u0275TESTABILITY_GETTER,
    useClass: BrowserGetTestability
  },
  {
    provide: import_core.\u0275TESTABILITY,
    useClass: import_core.Testability,
    deps: [import_core.NgZone, import_core.TestabilityRegistry, import_core.\u0275TESTABILITY_GETTER]
  },
  {
    provide: import_core.Testability,
    // Also provide as `Testability` for backwards-compatibility.
    useClass: import_core.Testability,
    deps: [import_core.NgZone, import_core.TestabilityRegistry, import_core.\u0275TESTABILITY_GETTER]
  }
];
const BROWSER_MODULE_PROVIDERS = [
  { provide: import_core.\u0275INJECTOR_SCOPE, useValue: "root" },
  { provide: import_core.ErrorHandler, useFactory: errorHandler },
  {
    provide: import_dom_renderer.EVENT_MANAGER_PLUGINS,
    useClass: import_dom_renderer.DomEventsPlugin,
    multi: true,
    deps: [import_common.DOCUMENT]
  },
  { provide: import_dom_renderer.EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true, deps: [import_common.DOCUMENT] },
  import_dom_renderer.DomRendererFactory2,
  import_dom_renderer.SharedStylesHost,
  import_dom_renderer.EventManager,
  { provide: import_core.RendererFactory2, useExisting: import_dom_renderer.DomRendererFactory2 },
  { provide: import_common.XhrFactory, useClass: BrowserXhr },
  typeof ngDevMode === "undefined" || ngDevMode ? { provide: BROWSER_MODULE_PROVIDERS_MARKER, useValue: true } : []
];
const _BrowserModule = class _BrowserModule {
  constructor() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const providersAlreadyPresent = (0, import_core.inject)(BROWSER_MODULE_PROVIDERS_MARKER, {
        optional: true,
        skipSelf: true
      });
      if (providersAlreadyPresent) {
        throw new import_core.\u0275RuntimeError(5100, `Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
      }
    }
  }
};
__publicField(_BrowserModule, "\u0275fac", i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _BrowserModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule }));
__publicField(_BrowserModule, "\u0275mod", i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.16", ngImport: i0, type: _BrowserModule, exports: [import_common.CommonModule, import_core.ApplicationModule] }));
__publicField(_BrowserModule, "\u0275inj", i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: _BrowserModule, providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS], imports: [import_common.CommonModule, import_core.ApplicationModule] }));
let BrowserModule = _BrowserModule;
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.16", ngImport: i0, type: BrowserModule, decorators: [{
  type: import_core.NgModule,
  args: [{
    providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
    exports: [import_common.CommonModule, import_core.ApplicationModule]
  }]
}], ctorParameters: () => [] });
