{
  "version": 3,
  "sources": ["/Users/cmackey/Documents/midwest.mackey/midwest-mackey-website/node_modules/@angular/core/fesm2022/effect.mjs"],
  "sourcesContent": ["/**\n * @license Angular v20.3.16\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed, setActiveConsumer, consumerPollProducersForChange } from './signal.mjs';\n\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n    const node = Object.create(LINKED_SIGNAL_NODE);\n    node.source = sourceFn;\n    node.computation = computationFn;\n    if (equalityFn != undefined) {\n        node.equal = equalityFn;\n    }\n    const linkedSignalGetter = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    const getter = linkedSignalGetter;\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n    producerUpdateValueVersion(node);\n    signalSetFn(node, newValue);\n    producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n    producerUpdateValueVersion(node);\n    signalUpdateFn(node, updater);\n    producerMarkClean(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'linkedSignal',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            try {\n                const newSourceValue = node.source();\n                const prev = oldValue === UNSET || oldValue === ERRORED\n                    ? undefined\n                    : {\n                        source: node.sourceValue,\n                        value: oldValue,\n                    };\n                newValue = node.computation(newSourceValue, prev);\n                node.sourceValue = newSourceValue;\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nfunction untracked(nonReactiveReadsFn) {\n    const prevConsumer = setActiveConsumer(null);\n    // We are not trying to catch any particular errors here, just making sure that the consumers\n    // stack is restored in case of errors.\n    try {\n        return nonReactiveReadsFn();\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n\nconst BASE_EFFECT_NODE = \n/* @__PURE__ */ (() => ({\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: true,\n    dirty: true,\n    kind: 'effect',\n}))();\nfunction runEffect(node) {\n    node.dirty = false;\n    if (node.version > 0 && !consumerPollProducersForChange(node)) {\n        return;\n    }\n    node.version++;\n    const prevNode = consumerBeforeComputation(node);\n    try {\n        node.cleanup();\n        node.fn();\n    }\n    finally {\n        consumerAfterComputation(node, prevNode);\n    }\n}\n\nexport { BASE_EFFECT_NODE, createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, runEffect, untracked };\n//# sourceMappingURL=effect.mjs.map\n"],
  "mappings": "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",
  "names": []
}
